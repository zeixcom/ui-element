<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Introduction â€“ UIElement Docs</title>
    <meta name="description" content="Overview and key benefits of UIElement">
    <link rel="stylesheet" href="assets/main.css">
	<script type="module" src="assets/main.js"></script>
</head>
<body>
	<header class="content-grid">
		<h1 class="content">UIElement Docs <small>Version 0.9.4</small></h1>
		
    <nav class="breakout">
        <ul>
            
                <li>
                    <a href="/index.html">
						<span class="icon">ðŸ“˜</span>
						<strong>Introduction</strong>
						<small>Overview and key benefits of UIElement</small>
                    </a>
                </li>

                <li>
                    <a href="/component-library.html">
						<span class="icon">ðŸ§©</span>
						<strong>Component Library</strong>
						<small>Browse all UI components and their usage examples</small>
                    </a>
                </li>
        </ul>
    </nav>
	</header>
    
    <main>
        <section class="hero">
  <h1>Introduction</h1>
  <p class="lead">
    A lightweight solution to bring signals-based reactivity and state management to vanilla Web Components without the need for a complex framework.
  </p>
</section>

<section>

<h2>What is UIElement?</h2>
<p><strong>UIElement</strong> is a lightweight JavaScript library that extends the native <code>HTMLElement</code> class to bring efficient state management and reactivity to your Web Components without client-side rendering or the overhead of a larger framework.</p>
<ul>
<li><strong>Minimalist &amp; Lightweight</strong>: Only what you need to manage state and reactivity.</li>
<li><strong>Signals-Based Reactivity</strong>: Fine-grained updates based on state changes.</li>
<li><strong>Server-Rendered HTML Updates</strong>: Designed to work seamlessly with HTML rendered on the server, only updating what&#39;s necessary on the client side.</li>
</ul>
</section>

<section>

<h2>Why Use UIElement?</h2>
<p>If you&#39;re looking for:</p>
<ul>
<li><strong>Efficient State Management</strong>: No need for large frameworksâ€”just manage client-side state and update HTML efficiently.</li>
<li><strong>Full Control with Web Standards</strong>: Build fully functional components with standard Web Components, no special syntax or magic.</li>
<li><strong>Fine-Grained Reactivity</strong>: Update exactly what&#39;s needed when state changes, reducing re-renders and keeping components performant.</li>
<li><strong>Flexibility to Work with Existing HTML</strong>: Update server-rendered HTML dynamically without re-rendering the entire page.</li>
</ul>
</section>

<section>

<h2>When Should You Use UIElement?</h2>
<p><strong>Best Use Cases:</strong></p>
<ul>
<li><strong>Enhancing Server-Rendered Pages</strong>: When you want to add interactivity to server-rendered pages without doing client-side rendering.</li>
<li><strong>Building Web Components with State</strong>: When creating custom elements that require easy state management.</li>
<li><strong>Projects Prioritizing Performance &amp; Simplicity</strong>: When you want to maintain a simple, fast project without the need for a full JavaScript framework like React, Vue, or Angular.</li>
</ul>
<p><strong>Example Scenarios:</strong></p>
<ul>
<li>Enhancing form interactions without reloading the page.</li>
<li>Adding client-side features like counters, tabs, or toggles to a server-rendered app.</li>
<li>Managing shared state between multiple components on the client.</li>
</ul>
</section>

<section>

<h2>How UIElement Works</h2>
<p>UIElement relies on signals â€” small pieces of reactive state that notify your components when changes occur. This allows for efficient updates to HTML content, handling reactivity only when necessary.</p>
<p><strong>Signals &amp; Effects:</strong> Signals automatically trigger updates to the DOM when they change.</p>
<code-block language="js">
<pre class="language-js"><code>this.set('count', 0) // Define a signal for 'count'
this.first('.count').sync(setText('count')) // Automatically update content when 'count' changes</code></pre>
</code-block>
</section>

<section>

<h2>Benefits of UIElement over Traditional Frameworks</h2>
<ul>
<li><strong>No Virtual DOM</strong>: Unlike React or Vue, UIElement updates HTML directly, avoiding unnecessary renders.</li>
<li><strong>Minimal Overhead</strong>: Since it builds on Web Components, it has minimal impact on performance and bundle size.</li>
<li><strong>Simple API</strong>: Few, clear concepts (signals, effects, context) allow developers to quickly build interactive components.</li>
</ul>
</section>
		  
<section>

<h2>Quick Start Guide</h2>
<p>A simple example to get started:
				
<component-demo>
	<div class="preview">
		<my-counter count="42">
			<p>
				Count: <span class="count"></span>
				Parity: <span class="parity"></span>
			</p>
			<button type="button" class="decrement">âˆ’</button>
			<button type="button" class="increment">+</button>
		</my-counter>
	</div>
	<accordion-panel collapsible>
		<details>
			<summary>
				<div class="summary">Source Code</div>
			</summary>
			<lazy-load src="./examples/my-counter.html">
				<p class="loading">Loading...</p>
			</lazy-load>
		</details>
	</accordion-panel>
</component-demo></p>
</section>
		  
<section>

<h2>Next Steps</h2>
<p>Continue to the <a href="installation-setup.html">Installation &amp; Setup</a> to get started, or dive into <a href="core-concepts.html">Core Concepts</a> to learn more about signals and reactivity.</p>
</section>
    </main>
    <footer>
		<p>Â© 2025 Zeix AG</p>
	</footer>
</body>
</html>