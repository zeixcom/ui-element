<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Data Flow – Le Truc Docs</title>
		<meta name="description" content="Passing state, events, context" />
		<link
			rel="preload"
			href="./assets/main.css?v=mhb2o0ag"
			as="style"
		/>
		<link
			rel="modulepreload"
			href="./assets/main.js?v=mhb2o0ag"
		/>
		<link
			rel="stylesheet"
			href="./assets/main.css?v=mhb2o0ag"
		/>
		<script
			type="module"
			src="./assets/main.js?v=mhb2o0ag"
		></script>
	</head>
	<body class="">
		<context-router>
			<header class="content-grid">
				<a href="#main" class="skiplink visually-hidden">
					Skip to main content
				</a>
				<h1 class="content">
					Le Truc Docs <small>Version 0.14.0</small>
				</h1>
				<section-menu>
	<nav>
		<h2 class="visually-hidden">Main Menu</h2>
		<ol>
			<li>
			<a href="about.html">
				<span class="icon">🤝</span>
				<strong>About</strong>
				<small>License, versioning, getting involved</small>
			</a>
		</li><li>
			<a href="api.html">
				<span class="icon">📚</span>
				<strong>API Reference</strong>
				<small>Functions, types, and constants</small>
			</a>
		</li><li>
			<a href="blog.html">
				<span class="icon">📜</span>
				<strong>Blog</strong>
				<small>Latest articles and updates</small>
			</a>
		</li><li>
			<a href="components.html">
				<span class="icon">🏗️</span>
				<strong>Components</strong>
				<small>Anatomy, lifecycle, signals, effects</small>
			</a>
		</li><li>
			<a href="data-flow.html">
				<span class="icon">🔄</span>
				<strong>Data Flow</strong>
				<small>Passing state, events, context</small>
			</a>
		</li><li>
			<a href="examples.html">
				<span class="icon">🍽️</span>
				<strong>Examples</strong>
				<small>Common use cases and demos</small>
			</a>
		</li><li>
			<a href="getting-started.html">
				<span class="icon">🚀</span>
				<strong>Getting Started</strong>
				<small>Installation, setup, and first steps</small>
			</a>
		</li><li>
			<a href="index.html">
				<span class="icon">📖</span>
				<strong>Introduction</strong>
				<small>Overview and key benefits of Le Truc</small>
			</a>
		</li><li>
			<a href="styling.html">
				<span class="icon">🎨</span>
				<strong>Styling</strong>
				<small>Scoped styles, CSS custom properties</small>
			</a>
		</li>
		</ol>
	</nav>
</section-menu>
				<card-callout class="content danger" hidden>
					<p class="error" role="alert" aria-live="assertive"></p>
				</card-callout>
			</header>
			<main id="main" class="content-grid"><section-hero>

<h1 id="-data-flow">
							<a name="-data-flow" class="anchor" href="#-data-flow">
								<span class="permalink">🔗</span>
								<span class="title">🔄 Data Flow</span>
							</a>
						</h1>
<div>
  <p class="lead"><strong>Learn how Le Truc components can work together seamlessly.</strong> Start with simple parent-child relationships, then explore advanced patterns like custom events and shared state. Build modular, loosely coupled components that communicate efficiently.</p>
  <module-toc>
		<nav>
			<h2>On This Page</h2>
			<ol><li>
			<a href="#component-coordination">Component Coordination</a>
		</li><li>
			<a href="#custom-events">Custom Events</a>
		</li><li>
			<a href="#providing-context">Providing Context</a>
		</li><li>
			<a href="#consuming-context">Consuming Context</a>
		</li><li>
			<a href="#next-steps">Next Steps</a>
		</li></ol>
		</nav>
	</module-toc>
</div>
</section-hero>

<section>

<h2 id="component-coordination">
							<a name="component-coordination" class="anchor" href="#component-coordination">
								<span class="permalink">🔗</span>
								<span class="title">Component Coordination</span>
							</a>
						</h2>
<p>Let&#39;s consider a <strong>product catalog</strong> where users can add items to a shopping cart. We have <strong>three independent components</strong> that work together:</p>
<ul>
<li><code>ModuleCatalog</code> <strong>(Parent)</strong>:<ul>
<li><strong>Tracks all <code>SpinButton</code> components</strong> in its subtree and calculates the total count of items in the shopping cart.</li>
<li><strong>Passes that total</strong> to a <code>BasicButton</code>.</li>
</ul>
</li>
<li><code>BasicButton</code> <strong>(Child)</strong>:<ul>
<li>Displays a <strong>badge</strong> in the top-right corner when the <code>badge</code> property is set.</li>
<li><strong>Does not track any state</strong> – it simply renders whatever value is passed to it.</li>
</ul>
</li>
<li><code>FormSpinbutton</code> <strong>(Child)</strong>:<ul>
<li>Displays an <strong>Add to Cart</strong> button initially.</li>
<li>When an item is added, it transforms into a <strong>stepper</strong> (increment/decrement buttons).</li>
</ul>
</li>
</ul>
<p>Although <code>BasicButton</code> and <code>FormSpinbutton</code> are completely independent, they need to work together. So <code>ModuleCatalog</code> <strong>coordinates the data flow between them</strong>.</p>
<h3 id="parent-component-modulecatalog">
							<a name="parent-component-modulecatalog" class="anchor" href="#parent-component-modulecatalog">
								<span class="permalink">🔗</span>
								<span class="title">Parent Component: ModuleCatalog</span>
							</a>
						</h3>
<p>The <strong>parent component (<code>ModuleCatalog</code>) knows about its children</strong>, meaning it can <strong>read state from and pass state to</strong> them.</p>
<p>First, we need to observe the quantities of all <code>FormSpinbutton</code> components. For this, we create a signal of all children matching the <code>form-spinbutton</code> selector:</p>
<p><strong>CODE_BLOCK_PLACEHOLDER_0</strong></p>
<p>The <code>fromDescendants()</code> function returns a signal of the reduced array of all matching elements. In contrast to a static <code>querySelectorAll()</code> call, the <code>fromDescendants()</code> function is reactive and updates whenever new elements are added or removed from the DOM.</p>
<p>Then, we need to convert the total of all product quantities to a string and pass it on to the <code>BasicButton</code> component. In Le Truc we use the <code>pass()</code> function to share state across components:</p>
<p><strong>CODE_BLOCK_PLACEHOLDER_1</strong></p>
<p>Allright, that&#39;s it!</p>
<ul>
<li>Whenever one of the <code>value</code> signals of a <code>&lt;form-spinbutton&gt;</code> updates, the total in the badge of <code>&lt;basic-button&gt;</code> automatically updates.</li>
<li>No need for event listeners or manual updates!</li>
</ul>
<h3 id="child-component-basicbutton">
							<a name="child-component-basicbutton" class="anchor" href="#child-component-basicbutton">
								<span class="permalink">🔗</span>
								<span class="title">Child Component: BasicButton</span>
							</a>
						</h3>
<p>The <code>BasicButton</code> component <strong>displays a badge when needed</strong> – it does not know about any other component nor track state itself. It just exposes a reactive properties <code>badge</code> of type <code>string</code> and <code>disabled</code> of type <code>boolean</code> and has effects to react to state changes that updates the DOM subtree.</p>
<p><strong>CODE_BLOCK_PLACEHOLDER_2</strong></p>
<ul>
<li>Whenever the <code>disabled</code> property is updated by a parent component, the button is disabled or enabled.</li>
<li>Whenever the <code>badge</code> property is updated by a parent component, the badge text updates.</li>
<li>If <code>badge</code> is an empty string, the badge indicator is hidden (via CSS).</li>
</ul>
<h3 id="child-component-formspinbutton">
							<a name="child-component-formspinbutton" class="anchor" href="#child-component-formspinbutton">
								<span class="permalink">🔗</span>
								<span class="title">Child Component: FormSpinbutton</span>
							</a>
						</h3>
<p>The <code>FormSpinbutton</code> component reacts to user interactions and exposes a reactive property <code>value</code> of type <code>number</code>. It updates its own internal DOM subtree, but doesn&#39;t know about any other component nor where the value is used.</p>
<p><strong>CODE_BLOCK_PLACEHOLDER_3</strong></p>
<ul>
<li>Whenever the user clicks a button or presses a handled key, the value property is updated.</li>
<li>The component sets hidden and disabled states of buttons and updates the text of the <code>.value</code> element.</li>
</ul>
<h3 id="full-example">
							<a name="full-example" class="anchor" href="#full-example">
								<span class="permalink">🔗</span>
								<span class="title">Full Example</span>
							</a>
						</h3>
<p>Here&#39;s how everything comes together:</p>
<ul>
<li>Each <code>FormSpinbutton</code> tracks its own value.</li>
<li>The <code>ModuleCatalog</code> sums all quantities and passes the total to <code>BasicButton</code>.</li>
<li>The <code>BasicButton</code> displays the total if it&#39;s greater than zero.</li>
</ul>
<p><strong>No custom events are needed – state flows naturally!</strong></p>
<module-demo>
	<div class="preview">
  	<module-catalog>
  		<header>
  			<p>Shop</p>
  			<basic-button disabled>
  				<button type="button" disabled>
  					<span class="label">🛒 Shopping Cart</span>
  					<span class="badge"></span>
  				</button>
  			</basic-button>
  		</header>
  		<ul>
  			<li>
  				<p>Product 1</p>
  				<form-spinbutton
  					value="0"
  					zero-label="Add to Cart"
  					increment-label="Increment"
  				>
  					<button
  						type="button"
  						class="decrement"
  						aria-label="Decrement"
  						hidden
  					>
  						−
  					</button>
  					<p class="value" hidden>0</p>
  					<button type="button" class="increment">Add to Cart</button>
  				</form-spinbutton>
  			</li>
  			<li>
  				<p>Product 2</p>
  				<form-spinbutton
  					value="0"
  					zero-label="Add to Cart"
  					increment-label="Increment"
  				>
  					<button
  						type="button"
  						class="decrement"
  						aria-label="Decrement"
  						hidden
  					>
  						−
  					</button>
  					<p class="value" hidden>0</p>
  					<button type="button" class="increment">Add to Cart</button>
  				</form-spinbutton>
  			</li>
  			<li>
  				<p>Product 3</p>
  				<form-spinbutton
  					value="0"
  					zero-label="Add to Cart"
  					increment-label="Increment"
  				>
  					<button
  						type="button"
  						class="decrement"
  						aria-label="Decrement"
  						hidden
  					>
  						−
  					</button>
  					<p class="value" hidden>0</p>
  					<button type="button" class="increment">Add to Cart</button>
  				</form-spinbutton>
  			</li>
  		</ul>
	  </module-catalog>
	</div>
	<details>
		<summary>ModuleCatalog Source Code</summary>
		<module-lazy src="./examples/module-catalog.html">
			<card-callout>
				<p class="loading" role="status" aria-live="polite">Loading...</p>
				<p class="error" role="alert" aria-live="assertive" hidden></p>
			</card-callout>
		</module-lazy>
	</details>
	<details>
		<summary>BasicButton Source Code</summary>
		<module-lazy src="./examples/basic-button.html">
			<card-callout>
				<p class="loading" role="status" aria-live="polite">Loading...</p>
				<p class="error" role="alert" aria-live="assertive" hidden></p>
			</card-callout>
		</module-lazy>
	</details>
	<details>
		<summary>FormSpinbutton Source Code</summary>
		<module-lazy src="./examples/form-spinbutton.html">
			<card-callout>
				<p class="loading" role="status" aria-live="polite">Loading...</p>
				<p class="error" role="alert" aria-live="asserive" hidden></p>
			</card-callout>
		</module-lazy>
	</details>
</module-demo>

</section>

<section>

<h2 id="custom-events">
							<a name="custom-events" class="anchor" href="#custom-events">
								<span class="permalink">🔗</span>
								<span class="title">Custom Events</span>
							</a>
						</h2>
<p>Passing state down works well when a <strong>parent component can directly access child state</strong>, but sometimes a <strong>child needs to notify its parent</strong> about an action <strong>without managing shared state itself</strong>.</p>
<p>Custom events are perfect for this - they allow components to communicate upward through the DOM tree without tight coupling.</p>
<h3 id="typescript-support-for-components-and-events">
							<a name="typescript-support-for-components-and-events" class="anchor" href="#typescript-support-for-components-and-events">
								<span class="permalink">🔗</span>
								<span class="title">TypeScript Support for Components and Events</span>
							</a>
						</h3>
<p>To get full TypeScript support, declare your components and custom events globally:</p>
<p><strong>CODE_BLOCK_PLACEHOLDER_4</strong></p>
<p>This enables full type checking, autocompletion, and access to Le Truc component methods like <code>.getSignal()</code> and <code>.setSignal()</code>.</p>
<h3 id="example-shopping-cart-events">
							<a name="example-shopping-cart-events" class="anchor" href="#example-shopping-cart-events">
								<span class="permalink">🔗</span>
								<span class="title">Example: Shopping Cart Events</span>
							</a>
						</h3>
<p>Consider a <strong>product card</strong> that needs to notify its parent when an item is added:</p>
<p><strong>CODE_BLOCK_PLACEHOLDER_5</strong></p>
<p><strong>CODE_BLOCK_PLACEHOLDER_6</strong></p>
<h3 id="benefits-of-custom-events">
							<a name="benefits-of-custom-events" class="anchor" href="#benefits-of-custom-events">
								<span class="permalink">🔗</span>
								<span class="title">Benefits of Custom Events</span>
							</a>
						</h3>
<ul>
<li><strong>Decoupling</strong>: Child components don&#39;t need to know about parent implementation</li>
<li><strong>Reusability</strong>: Components can be used in different contexts</li>
<li><strong>Standard DOM</strong>: Uses native event system, works with any framework</li>
<li><strong>Bubbling</strong>: Events naturally flow up the DOM tree</li>
<li><strong>Cancellable</strong>: Parent can prevent default behavior if needed</li>
</ul>
<h3 id="when-to-use-custom-events">
							<a name="when-to-use-custom-events" class="anchor" href="#when-to-use-custom-events">
								<span class="permalink">🔗</span>
								<span class="title">When to Use Custom Events</span>
							</a>
						</h3>
<ul>
<li><strong>User Actions</strong>: Button clicks, form submissions, gestures</li>
<li><strong>State Changes</strong>: When a component&#39;s internal state affects others</li>
<li><strong>Lifecycle Events</strong>: Component initialization, destruction, errors</li>
<li><strong>Data Flow</strong>: When child needs to send data upward without direct coupling</li>
</ul>
<h3 id="component-type-safety-best-practices">
							<a name="component-type-safety-best-practices" class="anchor" href="#component-type-safety-best-practices">
								<span class="permalink">🔗</span>
								<span class="title">Component Type Safety Best Practices</span>
							</a>
						</h3>
<p>Each Le Truc component should declare its own <code>HTMLElementTagNameMap</code> extension:</p>
<p><strong>CODE_BLOCK_PLACEHOLDER_7</strong></p>
<p>This enables:</p>
<ul>
<li><strong>Full type safety</strong> when using signal producers like <code>fromDescendants(&#39;my-component&#39;, ...)</code></li>
<li><strong>Access to Le Truc methods</strong> like <code>.getSignal()</code> and <code>.setSignal()</code></li>
<li><strong>IntelliSense</strong> for component properties and methods</li>
<li><strong>Compile-time validation</strong> of component interactions</li>
</ul>
</section>

<section>

<h2 id="providing-context">
							<a name="providing-context" class="anchor" href="#providing-context">
								<span class="permalink">🔗</span>
								<span class="title">Providing Context</span>
							</a>
						</h2>
<p>Context allows <strong>parent components to share state</strong> with any descendant components in the DOM tree, <strong>without prop drilling</strong>. This is perfect for application-wide settings like user preferences, theme data, or authentication state.</p>
<h3 id="creating-context-keys">
							<a name="creating-context-keys" class="anchor" href="#creating-context-keys">
								<span class="permalink">🔗</span>
								<span class="title">Creating Context Keys</span>
							</a>
						</h3>
<p>First, define typed context keys for the values you want to share:</p>
<p><strong>CODE_BLOCK_PLACEHOLDER_8</strong></p>
<h3 id="provider-component">
							<a name="provider-component" class="anchor" href="#provider-component">
								<span class="permalink">🔗</span>
								<span class="title">Provider Component</span>
							</a>
						</h3>
<p>The <strong>provider component</strong> creates the shared state and makes it available to descendants:</p>
<p><strong>CODE_BLOCK_PLACEHOLDER_9</strong></p>
<h3 id="typescript-support">
							<a name="typescript-support" class="anchor" href="#typescript-support">
								<span class="permalink">🔗</span>
								<span class="title">TypeScript Support</span>
							</a>
						</h3>
<p>For full type safety and autocompletion, declare your contexts globally:</p>
<p><strong>CODE_BLOCK_PLACEHOLDER_10</strong></p>
<h3 id="usage-in-html">
							<a name="usage-in-html" class="anchor" href="#usage-in-html">
								<span class="permalink">🔗</span>
								<span class="title">Usage in HTML</span>
							</a>
						</h3>
<p>The provider component wraps your entire application or a section that needs shared state:</p>
<p><strong>CODE_BLOCK_PLACEHOLDER_11</strong></p>
<p><strong>Key Benefits:</strong></p>
<ul>
<li><strong>Centralized State</strong>: All user preferences managed in one place</li>
<li><strong>Automatic Persistence</strong>: Changes automatically saved to localStorage</li>
<li><strong>Type Safety</strong>: Full TypeScript support with autocomplete</li>
<li><strong>Reactive Updates</strong>: All consumers automatically update when context changes</li>
<li><strong>No Prop Drilling</strong>: Deep components access context directly</li>
</ul>
</section>

<section>

<h2 id="consuming-context">
							<a name="consuming-context" class="anchor" href="#consuming-context">
								<span class="permalink">🔗</span>
								<span class="title">Consuming Context</span>
							</a>
						</h2>
<p><strong>Consumer components</strong> use <code>fromContext()</code> to access shared state from ancestor providers. The context is automatically reactive - when the provider updates the context, all consumers update immediately.</p>
<h3 id="simple-context-consumer">
							<a name="simple-context-consumer" class="anchor" href="#simple-context-consumer">
								<span class="permalink">🔗</span>
								<span class="title">Simple Context Consumer</span>
							</a>
						</h3>
<p>Here&#39;s a theme toggle that consumes and updates the user theme context:</p>
<p><strong>CODE_BLOCK_PLACEHOLDER_12</strong></p>
<h3 id="complex-context-consumer">
							<a name="complex-context-consumer" class="anchor" href="#complex-context-consumer">
								<span class="permalink">🔗</span>
								<span class="title">Complex Context Consumer</span>
							</a>
						</h3>
<p>A settings panel that consumes and modifies user settings:</p>
<p><strong>CODE_BLOCK_PLACEHOLDER_13</strong></p>
<h3 id="context-with-computed-values">
							<a name="context-with-computed-values" class="anchor" href="#context-with-computed-values">
								<span class="permalink">🔗</span>
								<span class="title">Context with Computed Values</span>
							</a>
						</h3>
<p>You can also use context to provide computed values derived from multiple sources:</p>
<p><strong>CODE_BLOCK_PLACEHOLDER_14</strong></p>
<h3 id="context-with-fallback-functions">
							<a name="context-with-fallback-functions" class="anchor" href="#context-with-fallback-functions">
								<span class="permalink">🔗</span>
								<span class="title">Context with Fallback Functions</span>
							</a>
						</h3>
<p>For more complex fallback logic, use a function:</p>
<p><strong>CODE_BLOCK_PLACEHOLDER_15</strong></p>
<h3 id="benefits-of-context">
							<a name="benefits-of-context" class="anchor" href="#benefits-of-context">
								<span class="permalink">🔗</span>
								<span class="title">Benefits of Context</span>
							</a>
						</h3>
<ul>
<li><strong>Automatic Updates</strong>: All consumers react when context changes</li>
<li><strong>Type Safety</strong>: Full TypeScript support with proper typing</li>
<li><strong>Fallback Support</strong>: Graceful degradation when context is unavailable</li>
<li><strong>Performance</strong>: Only components that use changed context re-render</li>
<li><strong>Clean Architecture</strong>: Eliminates prop drilling and tight coupling</li>
</ul>
<p><strong>When to Use Context:</strong></p>
<ul>
<li><strong>Application State</strong>: User preferences, authentication, theme</li>
<li><strong>Configuration</strong>: API endpoints, feature flags, environment settings</li>
<li><strong>Shared Resources</strong>: Database connections, cache instances</li>
<li><strong>Cross-cutting Concerns</strong>: Logging, analytics, error handling</li>
</ul>
</section>

<section>

<h2 id="next-steps">
							<a name="next-steps" class="anchor" href="#next-steps">
								<span class="permalink">🔗</span>
								<span class="title">Next Steps</span>
							</a>
						</h2>
</section>
</main>
			<footer class="content-grid">
				<div class="content">
					<h2 class="visually-hidden">Footer</h2>
					<p>© 2024 – 2025 Zeix AG</p>
				</div>
			</footer>
		</context-router>
	</body>
</html>
