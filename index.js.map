{
  "version": 3,
  "sources": ["node_modules/@zeix/cause-effect/src/util.ts", "node_modules/@zeix/cause-effect/src/scheduler.ts", "node_modules/@zeix/cause-effect/src/state.ts", "node_modules/@zeix/cause-effect/src/computed.ts", "node_modules/@zeix/cause-effect/src/signal.ts", "node_modules/@zeix/cause-effect/src/effect.ts", "src/core/util.ts", "src/core/dom.ts", "src/component.ts", "src/core/context.ts", "src/lib/parsers.ts", "src/lib/effects.ts"],
  "sourcesContent": [
    "/* === Utility Functions === */\n\nconst isFunction = /*#__PURE__*/ <T>(\n\tvalue: unknown,\n): value is (...args: unknown[]) => T => typeof value === 'function'\n\nconst isObjectOfType = /*#__PURE__*/ <T>(\n\tvalue: unknown,\n\ttype: string,\n): value is T => Object.prototype.toString.call(value) === `[object ${type}]`\n\nconst toError = (reason: unknown): Error =>\n\treason instanceof Error ? reason : Error(String(reason))\n\nclass CircularDependencyError extends Error {\n\tconstructor(where: string) {\n\t\tsuper(`Circular dependency in ${where} detected`)\n\t\treturn this\n\t}\n}\n\n/* === Exports === */\n\nexport { isFunction, isObjectOfType, toError, CircularDependencyError }\n",
    "/* === Types === */\n\ntype Cleanup = () => void\n\ntype Watcher = {\n\t(): void\n\toff(cleanup: Cleanup): void\n\tcleanup(): void\n}\n\ntype Updater = <T>() => T | boolean | void\n\n/* === Internal === */\n\n// Currently active watcher\nlet active: Watcher | undefined\n\n// Pending queue for batched change notifications\nconst pending = new Set<Watcher>()\nlet batchDepth = 0\n\n// Map of deduplication symbols to update functions (using Symbol keys prevents unintended overwrites)\nconst updateMap = new Map<symbol, Updater>()\nlet requestId: number | undefined\n\nconst updateDOM = () => {\n\trequestId = undefined\n\tconst updates = Array.from(updateMap.values())\n\tupdateMap.clear()\n\tfor (const update of updates) {\n\t\tupdate()\n\t}\n}\n\nconst requestTick = () => {\n\tif (requestId) cancelAnimationFrame(requestId)\n\trequestId = requestAnimationFrame(updateDOM)\n}\n\n// Initial render when the call stack is empty\nqueueMicrotask(updateDOM)\n\n/* === Functions === */\n\n/**\n * Create a watcher that can be used to observe changes to a signal\n *\n * @since 0.14.1\n * @param {() => void} notice - function to be called when the state changes\n * @returns {Watcher} - watcher object with off and cleanup methods\n */\nconst watch = (notice: () => void): Watcher => {\n\tconst cleanups = new Set<Cleanup>()\n\tconst w = notice as Partial<Watcher>\n\tw.off = (on: Cleanup) => {\n\t\tcleanups.add(on)\n\t}\n\tw.cleanup = () => {\n\t\tfor (const cleanup of cleanups) {\n\t\t\tcleanup()\n\t\t}\n\t\tcleanups.clear()\n\t}\n\treturn w as Watcher\n}\n\n/**\n * Add active watcher to the Set of watchers\n *\n * @param {Set<Watcher>} watchers - watchers of the signal\n */\nconst subscribe = (watchers: Set<Watcher>) => {\n\tif (active && !watchers.has(active)) {\n\t\tconst watcher = active\n\t\twatchers.add(watcher)\n\t\tactive.off(() => {\n\t\t\twatchers.delete(watcher)\n\t\t})\n\t}\n}\n\n/**\n * Add watchers to the pending set of change notifications\n *\n * @param {Set<Watcher>} watchers - watchers of the signal\n */\nconst notify = (watchers: Set<Watcher>) => {\n\tfor (const watcher of watchers) {\n\t\tif (batchDepth) pending.add(watcher)\n\t\telse watcher()\n\t}\n}\n\n/**\n * Flush all pending changes to notify watchers\n */\nconst flush = () => {\n\twhile (pending.size) {\n\t\tconst watchers = Array.from(pending)\n\t\tpending.clear()\n\t\tfor (const watcher of watchers) {\n\t\t\twatcher()\n\t\t}\n\t}\n}\n\n/**\n * Batch multiple changes in a single signal graph and DOM update cycle\n *\n * @param {() => void} fn - function with multiple signal writes to be batched\n */\nconst batch = (fn: () => void) => {\n\tbatchDepth++\n\ttry {\n\t\tfn()\n\t} finally {\n\t\tflush()\n\t\tbatchDepth--\n\t}\n}\n\n/**\n * Run a function in a reactive context\n *\n * @param {() => void} run - function to run the computation or effect\n * @param {Watcher} watcher - function to be called when the state changes or undefined for temporary unwatching while inserting auto-hydrating DOM nodes that might read signals (e.g., web components)\n */\nconst observe = (run: () => void, watcher?: Watcher): void => {\n\tconst prev = active\n\tactive = watcher\n\ttry {\n\t\trun()\n\t} finally {\n\t\tactive = prev\n\t}\n}\n\n/**\n * Enqueue a function to be executed on the next animation frame\n *\n * If the same Symbol is provided for multiple calls before the next animation frame,\n * only the latest call will be executed (deduplication).\n *\n * @param {Updater} fn - function to be executed on the next animation frame; can return updated value <T>, success <boolean> or void\n * @param {symbol} dedupe - Symbol for deduplication; if not provided, a unique Symbol is created ensuring the update is always executed\n */\nconst enqueue = <T>(fn: Updater, dedupe?: symbol) =>\n\tnew Promise<T | boolean | void>((resolve, reject) => {\n\t\tupdateMap.set(dedupe || Symbol(), () => {\n\t\t\ttry {\n\t\t\t\tresolve(fn())\n\t\t\t} catch (error) {\n\t\t\t\treject(error)\n\t\t\t}\n\t\t})\n\t\trequestTick()\n\t})\n\n/* === Exports === */\n\nexport {\n\ttype Cleanup,\n\ttype Watcher,\n\ttype Updater,\n\tsubscribe,\n\tnotify,\n\tflush,\n\tbatch,\n\twatch,\n\tobserve,\n\tenqueue,\n}\n",
    "import { UNSET } from './signal'\nimport { isObjectOfType } from './util'\nimport { type Watcher, notify, subscribe } from './scheduler'\n\n/* === Types === */\n\ntype State<T extends {}> = {\n\t[Symbol.toStringTag]: 'State'\n\tget(): T\n\tset(v: T): void\n\tupdate(fn: (v: T) => T): void\n}\n\n/* === Constants === */\n\nconst TYPE_STATE = 'State'\n\n/* === Functions === */\n\n/**\n * Create a new state signal\n *\n * @since 0.9.0\n * @param {T} initialValue - initial value of the state\n * @returns {State<T>} - new state signal\n */\nconst state = /*#__PURE__*/ <T extends {}>(initialValue: T): State<T> => {\n\tconst watchers: Set<Watcher> = new Set()\n\tlet value: T = initialValue\n\n\tconst s: State<T> = {\n\t\t[Symbol.toStringTag]: TYPE_STATE,\n\n\t\t/**\n\t\t * Get the current value of the state\n\t\t *\n\t\t * @since 0.9.0\n\t\t * @returns {T} - current value of the state\n\t\t */\n\t\tget: (): T => {\n\t\t\tsubscribe(watchers)\n\t\t\treturn value\n\t\t},\n\n\t\t/**\n\t\t * Set a new value of the state\n\t\t *\n\t\t * @since 0.9.0\n\t\t * @param {T} v\n\t\t * @returns {void}\n\t\t */\n\t\tset: (v: T): void => {\n\t\t\tif (Object.is(value, v)) return\n\t\t\tvalue = v\n\t\t\tnotify(watchers)\n\n\t\t\t// Setting to UNSET clears the watchers so the signal can be garbage collected\n\t\t\tif (UNSET === value) watchers.clear()\n\t\t},\n\n\t\t/**\n\t\t * Update the state with a new value using a function\n\t\t *\n\t\t * @since 0.10.0\n\t\t * @param {(v: T) => T} fn - function to update the state\n\t\t * @returns {void} - updates the state with the result of the function\n\t\t */\n\t\tupdate: (fn: (v: T) => T): void => {\n\t\t\ts.set(fn(value))\n\t\t},\n\t}\n\n\treturn s\n}\n\n/**\n * Check if the provided value is a State instance\n *\n * @since 0.9.0\n * @param {unknown} value - value to check\n * @returns {boolean} - true if the value is a State instance, false otherwise\n */\nconst isState = /*#__PURE__*/ <T extends {}>(\n\tvalue: unknown,\n): value is State<T> => isObjectOfType(value, TYPE_STATE)\n\n/* === Exports === */\n\nexport { type State, TYPE_STATE, state, isState }\n",
    "import {\n\tCircularDependencyError,\n\tisFunction,\n\tisObjectOfType,\n\ttoError,\n} from './util'\nimport {\n\ttype Watcher,\n\twatch,\n\tsubscribe,\n\tnotify,\n\tflush,\n\tobserve,\n} from './scheduler'\nimport { UNSET } from './signal'\n\n/* === Types === */\n\ntype Computed<T extends {}> = {\n\t[Symbol.toStringTag]: 'Computed'\n\tget(): T\n}\ntype ComputedCallback<T extends {} & { then?: void }> =\n\t| ((abort: AbortSignal) => Promise<T>)\n\t| (() => T)\n\n/* === Constants === */\n\nconst TYPE_COMPUTED = 'Computed'\n\n/* === Functions === */\n\n/**\n * Create a derived signal from existing signals\n *\n * @since 0.9.0\n * @param {ComputedCallback<T>} fn - computation callback function\n * @returns {Computed<T>} - Computed signal\n */\nconst computed = <T extends {}>(fn: ComputedCallback<T>): Computed<T> => {\n\tconst watchers: Set<Watcher> = new Set()\n\n\t// Internal state\n\tlet value: T = UNSET\n\tlet error: Error | undefined\n\tlet controller: AbortController | undefined\n\tlet dirty = true\n\tlet changed = false\n\tlet computing = false\n\n\t// Functions to update internal state\n\tconst ok = (v: T) => {\n\t\tif (!Object.is(v, value)) {\n\t\t\tvalue = v\n\t\t\tchanged = true\n\t\t}\n\t\terror = undefined\n\t\tdirty = false\n\t}\n\tconst nil = () => {\n\t\tchanged = UNSET !== value\n\t\tvalue = UNSET\n\t\terror = undefined\n\t}\n\tconst err = (e: unknown) => {\n\t\tconst newError = toError(e)\n\t\tchanged =\n\t\t\t!error ||\n\t\t\tnewError.name !== error.name ||\n\t\t\tnewError.message !== error.message\n\t\tvalue = UNSET\n\t\terror = newError\n\t}\n\tconst settle =\n\t\t<T>(settleFn: (arg: T) => void) =>\n\t\t(arg: T) => {\n\t\t\tcomputing = false\n\t\t\tcontroller = undefined\n\t\t\tsettleFn(arg)\n\t\t\tif (changed) notify(watchers)\n\t\t}\n\n\t// Own watcher: called when notified from sources (push)\n\tconst mark = watch(() => {\n\t\tdirty = true\n\t\tcontroller?.abort('Aborted because source signal changed')\n\t\tif (watchers.size) notify(watchers)\n\t\telse mark.cleanup()\n\t})\n\n\t// Called when requested by dependencies (pull)\n\tconst compute = () =>\n\t\tobserve(() => {\n\t\t\tif (computing) throw new CircularDependencyError('computed')\n\t\t\tchanged = false\n\t\t\tif (isFunction(fn) && fn.constructor.name === 'AsyncFunction') {\n\t\t\t\tif (controller) return value // return current value until promise resolves\n\t\t\t\tcontroller = new AbortController()\n\t\t\t\tcontroller.signal.addEventListener(\n\t\t\t\t\t'abort',\n\t\t\t\t\t() => {\n\t\t\t\t\t\tcomputing = false\n\t\t\t\t\t\tcontroller = undefined\n\t\t\t\t\t\tcompute() // retry\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tonce: true,\n\t\t\t\t\t},\n\t\t\t\t)\n\t\t\t}\n\t\t\tlet result: T | Promise<T>\n\t\t\tcomputing = true\n\t\t\ttry {\n\t\t\t\tresult = controller ? fn(controller.signal) : (fn as () => T)()\n\t\t\t} catch (e) {\n\t\t\t\tif (e instanceof DOMException && e.name === 'AbortError') nil()\n\t\t\t\telse err(e)\n\t\t\t\tcomputing = false\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (result instanceof Promise) result.then(settle(ok), settle(err))\n\t\t\telse if (null == result || UNSET === result) nil()\n\t\t\telse ok(result)\n\t\t\tcomputing = false\n\t\t}, mark)\n\n\tconst c: Computed<T> = {\n\t\t[Symbol.toStringTag]: TYPE_COMPUTED,\n\n\t\t/**\n\t\t * Get the current value of the computed\n\t\t *\n\t\t * @since 0.9.0\n\t\t * @returns {T} - current value of the computed\n\t\t */\n\t\tget: (): T => {\n\t\t\tsubscribe(watchers)\n\t\t\tflush()\n\t\t\tif (dirty) compute()\n\t\t\tif (error) throw error\n\t\t\treturn value\n\t\t},\n\t}\n\treturn c\n}\n\n/**\n * Check if a value is a computed state\n *\n * @since 0.9.0\n * @param {unknown} value - value to check\n * @returns {boolean} - true if value is a computed state, false otherwise\n */\nconst isComputed = /*#__PURE__*/ <T extends {}>(\n\tvalue: unknown,\n): value is Computed<T> => isObjectOfType(value, TYPE_COMPUTED)\n\n/**\n * Check if the provided value is a callback that may be used as input for toSignal() to derive a computed state\n *\n * @since 0.12.0\n * @param {unknown} value - value to check\n * @returns {boolean} - true if value is a callback or callbacks object, false otherwise\n */\nconst isComputedCallback = /*#__PURE__*/ <T extends {}>(\n\tvalue: unknown,\n): value is ComputedCallback<T> => isFunction(value) && value.length < 2\n\n/* === Exports === */\n\nexport {\n\ttype Computed,\n\ttype ComputedCallback,\n\tTYPE_COMPUTED,\n\tcomputed,\n\tisComputed,\n\tisComputedCallback,\n}\n",
    "import { isState, state } from './state'\nimport {\n\ttype ComputedCallback,\n\tisComputed,\n\tisComputedCallback,\n\tcomputed,\n} from './computed'\n\n/* === Types === */\n\ntype Signal<T extends {}> = {\n\tget(): T\n}\ntype MaybeSignal<T extends {}> = T | Signal<T> | ComputedCallback<T>\n\ntype SignalValues<S extends Signal<{}>[]> = {\n\t[K in keyof S]: S[K] extends Signal<infer T> ? T : never\n}\n\n/* === Constants === */\n\nconst UNSET: any = Symbol()\n\n/* === Functions === */\n\n/**\n * Check whether a value is a Signal or not\n *\n * @since 0.9.0\n * @param {unknown} value - value to check\n * @returns {boolean} - true if value is a Signal, false otherwise\n */\nconst isSignal = /*#__PURE__*/ <T extends {}>(\n\tvalue: unknown,\n): value is Signal<T> => isState(value) || isComputed(value)\n\n/**\n * Convert a value to a Signal if it's not already a Signal\n *\n * @since 0.9.6\n * @param {MaybeSignal<T>} value - value to convert to a Signal\n * @returns {Signal<T>} - converted Signal\n */\nconst toSignal = /*#__PURE__*/ <T extends {}>(\n\tvalue: MaybeSignal<T>,\n): Signal<T> =>\n\tisSignal<T>(value)\n\t\t? value\n\t\t: isComputedCallback<T>(value)\n\t\t\t? computed(value)\n\t\t\t: state(value as T)\n\n/* === Exports === */\n\nexport {\n\ttype Signal,\n\ttype MaybeSignal,\n\ttype SignalValues,\n\tUNSET,\n\tisSignal,\n\tisComputedCallback,\n\ttoSignal,\n}\n",
    "import { type Signal, type SignalValues, UNSET } from './signal'\nimport { CircularDependencyError, isFunction, toError } from './util'\nimport { type Cleanup, watch, observe } from './scheduler'\n\n/* === Types === */\n\ntype EffectMatcher<S extends Signal<{}>[]> = {\n\tsignals: S\n\tok: (...values: SignalValues<S>) => void | Cleanup\n\terr?: (...errors: Error[]) => void | Cleanup\n\tnil?: () => void | Cleanup\n}\n\n/* === Functions === */\n\n/**\n * Define what happens when a reactive state changes\n *\n * @since 0.1.0\n * @param {EffectMatcher<S> | (() => void | Cleanup)} matcher - effect matcher or callback\n * @returns {Cleanup} - cleanup function for the effect\n */\nfunction effect<S extends Signal<{}>[]>(\n\tmatcher: EffectMatcher<S> | (() => void | Cleanup),\n): Cleanup {\n\tconst {\n\t\tsignals,\n\t\tok,\n\t\terr = console.error,\n\t\tnil = () => {},\n\t} = isFunction(matcher)\n\t\t? { signals: [] as unknown as S, ok: matcher }\n\t\t: matcher\n\n\tlet running = false\n\tconst run = watch(() =>\n\t\tobserve(() => {\n\t\t\tif (running) throw new CircularDependencyError('effect')\n\t\t\trunning = true\n\n\t\t\t// Pure part\n\t\t\tconst errors: Error[] = []\n\t\t\tlet pending = false\n\t\t\tconst values = signals.map(signal => {\n\t\t\t\ttry {\n\t\t\t\t\tconst value = signal.get()\n\t\t\t\t\tif (value === UNSET) pending = true\n\t\t\t\t\treturn value\n\t\t\t\t} catch (e) {\n\t\t\t\t\terrors.push(toError(e))\n\t\t\t\t\treturn UNSET\n\t\t\t\t}\n\t\t\t}) as SignalValues<S>\n\n\t\t\t// Effectful part\n\t\t\tlet cleanup: void | Cleanup = undefined\n\t\t\ttry {\n\t\t\t\tcleanup = pending\n\t\t\t\t\t? nil()\n\t\t\t\t\t: errors.length\n\t\t\t\t\t\t? err(...errors)\n\t\t\t\t\t\t: ok(...values)\n\t\t\t} catch (e) {\n\t\t\t\tcleanup = err(toError(e))\n\t\t\t} finally {\n\t\t\t\tif (isFunction(cleanup)) run.off(cleanup)\n\t\t\t}\n\n\t\t\trunning = false\n\t\t}, run),\n\t)\n\trun()\n\treturn () => run.cleanup()\n}\n\n/* === Exports === */\n\nexport { type EffectMatcher, effect }\n",
    "/* === Types === */\n\ntype LogLevel = 'debug' | 'info' | 'warn' | 'error'\n\n/* === Constants === */\n\nconst DEV_MODE = process.env.DEV_MODE\n\nconst LOG_DEBUG: LogLevel = 'debug'\nconst LOG_INFO: LogLevel = 'info'\nconst LOG_WARN: LogLevel = 'warn'\nconst LOG_ERROR: LogLevel = 'error'\n\n/* === Internal Functions === */\n\n/**\n * Return selector string for the id of the element\n *\n * @since 0.7.0\n * @param {string} id\n * @returns {string} - id string for the element with '#' prefix\n */\nconst idString = (id: string): string => (id ? `#${id}` : '')\n\n/**\n * Return a selector string for classes of the element\n *\n * @since 0.7.0\n * @param {DOMTokenList} classList - DOMTokenList to convert to a string\n * @returns {string} - class string for the DOMTokenList with '.' prefix if any\n */\nconst classString = (classList: DOMTokenList): string =>\n\tclassList.length ? `.${Array.from(classList).join('.')}` : ''\n\n/* === Exported Functions === */\n\nconst isDefinedObject = /*#__PURE__*/ (\n\tvalue: unknown,\n): value is Record<string, unknown> => !!value && typeof value === 'object'\n\nconst isString = /*#__PURE__*/ (value: unknown): value is string =>\n\ttypeof value === 'string'\n\n/**\n * Check if a node is an Element\n *\n * @param {Node} node - node to check\n * @returns {boolean} - `true` if node is an element node, otherwise `false`\n */\nconst isElement = (node: Node): node is Element =>\n\tnode.nodeType === Node.ELEMENT_NODE\n\n/**\n * Return a HyperScript string representation of the Element instance\n *\n * @since 0.7.0\n * @param {Element} el\n * @returns {string}\n */\nconst elementName = (el: Element): string =>\n\t`<${el.localName}${idString(el.id)}${classString(el.classList)}>`\n\n/**\n * Return a string representation of a JavaScript variable\n *\n * @since 0.7.0\n * @param {unknown} value\n * @returns {string}\n */\nconst valueString = (value: unknown): string =>\n\tisString(value)\n\t\t? `\"${value}\"`\n\t\t: isDefinedObject(value)\n\t\t\t? JSON.stringify(value)\n\t\t\t: String(value)\n\n/**\n * Return a detailed type of a JavaScript variable\n *\n * @since 0.11.0\n * @param {unknown} value\n * @returns {string}\n */\nconst typeString = (value: unknown): string => {\n\tif (value === null) return 'null'\n\tif (typeof value !== 'object') return typeof value\n\tif (Array.isArray(value)) return 'Array'\n\n\t// Check for Symbol.toStringTag\n\tif (Symbol.toStringTag in Object(value)) {\n\t\treturn (value as any)[Symbol.toStringTag]\n\t}\n\n\t// For other objects, return the constructor name if available\n\treturn value.constructor?.name || 'Object'\n}\n\n/**\n * Log a message to the console with the specified level\n *\n * @since 0.7.0\n * @param {T} value - value to inspect\n * @param {string} msg - message to log\n * @param {LogLevel} level - log level\n * @returns {T} - value passed through\n */\nconst log = <T>(value: T, msg: string, level: LogLevel = LOG_DEBUG): T => {\n\tif (DEV_MODE || ([LOG_ERROR, LOG_WARN] as LogLevel[]).includes(level))\n\t\tconsole[level](msg, value)\n\treturn value\n}\n\nexport {\n\ttype LogLevel,\n\tisString,\n\tisDefinedObject,\n\tisElement,\n\tlog,\n\telementName,\n\tvalueString,\n\ttypeString,\n\tDEV_MODE,\n\tLOG_DEBUG,\n\tLOG_INFO,\n\tLOG_WARN,\n\tLOG_ERROR,\n}\n",
    "import {\n\ttype Cleanup,\n\ttype Computed,\n\ttype MaybeSignal,\n\ttype Signal,\n\tTYPE_COMPUTED,\n\tUNSET,\n\ttype Watcher,\n\tcomputed,\n\tisFunction,\n\tnotify,\n\tsubscribe,\n\ttoSignal,\n} from '@zeix/cause-effect'\n\nimport type { Component, ComponentProps, SignalProducer } from '../component'\nimport { elementName, isDefinedObject, isString } from './util'\n\n/* === Types === */\n\n// Map common element types to their typical events\ntype ElementEventMap<E extends Element> = E extends\n\t| HTMLInputElement\n\t| HTMLTextAreaElement\n\t| HTMLSelectElement\n\t? Pick<\n\t\t\tHTMLElementEventMap,\n\t\t\t| 'input'\n\t\t\t| 'change'\n\t\t\t| 'focus'\n\t\t\t| 'blur'\n\t\t\t| 'invalid'\n\t\t\t| 'keydown'\n\t\t\t| 'keyup'\n\t\t\t| 'keypress'\n\t\t\t| 'click'\n\t\t\t| 'mousedown'\n\t\t\t| 'mouseup'\n\t\t\t| 'paste'\n\t\t\t| 'cut'\n\t\t\t| 'copy'\n\t\t>\n\t: E extends HTMLFormElement\n\t\t? Pick<HTMLElementEventMap, 'submit' | 'reset' | 'formdata'>\n\t\t: E extends HTMLButtonElement\n\t\t\t? Pick<\n\t\t\t\t\tHTMLElementEventMap,\n\t\t\t\t\t| 'click'\n\t\t\t\t\t| 'focus'\n\t\t\t\t\t| 'blur'\n\t\t\t\t\t| 'keydown'\n\t\t\t\t\t| 'keyup'\n\t\t\t\t\t| 'keypress'\n\t\t\t\t>\n\t\t\t: E extends HTMLAnchorElement\n\t\t\t\t? Pick<HTMLElementEventMap, 'click' | 'focus' | 'blur'>\n\t\t\t\t: E extends HTMLDetailsElement\n\t\t\t\t\t? Pick<HTMLElementEventMap, 'toggle'>\n\t\t\t\t\t: E extends HTMLDialogElement\n\t\t\t\t\t\t? Pick<HTMLElementEventMap, 'close' | 'cancel'>\n\t\t\t\t\t\t: E extends HTMLMediaElement\n\t\t\t\t\t\t\t? Pick<\n\t\t\t\t\t\t\t\t\tHTMLElementEventMap,\n\t\t\t\t\t\t\t\t\t| 'loadstart'\n\t\t\t\t\t\t\t\t\t| 'loadeddata'\n\t\t\t\t\t\t\t\t\t| 'canplay'\n\t\t\t\t\t\t\t\t\t| 'play'\n\t\t\t\t\t\t\t\t\t| 'pause'\n\t\t\t\t\t\t\t\t\t| 'ended'\n\t\t\t\t\t\t\t\t\t| 'volumechange'\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t: E extends HTMLImageElement\n\t\t\t\t\t\t\t\t? Pick<HTMLElementEventMap, 'load' | 'error'>\n\t\t\t\t\t\t\t\t: HTMLElementEventMap // fallback to all events\n\n// Helper type to get event type from element and event name\ntype ElementEventType<\n\tE extends Element,\n\tK extends string,\n> = K extends keyof ElementEventMap<E> ? ElementEventMap<E>[K] : Event\n\n// Helper type to constrain event names to element-appropriate ones\ntype ValidEventName<E extends Element> = keyof ElementEventMap<E> & string\n\ntype PassedSignals<P extends ComponentProps, Q extends ComponentProps> = {\n\t[K in keyof Q]?: Signal<Q[K]> | ((element: Component<Q>) => Q[K]) | keyof P\n}\n\n/* === Error Class === */\n\n/**\n * Error thrown when a circular dependency is detected in a selection signal\n */\nclass CircularMutationError extends Error {\n\tconstructor(message: string) {\n\t\tsuper(message)\n\t\tthis.name = 'CircularMutationError'\n\t}\n}\n\n/* === Internal Function === */\n\n/**\n * Check if a value is a Component\n *\n * @param {unknown} value - value to check\n * @returns {boolean} - `true` if value is a valid custom element, otherwise `false`\n */\nconst isComponent = (value: unknown): value is Component<ComponentProps> =>\n\tvalue instanceof HTMLElement && value.localName.includes('-')\n\n/**\n * Extract attribute names from a CSS selector\n * Handles various attribute selector formats: .class, #id, [attr], [attr=value], [attr^=value], etc.\n *\n * @param {string} selector - CSS selector to parse\n * @returns {string[]} - Array of attribute names found in the selector\n */\nconst extractAttributes = (selector: string): string[] => {\n\tconst attributes = new Set<string>()\n\tif (selector.includes('.')) attributes.add('class')\n\tif (selector.includes('#')) attributes.add('id')\n\tif (selector.includes('[')) {\n\t\tconst parts = selector.split('[')\n\t\tfor (let i = 1; i < parts.length; i++) {\n\t\t\tconst part = parts[i]\n\t\t\tif (!part.includes(']')) continue\n\t\t\tconst attrName = part\n\t\t\t\t.split('=')[0]\n\t\t\t\t.trim()\n\t\t\t\t.replace(/[^a-zA-Z0-9_-]/g, '')\n\t\t\tif (attrName) attributes.add(attrName)\n\t\t}\n\t}\n\treturn [...attributes]\n}\n\n/**\n * Compare two arrays of elements to determine if they contain the same elements\n *\n * @param {E[]} arr1 - First array of elements to compare\n * @param {E[]} arr2 - Second array of elements to compare\n * @returns {boolean} - True if arrays contain the same elements, false otherwise\n */\nconst areElementArraysEqual = <E extends Element>(\n\tarr1: E[],\n\tarr2: E[],\n): boolean => {\n\tif (arr1.length !== arr2.length) return false\n\tconst set1 = new Set(arr1)\n\tfor (const el of arr2) {\n\t\tif (!set1.has(el)) return false\n\t}\n\treturn true\n}\n\n/* === Exported Functions === */\n\n/**\n * Observe a DOM subtree with a mutation observer\n *\n * @since 0.12.2\n * @param {ParentNode} parent - parent node\n * @param {string} selectors - selector for matching elements to observe\n * @param {MutationCallback} callback - mutation callback\n * @returns {MutationObserver} - the created mutation observer\n */\nconst observeSubtree = (\n\tparent: ParentNode,\n\tselectors: string,\n\tcallback: MutationCallback,\n): MutationObserver => {\n\tconst observer = new MutationObserver(callback)\n\tconst observedAttributes = extractAttributes(selectors)\n\tconst observerConfig: MutationObserverInit = {\n\t\tchildList: true,\n\t\tsubtree: true,\n\t}\n\tif (observedAttributes.length) {\n\t\tobserverConfig.attributes = true\n\t\tobserverConfig.attributeFilter = observedAttributes\n\t}\n\tobserver.observe(parent, observerConfig)\n\treturn observer\n}\n\n/**\n * Create a element selection signal from a query selector\n *\n * @since 0.12.2\n * @param {ParentNode} parent - parent node to query\n * @param {string} selectors - query selector\n * @returns {Computed<E[]>} Element selection signal\n */\nconst selection = <E extends Element>(\n\tparent: ParentNode,\n\tselectors: string,\n): Computed<E[]> => {\n\tconst watchers: Set<Watcher> = new Set()\n\tconst select = () => Array.from(parent.querySelectorAll<E>(selectors))\n\tlet value: E[] = UNSET\n\tlet observer: MutationObserver | undefined\n\tlet mutationDepth = 0\n\tconst MAX_MUTATION_DEPTH = 2 // Consider a depth > 1 as circular\n\n\tconst observe = () => {\n\t\tvalue = select()\n\t\tobserver = observeSubtree(parent, selectors, () => {\n\t\t\t// If we have no watchers, just disconnect\n\t\t\tif (!watchers.size) {\n\t\t\t\tobserver?.disconnect()\n\t\t\t\tobserver = undefined\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tmutationDepth++\n\t\t\tif (mutationDepth > MAX_MUTATION_DEPTH) {\n\t\t\t\tobserver?.disconnect()\n\t\t\t\tobserver = undefined\n\t\t\t\tmutationDepth = 0\n\t\t\t\tthrow new CircularMutationError(\n\t\t\t\t\t'Circular mutation in element selection detected',\n\t\t\t\t)\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tconst newElements = select()\n\t\t\t\tif (!areElementArraysEqual(value, newElements)) {\n\t\t\t\t\tvalue = newElements\n\t\t\t\t\tnotify(watchers)\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tmutationDepth--\n\t\t\t}\n\t\t})\n\t}\n\n\tconst s: Computed<E[]> = {\n\t\t[Symbol.toStringTag]: TYPE_COMPUTED,\n\n\t\tget: (): E[] => {\n\t\t\tsubscribe(watchers)\n\t\t\tif (!watchers.size) value = select()\n\t\t\telse if (!observer) observe()\n\t\t\treturn value\n\t\t},\n\t}\n\treturn s\n}\n\n/**\n * Produce a selection signal from a selector\n *\n * @since 0.13.1\n * @param {string} selectors - CSS selector for descendant elements\n * @returns {SignalProducer<HTMLElement, E[]>} signal producer for descendant element collection from a selector\n */\nconst fromSelector =\n\t<E extends Element>(selectors: string): SignalProducer<E[]> =>\n\t(host: HTMLElement) =>\n\t\tselection<E>(host, selectors)\n\n/**\n * Produce a computed signal from reduced properties of descendant elements\n *\n * @since 0.13.1\n * @param {string} selectors - CSS selector for descendant elements\n * @param {(accumulator: T, currentElement: E, currentIndex: number, array: E[]) => T} reducer - function to reduce values\n * @param {T} initialValue - initial value for reduction\n * @returns {SignalProducer<T>} signal producer that emits reduced value\n */\nconst fromDescendants =\n\t<T extends {}, E extends Element = HTMLElement>(\n\t\tselectors: string,\n\t\treducer: (\n\t\t\taccumulator: T,\n\t\t\tcurrentElement: E,\n\t\t\tcurrentIndex: number,\n\t\t\tarray: E[],\n\t\t) => T,\n\t\tinitialValue: T,\n\t): SignalProducer<T> =>\n\t(host: HTMLElement) =>\n\t\tcomputed(() =>\n\t\t\tselection<E>(host, selectors).get().reduce(reducer, initialValue),\n\t\t)\n\n/**\n * Attach an event listener to an element\n *\n * @since 0.12.0\n * @param {K} type - event type to listen for (type-safe based on element type)\n * @param {(event: ElementEventType<E, K>) => void} listener - event listener\n * @param {boolean | AddEventListenerOptions} options - event listener options\n * @throws {TypeError} - if the provided handler is not an event listener or a provider function\n */\nconst on =\n\t<E extends Element, K extends ValidEventName<E>>(\n\t\ttype: K,\n\t\tlistener: (event: ElementEventType<E, K>) => void,\n\t\toptions: boolean | AddEventListenerOptions = false,\n\t) =>\n\t<P extends ComponentProps>(\n\t\thost: Component<P>,\n\t\ttarget: E = host as unknown as E,\n\t): Cleanup => {\n\t\tif (!isFunction(listener))\n\t\t\tthrow new TypeError(\n\t\t\t\t`Invalid event listener provided for \"${type} event on element ${elementName(target)}`,\n\t\t\t)\n\t\ttarget.addEventListener(type, listener, options)\n\t\treturn () => target.removeEventListener(type, listener)\n\t}\n\n/**\n * Create a computed signal that listens to an event on an element\n *\n * This function creates a reactive signal that updates when the specified event fires.\n * Event listeners are automatically managed - they are added when the signal has watchers\n * and removed when no watchers remain to prevent memory leaks.\n *\n * @since 0.13.1\n * @param {C} host - host element (used as context in transform function)\n * @param {E} source - element to attach event listener to\n * @param {K} type - event type to listen for (type-safe based on element type)\n * @param {(host: C, source: E, event: ElementEventType<E, K>, oldValue: T) => T} transform - transformation function in event listener\n * @param {T} initialValue - initial value of the signal\n * @param {boolean | AddEventListenerOptions} options - event listener options\n * @returns {Computed<T>} computed signal that automatically manages event listener lifecycle\n */\nconst sensor = <\n\tT extends {},\n\tE extends Element,\n\tK extends ValidEventName<E>,\n\tC extends HTMLElement = HTMLElement,\n>(\n\thost: C,\n\tsource: E,\n\ttype: K,\n\ttransform: (\n\t\thost: C,\n\t\tsource: E,\n\t\tevent: ElementEventType<E, K>,\n\t\toldValue: T,\n\t) => T,\n\tinitialValue: T,\n\toptions: boolean | AddEventListenerOptions = false,\n): Computed<T> => {\n\tconst watchers: Set<Watcher> = new Set()\n\tlet value: T = initialValue\n\tlet listener: EventListener | undefined\n\tlet cleanup: Cleanup | undefined\n\n\tconst listen = () => {\n\t\tlistener = ((event: ElementEventType<E, K>) => {\n\t\t\tconst newValue = transform(\n\t\t\t\thost,\n\t\t\t\tsource,\n\t\t\t\tevent as ElementEventType<E, K>,\n\t\t\t\tvalue,\n\t\t\t)\n\t\t\tif (!Object.is(newValue, value)) {\n\t\t\t\tvalue = newValue\n\t\t\t\tif (watchers.size > 0) notify(watchers)\n\t\t\t\telse if (cleanup) cleanup()\n\t\t\t}\n\t\t}) as EventListener\n\n\t\tsource.addEventListener(type, listener, options)\n\t\tcleanup = () => {\n\t\t\tif (listener) {\n\t\t\t\tsource.removeEventListener(type, listener)\n\t\t\t\tlistener = undefined\n\t\t\t}\n\t\t\tcleanup = undefined\n\t\t}\n\t}\n\n\tconst s: Computed<T> = {\n\t\t[Symbol.toStringTag]: TYPE_COMPUTED,\n\n\t\tget: (): T => {\n\t\t\tsubscribe(watchers)\n\t\t\tif (watchers.size && !listener) listen()\n\t\t\treturn value\n\t\t},\n\t}\n\treturn s\n}\n\n/**\n * Produce a computed signal from transformed event data\n *\n * @since 0.13.1\n * @param {string} selector - CSS selector for the source element\n * @param {K} type - event type to listen for\n * @param {(host: C, source: E, event: ElementEventType<E, K>, oldValue: T) => T} transform - transformation function for the event\n * @param {T | ((host: C, source: E) => T)} initializer - initial value or initializer function\n * @returns {SignalProducer<T, C>} signal producer for value from event\n */\nconst fromEvent =\n\t<\n\t\tT extends {},\n\t\tE extends HTMLElement,\n\t\tK extends ValidEventName<E>,\n\t\tC extends HTMLElement = HTMLElement,\n\t>(\n\t\tselector: string,\n\t\ttype: K,\n\t\ttransform: (\n\t\t\thost: C,\n\t\t\tsource: E,\n\t\t\tevent: ElementEventType<E, K>,\n\t\t\toldValue: T,\n\t\t) => T,\n\t\tinitializer: T | ((host: C, source: E) => T),\n\t): SignalProducer<T, C> =>\n\t(host: C) => {\n\t\tconst source = host.querySelector<E>(selector)\n\t\tif (!source) {\n\t\t\tthrow new Error(\n\t\t\t\t`Element not found for selector \"${selector}\" in ${host.localName || 'component'}`,\n\t\t\t)\n\t\t}\n\t\tconst initialValue = isFunction<T>(initializer)\n\t\t\t? initializer(host, source)\n\t\t\t: (initializer as T)\n\t\treturn sensor(host, source, type, transform, initialValue)\n\t}\n\n/**\n * Emit a custom event with the given detail\n *\n * @since 0.12.0\n * @param {string} type - event type to emit\n * @param {T | ((element: Element) => T)} detail - event detail or provider function\n */\nconst emit =\n\t<T>(type: string, detail: T | ((element: Element) => T)) =>\n\t<P extends ComponentProps>(\n\t\thost: Component<P>,\n\t\ttarget: Element = host,\n\t): void => {\n\t\ttarget.dispatchEvent(\n\t\t\tnew CustomEvent(type, {\n\t\t\t\tdetail: isFunction(detail) ? detail(target) : detail,\n\t\t\t\tbubbles: true,\n\t\t\t}),\n\t\t)\n\t}\n\n/**\n * Pass signals to a custom element\n *\n * @since 0.12.0\n * @param {PassedSignals<P, Q> | ((target: Component<Q>) => PassedSignals<P, Q>)} signals - signals to be passed to the custom element\n * @throws {TypeError} - if the target element is not a custom element\n * @throws {TypeError} - if the provided signals are not an object or a provider function\n * @throws {Error} - if it fails to pass signals to the target element\n */\nconst pass =\n\t<P extends ComponentProps, Q extends ComponentProps>(\n\t\tsignals:\n\t\t\t| PassedSignals<P, Q>\n\t\t\t| ((target: Component<Q>) => PassedSignals<P, Q>),\n\t) =>\n\t<E extends Element>(host: Component<P>, target: E): void => {\n\t\tif (!isComponent(target))\n\t\t\tthrow new TypeError(`Target element must be a custom element`)\n\t\tconst sources = isFunction(signals) ? signals(target) : signals\n\t\tif (!isDefinedObject(sources))\n\t\t\tthrow new TypeError(\n\t\t\t\t`Passed signals must be an object or a provider function`,\n\t\t\t)\n\t\tcustomElements\n\t\t\t.whenDefined(target.localName)\n\t\t\t.then(() => {\n\t\t\t\tfor (const [prop, source] of Object.entries(sources)) {\n\t\t\t\t\tconst signal = isString(source)\n\t\t\t\t\t\t? host.getSignal(prop)\n\t\t\t\t\t\t: toSignal(source as MaybeSignal<Q[keyof Q]>)\n\t\t\t\t\ttarget.setSignal(prop, signal)\n\t\t\t\t}\n\t\t\t})\n\t\t\t.catch(error => {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Failed to pass signals to ${elementName(target)}`,\n\t\t\t\t\t{ cause: error },\n\t\t\t\t)\n\t\t\t})\n\t}\n\n/**\n * Read a signal property from a custom element safely after it's defined\n * Returns a function that provides the signal value with fallback until component is ready\n *\n * @since 0.13.1\n * @param {Component<Q>} source - source custom element to read signal from\n * @param {K} prop - property name to get signal for\n * @param {Q[K]} fallback - fallback value to use until component is ready\n * @returns {() => Q[K]} function that returns signal value or fallback\n */\nconst read = <Q extends ComponentProps, K extends keyof Q>(\n\tsource: Component<Q> | null,\n\tprop: K,\n\tfallback: Q[K],\n): (() => Q[K]) => {\n\tif (!source) return () => fallback\n\tif (!isComponent(source))\n\t\tthrow new TypeError(`Target element must be a custom element`)\n\n\tconst awaited = computed(async () => {\n\t\tawait customElements.whenDefined(source.localName)\n\t\treturn source.getSignal(prop)\n\t})\n\n\treturn () => {\n\t\tconst value = awaited.get()\n\t\treturn value === UNSET ? fallback : (value.get() as Q[K])\n\t}\n}\n\n/**\n * Produce a computed signal for projected reactive property from a descendant component\n *\n * @since 0.13.1\n * @param {string} selector - CSS selector for descendant element\n * @param {K} prop - property name to get signal for\n * @param {Q[K]} fallback - fallback value to use until component is ready\n * @returns {SignalProducer<Q[K]>} signal producer that emits value from descendant component\n */\nconst fromDescendant =\n\t<Q extends ComponentProps, K extends keyof Q>(\n\t\tselector: string,\n\t\tprop: K,\n\t\tfallback: Q[K],\n\t): SignalProducer<Q[K]> =>\n\t(host: HTMLElement) => {\n\t\tconst element = host.querySelector<Component<Q>>(selector)\n\t\treturn computed(read(element, prop, fallback))\n\t}\n\nexport {\n\ttype ElementEventMap,\n\ttype ElementEventType,\n\ttype ValidEventName,\n\ttype PassedSignals,\n\temit,\n\tfromDescendant,\n\tfromDescendants,\n\tfromEvent,\n\tfromSelector,\n\tobserveSubtree,\n\ton,\n\tpass,\n\tread,\n\tselection,\n\tsensor,\n}\n",
    "import {\n\ttype Cleanup,\n\ttype MaybeSignal,\n\ttype Signal,\n\tUNSET,\n\tisComputed,\n\tisFunction,\n\tisSignal,\n\tisState,\n\ttoSignal,\n} from '@zeix/cause-effect'\n\nimport { observeSubtree } from './core/dom'\nimport {\n\tDEV_MODE,\n\telementName,\n\tisElement,\n\tlog,\n\ttypeString,\n\tvalueString,\n} from './core/util'\n\n/* === Types === */\n\ntype ReservedWords =\n\t| 'constructor'\n\t| 'prototype'\n\t| '__proto__'\n\t| 'toString'\n\t| 'valueOf'\n\t| 'hasOwnProperty'\n\t| 'isPrototypeOf'\n\t| 'propertyIsEnumerable'\n\t| 'toLocaleString'\n\ntype ValidPropertyKey<T> = T extends keyof HTMLElement | ReservedWords\n\t? never\n\t: T\n\ntype ComponentProps = { [K in string as ValidPropertyKey<K>]: {} }\n\ntype Component<P extends ComponentProps> = HTMLElement &\n\tP & {\n\t\t// Common Web Component lifecycle properties\n\t\tadoptedCallback?(): void\n\t\tattributeChangedCallback(\n\t\t\tname: string,\n\t\t\toldValue: string | null,\n\t\t\tnewValue: string | null,\n\t\t): void\n\t\tconnectedCallback(): void\n\t\tdisconnectedCallback(): void\n\n\t\t// Custom element properties\n\t\tdebug?: boolean\n\t\tshadowRoot: ShadowRoot | null\n\n\t\t// Component-specific signal methods\n\t\tgetSignal(prop: keyof P): Signal<P[keyof P]>\n\t\tsetSignal(prop: keyof P, signal: Signal<P[keyof P]>): void\n\t}\n\ntype AttributeParser<T extends {}, C extends HTMLElement = HTMLElement> = (\n\thost: C,\n\tvalue: string | null,\n\told?: string | null,\n) => T\n\ntype SignalProducer<T extends {}, C extends HTMLElement = HTMLElement> = (\n\thost: C,\n) => MaybeSignal<T>\n\ntype MethodProducer<C extends HTMLElement> = (host: C) => void\n\ntype Initializer<T extends {}, C extends HTMLElement> =\n\t| T\n\t| AttributeParser<T, C>\n\t| SignalProducer<T, C>\n\t| MethodProducer<C>\n\ntype FxFunction<P extends ComponentProps, E extends Element> = (\n\thost: Component<P>,\n\telement: E,\n) => Cleanup | void\n\ntype ElementFromSelector<\n\tK extends string,\n\tE extends Element = HTMLElement,\n> = K extends keyof HTMLElementTagNameMap ? HTMLElementTagNameMap[K] : E\n\ntype SelectorFunctions<P extends ComponentProps> = {\n\tfirst: <E extends Element = never, K extends string = string>(\n\t\tselector: K,\n\t\t...fns: FxFunction<P, ElementFromSelector<K, E>>[]\n\t) => (host: Component<P>) => Cleanup | void\n\tall: <E extends Element = never, K extends string = string>(\n\t\tselector: K,\n\t\t...fns: FxFunction<P, ElementFromSelector<K, E>>[]\n\t) => (host: Component<P>) => Cleanup\n}\n\n/* === Constants === */\n\n// Special value explicitly marked as any so it can be used as signal value of any type\nconst RESET: any = Symbol()\n\n// Reserved words that should never be used as property names\n// These are fundamental JavaScript/Object properties that cause serious issues\nconst RESERVED_WORDS = new Set([\n\t'constructor',\n\t'prototype',\n\t// Expand this list based on user feedback for other reserved words like:\n\t// '__proto__', 'toString', 'valueOf', 'hasOwnProperty', etc.\n])\n\n// HTMLElement properties that commonly cause conflicts\n// These are properties that exist on HTMLElement and cause confusion when overridden\n// in our reactive components because we use the same name for both attributes and properties\nconst HTML_ELEMENT_PROPS = new Set([\n\t'id', // DOM selector conflicts\n\t'class', // CSS class management conflicts (note: property is 'className')\n\t'className', // CSS class management conflicts (note: HTML attribute is 'class')\n\t'title', // Conflicts with tooltip behavior\n\t'role', // ARIA/accessibility conflicts\n\t'style', // Conflicts with style object\n\t'dataset', // Conflicts with data-* attribute access\n\t'lang', // Language/i18n conflicts\n\t'dir', // Text direction conflicts\n\t'hidden', // Visibility control conflicts\n\t'children', // DOM manipulation conflicts\n\t'innerHTML', // DOM manipulation conflicts\n\t'outerHTML', // Full element HTML conflicts\n\t'textContent', // Text manipulation conflicts\n\t'innerText', // Text manipulation conflicts\n\t// TO EXPAND: Add properties based on user feedback and common mistakes\n\t// 'tabindex', 'tabIndex', 'slot', 'part', etc.\n])\n\n/* === Internal Functions === */\n\nconst isAttributeParser = <T extends {}, C extends HTMLElement = HTMLElement>(\n\tvalue: unknown,\n): value is AttributeParser<T, C> => isFunction(value) && value.length >= 2\n\n/**\n * Simple fail-fast validation that checks for specific problematic cases\n *\n * This validation prevents common mistakes where developers accidentally\n * use property names that conflict with native HTMLElement functionality.\n */\nconst validatePropertyName = (prop: string): string | null => {\n\t// Check for reserved words that should never be used\n\tif (RESERVED_WORDS.has(prop)) {\n\t\treturn `Property name \"${prop}\" is a reserved word`\n\t}\n\n\t// Check for problematic HTMLElement properties\n\tif (HTML_ELEMENT_PROPS.has(prop)) {\n\t\treturn `Property name \"${prop}\" conflicts with inherited HTMLElement property`\n\t}\n\n\treturn null\n}\n\n/**\n * Run one or more functions on a component's element\n *\n * @since 0.12.0\n * @param {FxFunction<P, E>[]} fns - functions to run\n * @param {Component<P>} host - component host element\n * @param {E} target - target element\n * @returns {Cleanup} - a cleanup function that runs collected cleanup functions\n */\nconst run = <P extends ComponentProps, E extends Element = Component<P>>(\n\tfns: FxFunction<P, E>[],\n\thost: Component<P>,\n\ttarget: E = host as unknown as E,\n): Cleanup => {\n\tconst cleanups = fns.filter(isFunction).map(fn => fn(host, target))\n\treturn () => {\n\t\tcleanups.filter(isFunction).forEach(cleanup => cleanup())\n\t\tcleanups.length = 0\n\t}\n}\n\n/**\n * Create partially applied helper functions to select sub-elements\n *\n * @since 0.13.0\n * @returns {UI<P>} - helper functions for selecting sub-elements\n */\nconst select = <P extends ComponentProps>(): SelectorFunctions<P> => ({\n\t/**\n\t * Apply effect functions to a first matching sub-element within the custom element\n\t *\n\t * @since 0.12.0\n\t * @param {K} selector - selector to match sub-element\n\t */\n\tfirst:\n\t\t<E extends Element = never, K extends string = string>(\n\t\t\tselector: K,\n\t\t\t...fns: FxFunction<P, ElementFromSelector<K, E>>[]\n\t\t) =>\n\t\t(host: Component<P>): Cleanup | void => {\n\t\t\tconst el = (host.shadowRoot || host).querySelector<\n\t\t\t\tElementFromSelector<K, E>\n\t\t\t>(selector)\n\t\t\tif (el) run(fns, host, el)\n\t\t},\n\n\t/**\n\t * Apply effect functions to all matching sub-elements within the custom element\n\t *\n\t * @since 0.12.0\n\t * @param {K} selector - selector to match sub-elements\n\t */\n\tall:\n\t\t<E extends Element = never, K extends string = string>(\n\t\t\tselector: K,\n\t\t\t...fns: FxFunction<P, ElementFromSelector<K, E>>[]\n\t\t) =>\n\t\t(host: Component<P>): Cleanup => {\n\t\t\tconst cleanups = new Map<ElementFromSelector<K, E>, Cleanup>()\n\t\t\tconst root = host.shadowRoot || host\n\n\t\t\tconst attach = (target: ElementFromSelector<K, E>) => {\n\t\t\t\tif (!cleanups.has(target))\n\t\t\t\t\tcleanups.set(target, run(fns, host, target))\n\t\t\t}\n\n\t\t\tconst detach = (target: ElementFromSelector<K, E>) => {\n\t\t\t\tconst cleanup = cleanups.get(target)\n\t\t\t\tif (isFunction(cleanup)) cleanup()\n\t\t\t\tcleanups.delete(target)\n\t\t\t}\n\n\t\t\tconst applyToMatching =\n\t\t\t\t(fn: (target: ElementFromSelector<K, E>) => void) =>\n\t\t\t\t(node: Node) => {\n\t\t\t\t\tif (isElement(node)) {\n\t\t\t\t\t\tif (node.matches(selector))\n\t\t\t\t\t\t\tfn(node as ElementFromSelector<K, E>)\n\t\t\t\t\t\tnode.querySelectorAll<ElementFromSelector<K, E>>(\n\t\t\t\t\t\t\tselector,\n\t\t\t\t\t\t).forEach(fn)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tconst observer = observeSubtree(root, selector, mutations => {\n\t\t\t\tfor (const mutation of mutations) {\n\t\t\t\t\tmutation.addedNodes.forEach(applyToMatching(attach))\n\t\t\t\t\tmutation.removedNodes.forEach(applyToMatching(detach))\n\t\t\t\t}\n\t\t\t})\n\n\t\t\troot.querySelectorAll<ElementFromSelector<K, E>>(selector).forEach(\n\t\t\t\tattach,\n\t\t\t)\n\n\t\t\treturn () => {\n\t\t\t\tobserver.disconnect()\n\t\t\t\tcleanups.forEach(cleanup => cleanup())\n\t\t\t\tcleanups.clear()\n\t\t\t}\n\t\t},\n})\n\n/* === Exported Function === */\n\n/**\n * Define a component with its states and setup function (connectedCallback)\n *\n * @since 0.12.0\n * @param {string} name - name of the custom element\n * @param {{ [K in keyof S]: Initializer<S[K], Component<P>> }} init - signals of the component\n * @param {FxFunction<S>[]} setup - setup function to be called in connectedCallback(), may return cleanup function to be called in disconnectedCallback()\n * @returns {typeof HTMLElement & P} - constructor function for the custom element\n */\nconst component = <P extends ComponentProps>(\n\tname: string,\n\tinit: {\n\t\t[K in keyof P]: Initializer<P[K], Component<P>>\n\t} = {} as {\n\t\t[K in keyof P]: Initializer<P[K], Component<P>>\n\t},\n\tsetup: (\n\t\thost: Component<P>,\n\t\tselect: SelectorFunctions<P>,\n\t) => FxFunction<P, Component<P>>[],\n): Component<P> => {\n\tfor (const prop of Object.keys(init)) {\n\t\tconst error = validatePropertyName(prop)\n\t\tif (error) {\n\t\t\tthrow new TypeError(`${error} in component \"${name}\".`)\n\t\t}\n\t}\n\n\tclass CustomElement extends HTMLElement {\n\t\tdebug?: boolean\n\t\t#signals: {\n\t\t\t[K in keyof P]: Signal<P[keyof P]>\n\t\t} = {} as {\n\t\t\t[K in keyof P]: Signal<P[keyof P]>\n\t\t}\n\t\t#cleanup: Cleanup | undefined\n\n\t\tstatic observedAttributes =\n\t\t\tObject.entries(init)\n\t\t\t\t?.filter(([, ini]) => isAttributeParser(ini))\n\t\t\t\t.map(([prop]) => prop) ?? []\n\n\t\t/**\n\t\t * Constructor function for the custom element: initializes signals\n\t\t */\n\t\tconstructor() {\n\t\t\tsuper()\n\t\t\tfor (const [prop, ini] of Object.entries(init)) {\n\t\t\t\tif (ini == null) continue\n\t\t\t\tconst result = isAttributeParser<\n\t\t\t\t\tSignal<P[keyof P]>,\n\t\t\t\t\tComponent<P>\n\t\t\t\t>(ini)\n\t\t\t\t\t? ini(this as unknown as Component<P>, null)\n\t\t\t\t\t: isFunction<Component<P>>(ini)\n\t\t\t\t\t\t? ini(this as unknown as Component<P>)\n\t\t\t\t\t\t: ini\n\t\t\t\tif (result != null) this.setSignal(prop, toSignal(result))\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Native callback function when the custom element is first connected to the document\n\t\t */\n\t\tconnectedCallback() {\n\t\t\tif (DEV_MODE) {\n\t\t\t\tthis.debug = this.hasAttribute('debug')\n\t\t\t\tif (this.debug) log(this, 'Connected')\n\t\t\t}\n\t\t\tconst fns = setup(this as unknown as Component<P>, select())\n\t\t\tif (!Array.isArray(fns))\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Expected array of functions as return value of setup function in ${elementName(this)}`,\n\t\t\t\t)\n\t\t\tthis.#cleanup = run(fns, this as unknown as Component<P>)\n\t\t}\n\n\t\t/**\n\t\t * Native callback function when the custom element is disconnected from the document\n\t\t */\n\t\tdisconnectedCallback() {\n\t\t\tif (isFunction(this.#cleanup)) this.#cleanup()\n\t\t\tif (DEV_MODE && this.debug) log(this, 'Disconnected')\n\t\t}\n\n\t\t/**\n\t\t * Native callback function when an observed attribute of the custom element changes\n\t\t *\n\t\t * @param {string} attr - name of the modified attribute\n\t\t * @param {string | null} old - old value of the modified attribute\n\t\t * @param {string | null} value - new value of the modified attribute\n\t\t */\n\t\tattributeChangedCallback(\n\t\t\tattr: string,\n\t\t\told: string | null,\n\t\t\tvalue: string | null,\n\t\t) {\n\t\t\tif (value === old || isComputed(this.#signals[attr])) return // unchanged or controlled by computed\n\t\t\tconst parse = init[attr as keyof P]\n\t\t\tif (!isAttributeParser<P[keyof P]>(parse)) return\n\t\t\tconst parsed = parse(this as unknown as Component<P>, value, old)\n\t\t\tif (DEV_MODE && this.debug)\n\t\t\t\tlog(\n\t\t\t\t\tvalue,\n\t\t\t\t\t`Attribute \"${attr}\" of ${elementName(this)} changed from ${valueString(old)} to ${valueString(value)}, parsed as <${typeString(parsed)}> ${valueString(parsed)}`,\n\t\t\t\t)\n\t\t\t;(this as unknown as P)[attr as keyof P] = parsed\n\t\t}\n\n\t\t/**\n\t\t * Get the the signal for a given key\n\t\t *\n\t\t * @since 0.12.0\n\t\t * @param {K} key - key to get signal for\n\t\t * @returns {S[K]} current value of signal; undefined if state does not exist\n\t\t */\n\t\tgetSignal(key: keyof P): Signal<P[keyof P]> {\n\t\t\tconst signal = this.#signals[key]\n\t\t\tif (DEV_MODE && this.debug)\n\t\t\t\tlog(\n\t\t\t\t\tsignal,\n\t\t\t\t\t`Get ${typeString(signal)} \"${String(key)}\" in ${elementName(this)}`,\n\t\t\t\t)\n\t\t\treturn signal\n\t\t}\n\n\t\t/**\n\t\t * Set the signal for a given key\n\t\t *\n\t\t * @since 0.12.0\n\t\t * @param {keyof P} key - key to set signal for\n\t\t * @param {Signal<P[keyof P]>} signal - signal to set value to\n\t\t * @throws {TypeError} if key is not a valid property key\n\t\t * @throws {TypeError} if signal is not a valid signal\n\t\t * @returns {void}\n\t\t */\n\t\tsetSignal(key: keyof P, signal: Signal<P[keyof P]>): void {\n\t\t\tconst error = validatePropertyName(String(key))\n\t\t\tif (error) throw new TypeError(`${error} on ${elementName(this)}.`)\n\t\t\tif (!isSignal(signal))\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Expected signal as value for property \"${String(key)}\" on ${elementName(this)}.`,\n\t\t\t\t)\n\t\t\tconst prev = this.#signals[key]\n\t\t\tconst writable = isState(signal)\n\t\t\tthis.#signals[key] = signal\n\t\t\tObject.defineProperty(this, key, {\n\t\t\t\tget: signal.get,\n\t\t\t\tset: writable ? signal.set : undefined,\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: writable,\n\t\t\t})\n\t\t\tif (prev && isState(prev)) prev.set(UNSET)\n\t\t\tif (DEV_MODE && this.debug)\n\t\t\t\tlog(\n\t\t\t\t\tsignal,\n\t\t\t\t\t`Set ${typeString(signal)} \"${String(key)} in ${elementName(this)}`,\n\t\t\t\t)\n\t\t}\n\t}\n\tcustomElements.define(name, CustomElement)\n\treturn CustomElement as unknown as Component<P>\n}\n\nexport {\n\ttype Component,\n\ttype ComponentProps,\n\ttype ValidPropertyKey,\n\ttype ReservedWords,\n\ttype Initializer,\n\ttype AttributeParser,\n\ttype SignalProducer,\n\ttype MethodProducer,\n\ttype FxFunction,\n\ttype ElementFromSelector,\n\ttype SelectorFunctions,\n\tRESET,\n\tcomponent,\n}\n",
    "import {\n\ttype Cleanup,\n\ttype MaybeSignal,\n\ttype Signal,\n\tisFunction,\n\ttoSignal,\n} from '@zeix/cause-effect'\n\nimport { type Component, type ComponentProps } from '../component'\n\n/** @see https://github.com/webcomponents-cg/community-protocols/blob/main/proposals/context.md */\n\n/* === Type definitions === */\n\n/**\n * A context key.\n *\n * A context key can be any type of object, including strings and symbols. The\n *  Context type brands the key type with the `__context__` property that\n * carries the type of the value the context references.\n */\ntype Context<K, V> = K & { __context__: V }\n\n/**\n * An unknown context type\n */\ntype UnknownContext = Context<unknown, unknown>\n\n/**\n * A helper type which can extract a Context value type from a Context type\n */\ntype ContextType<T extends UnknownContext> = T extends Context<string, infer V>\n\t? V\n\t: never\n\n/**\n * A callback which is provided by a context requester and is called with the value satisfying the request.\n * This callback can be called multiple times by context providers as the requested value is changed.\n */\ntype ContextCallback<V> = (value: V, unsubscribe?: () => void) => void\n\ndeclare global {\n\tinterface HTMLElementEventMap {\n\t\t/**\n\t\t * A 'context-request' event can be emitted by any element which desires\n\t\t * a context value to be injected by an external provider.\n\t\t */\n\t\t'context-request': ContextRequestEvent<Context<string, unknown>>\n\t}\n}\n\n/* === Constants === */\n\nconst CONTEXT_REQUEST = 'context-request'\n\n/* === Exported class === */\n\n/**\n * Class for context-request events\n *\n * An event fired by a context requester to signal it desires a named context.\n *\n * A provider should inspect the `context` property of the event to determine if it has a value that can\n * satisfy the request, calling the `callback` with the requested value if so.\n *\n * If the requested context event contains a truthy `subscribe` value, then a provider can call the callback\n * multiple times if the value is changed, if this is the case the provider should pass an `unsubscribe`\n * function to the callback which requesters can invoke to indicate they no longer wish to receive these updates.\n *\n * @class ContextRequestEvent\n * @extends {Event}\n *\n * @property {T} context - context key\n * @property {ContextCallback<ContextType<T>>} callback - callback function for value getter and unsubscribe function\n * @property {boolean} [subscribe=false] - whether to subscribe to context changes\n */\nclass ContextRequestEvent<T extends UnknownContext> extends Event {\n\tconstructor(\n\t\tpublic readonly context: T,\n\t\tpublic readonly callback: ContextCallback<ContextType<T>>,\n\t\tpublic readonly subscribe: boolean = false,\n\t) {\n\t\tsuper(CONTEXT_REQUEST, {\n\t\t\tbubbles: true,\n\t\t\tcomposed: true,\n\t\t})\n\t}\n}\n\n/**\n * Provide a context for descendant component consumers\n *\n * @since 0.12.0\n * @param {Context<string, Signal<T>>[]} provided - array of contexts to provide\n * @returns {(host: Component<P>) => Cleanup} - function to add an event listener for ContextRequestEvent returning a cleanup function to remove the event listener\n */\nconst provide =\n\t<P extends ComponentProps, K extends keyof P>(\n\t\tprovided: Context<K, Signal<P[K]>>[],\n\t): ((host: Component<P>) => Cleanup) =>\n\t(host: Component<P>) => {\n\t\tconst listener = (e: Event) => {\n\t\t\tconst { context, callback } = e as ContextRequestEvent<\n\t\t\t\tContext<K, Signal<P[K]>>\n\t\t\t>\n\t\t\tif (provided.includes(context) && isFunction(callback)) {\n\t\t\t\te.stopPropagation()\n\t\t\t\tcallback(host.getSignal(String(context)))\n\t\t\t}\n\t\t}\n\t\thost.addEventListener(CONTEXT_REQUEST, listener)\n\t\treturn () => host.removeEventListener(CONTEXT_REQUEST, listener)\n\t}\n\n/**\n * Consume a context value for a component.\n *\n * @since 0.13.1\n * @param {Context<string, Signal<T>>} context - context key to consume\n * @param {MaybeSignal<T>} fallback - fallback value to use if context is not provided\n * @returns {(host: C) => Signal<T>} - a function that returns the consumed context signal or a signal of the fallback value\n */\nconst fromContext =\n\t<T extends {}, C extends HTMLElement>(\n\t\tcontext: Context<string, Signal<T>>,\n\t\tfallback: MaybeSignal<T>,\n\t): ((host: C) => Signal<T>) =>\n\t(host: C) => {\n\t\tlet consumed: Signal<T> = toSignal(fallback)\n\t\thost.dispatchEvent(\n\t\t\tnew ContextRequestEvent(context, (value: Signal<T>) => {\n\t\t\t\tconsumed = value\n\t\t\t}),\n\t\t)\n\t\treturn consumed\n\t}\n\nexport {\n\ttype Context,\n\ttype UnknownContext,\n\ttype ContextType,\n\tCONTEXT_REQUEST,\n\tContextRequestEvent,\n\tprovide,\n\tfromContext,\n}\n",
    "import type { AttributeParser } from '../component'\n\n/* === Internal Function === */\n\nconst parseNumber = (\n\tparseFn: (v: string) => number,\n\tvalue: string | null,\n): number | undefined => {\n\tif (value == null) return\n\tconst parsed = parseFn(value)\n\treturn Number.isFinite(parsed) ? parsed : undefined\n}\n\n/* === Exported Functions === */\n\n/**\n * Parse a boolean attribute as an actual boolean value\n *\n * @since 0.13.1\n * @returns {AttributeParser<boolean>}\n */\nconst asBoolean =\n\t(): AttributeParser<boolean> =>\n\t(_: HTMLElement, value: string | null): boolean =>\n\t\tvalue !== 'false' && value != null\n\n/**\n * Parse an attribute as as number forced to integer with a fallback\n *\n * Supports hexadecimal and scientific notation\n *\n * @since 0.11.0\n * @param {number} [fallback=0] - fallback value\n * @returns {AttributeParser<number>} parser function\n */\nconst asInteger =\n\t(fallback: number = 0): AttributeParser<number> =>\n\t(_: HTMLElement, value: string | null): number => {\n\t\tif (value == null) return fallback\n\t\tconst trimmed = value.trim()\n\t\tif (trimmed === '') return fallback\n\n\t\t// Handle hexadecimal notation\n\t\tif (trimmed.toLowerCase().startsWith('0x')) {\n\t\t\tconst parsed = parseInt(trimmed, 16)\n\t\t\treturn Number.isFinite(parsed) ? parsed : fallback\n\t\t}\n\n\t\t// Handle other formats (including scientific notation)\n\t\tconst parsed = parseNumber(parseFloat, value)\n\t\treturn parsed != null ? Math.trunc(parsed) : fallback\n\t}\n\n/**\n * Parse an attribute as as number with a fallback\n *\n * @since 0.11.0\n * @param {number} [fallback=0] - fallback value\n * @returns {AttributeParser<number>} parser function\n */\nconst asNumber =\n\t(fallback: number = 0): AttributeParser<number> =>\n\t(_: HTMLElement, value: string | null): number =>\n\t\tparseNumber(parseFloat, value) ?? fallback\n\n/**\n * Parse an attribute as a string with a fallback\n *\n * @since 0.11.0\n * @param {string} [fallback=''] - fallback value\n * @returns {AttributeParser<string>} parser function\n */\nconst asString =\n\t(fallback: string = ''): AttributeParser<string> =>\n\t(_: HTMLElement, value: string | null): string =>\n\t\tvalue ?? fallback\n\n/**\n * Parse an attribute as a multi-state value (for examnple: true, false, mixed), defaulting to the first valid option\n *\n * @since 0.9.0\n * @param {string[]} valid - array of valid values\n * @returns {AttributeParser<string>} parser function\n */\nconst asEnum =\n\t(valid: [string, ...string[]]): AttributeParser<string> =>\n\t(_: HTMLElement, value: string | null): string => {\n\t\tif (value == null) return valid[0]\n\t\tconst lowerValue = value.toLowerCase()\n\t\tconst matchingValid = valid.find(v => v.toLowerCase() === lowerValue)\n\t\treturn matchingValid ? value : valid[0]\n\t}\n\n/**\n * Parse an attribute as a JSON serialized object with a fallback\n *\n * @since 0.11.0\n * @param {T} fallback - fallback value\n * @returns {AttributeParser<T>} parser function\n * @throws {ReferenceError} if the value and fallback are both null or undefined\n * @throws {SyntaxError} if the value is not a valid JSON object\n */\nconst asJSON =\n\t<T extends {}>(fallback: T): AttributeParser<T> =>\n\t(_: HTMLElement, value: string | null): T => {\n\t\tif ((value ?? fallback) == null)\n\t\t\tthrow new ReferenceError(\n\t\t\t\t'Value and fallback are both null or undefined',\n\t\t\t)\n\t\tif (value == null) return fallback\n\t\tif (value === '')\n\t\t\tthrow new SyntaxError('Empty string is not valid JSON')\n\t\tlet result: T | undefined\n\t\ttry {\n\t\t\tresult = JSON.parse(value)\n\t\t} catch (error) {\n\t\t\tthrow new SyntaxError(`Failed to parse JSON: ${String(error)}`, {\n\t\t\t\tcause: error,\n\t\t\t})\n\t\t}\n\t\treturn result ?? fallback\n\t}\n\nexport { asBoolean, asInteger, asNumber, asString, asEnum, asJSON }\n",
    "import {\n\ttype Cleanup,\n\ttype Signal,\n\tUNSET,\n\teffect,\n\tenqueue,\n\tisFunction,\n\tisSignal,\n\tisState,\n} from '@zeix/cause-effect'\n\nimport {\n\ttype Component,\n\ttype ComponentProps,\n\ttype FxFunction,\n\tRESET,\n} from '../component'\nimport {\n\tDEV_MODE,\n\tLOG_ERROR,\n\telementName,\n\tisString,\n\tlog,\n\tvalueString,\n} from '../core/util'\n\n/* === Types === */\n\ntype SignalLike<P extends ComponentProps, T, E extends Element = HTMLElement> =\n\t| keyof P\n\t| Signal<NonNullable<T>>\n\t| ((element: E) => T | null | undefined)\n\ntype UpdateOperation = 'a' | 'c' | 'h' | 'p' | 's' | 't'\n\ntype ElementUpdater<E extends Element, T> = {\n\top: UpdateOperation\n\tname?: string\n\tread: (element: E) => T | null\n\tupdate: (element: E, value: T) => void\n\tdelete?: (element: E) => void\n\tresolve?: (element: E) => void\n\treject?: (error: unknown) => void\n}\n\ntype ElementInserter<E extends Element> = {\n\tposition?: InsertPosition\n\tcreate: (parent: E) => Element | null\n\tresolve?: (parent: E) => void\n\treject?: (error: unknown) => void\n}\n\ntype DangerouslySetInnerHTMLOptions = {\n\tshadowRootMode?: ShadowRootMode\n\tallowScripts?: boolean\n}\n\n/* === Internal === */\n\nconst resolveSignalLike = /*#__PURE__*/ <\n\tP extends ComponentProps,\n\tT extends {},\n\tE extends Element = Component<P>,\n>(\n\ts: SignalLike<P, T, E>,\n\thost: Component<P>,\n\ttarget: E,\n): T =>\n\tisString(s)\n\t\t? (host.getSignal(s).get() as unknown as T)\n\t\t: isSignal(s)\n\t\t\t? s.get()\n\t\t\t: isFunction<T>(s)\n\t\t\t\t? s(target)\n\t\t\t\t: RESET\n\nconst isSafeURL = /*#__PURE__*/ (value: string): boolean => {\n\tif (/^(mailto|tel):/i.test(value)) return true\n\tif (value.includes('://')) {\n\t\ttry {\n\t\t\tconst url = new URL(value, window.location.origin)\n\t\t\treturn ['http:', 'https:', 'ftp:'].includes(url.protocol)\n\t\t} catch (_error) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nconst safeSetAttribute = /*#__PURE__*/ (\n\telement: Element,\n\tattr: string,\n\tvalue: string,\n): void => {\n\tif (/^on/i.test(attr)) throw new Error(`Unsafe attribute: ${attr}`)\n\tvalue = String(value).trim()\n\tif (!isSafeURL(value)) throw new Error(`Unsafe URL for ${attr}: ${value}`)\n\telement.setAttribute(attr, value)\n}\n\n/* === Exported Functions === */\n\n/**\n * Effect for setting properties of a target element according to a given SignalLike\n *\n * @since 0.9.0\n * @param {SignalLike<T>} s - state bound to the element property\n * @param {ElementUpdater} updater - updater object containing key, read, update, and delete methods\n */\nconst updateElement =\n\t<P extends ComponentProps, T extends {}, E extends Element = HTMLElement>(\n\t\ts: SignalLike<P, T, E>,\n\t\tupdater: ElementUpdater<E, T>,\n\t): FxFunction<P, E> =>\n\t(host: Component<P>, target: E): Cleanup => {\n\t\tconst { op, name = '', read, update } = updater\n\t\tconst fallback = read(target)\n\t\tconst ops: Record<string, string> = {\n\t\t\ta: 'attribute ',\n\t\t\tc: 'class ',\n\t\t\th: 'inner HTML',\n\t\t\tp: 'property ',\n\t\t\ts: 'style property ',\n\t\t\tt: 'text content',\n\t\t}\n\n\t\t// If not yet set, set signal value to value read from DOM\n\t\tif (isString(s) && isString(fallback) && host[s] === RESET)\n\t\t\thost.attributeChangedCallback(s, null, fallback)\n\n\t\tconst ok = (verb: string) => () => {\n\t\t\tif (DEV_MODE && host.debug)\n\t\t\t\tlog(\n\t\t\t\t\ttarget,\n\t\t\t\t\t`${verb} ${ops[op] + name} of ${elementName(target)} in ${elementName(host)}`,\n\t\t\t\t)\n\t\t\tupdater.resolve?.(target)\n\t\t}\n\t\tconst err = (verb: string) => (error: unknown) => {\n\t\t\tlog(\n\t\t\t\terror,\n\t\t\t\t`Failed to ${verb} ${ops[op] + name} of ${elementName(target)} in ${elementName(host)}`,\n\t\t\t\tLOG_ERROR,\n\t\t\t)\n\t\t\tupdater.reject?.(error)\n\t\t}\n\n\t\t// Update the element's DOM state according to the signal value\n\t\treturn effect(() => {\n\t\t\tconst UPDATE_DEDUPE = Symbol(`${op}:${name}`)\n\t\t\tconst DELETE_DEDUPE = Symbol(`${op}-${name}`)\n\t\t\tlet value = RESET\n\t\t\ttry {\n\t\t\t\tvalue = resolveSignalLike(s, host, target)\n\t\t\t} catch (error) {\n\t\t\t\tlog(\n\t\t\t\t\terror,\n\t\t\t\t\t`Failed to resolve value of ${valueString(s)} for ${ops[op] + name} of ${elementName(target)} in ${elementName(host)}`,\n\t\t\t\t\tLOG_ERROR,\n\t\t\t\t)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (value === RESET) value = fallback\n\t\t\telse if (value === UNSET) value = updater.delete ? null : fallback\n\n\t\t\t// Nil path => delete the attribute or style property of the element\n\t\t\tif (updater.delete && value === null) {\n\t\t\t\tenqueue(() => {\n\t\t\t\t\tupdater.delete!(target)\n\t\t\t\t\treturn true\n\t\t\t\t}, DELETE_DEDUPE)\n\t\t\t\t\t.then(ok('Deleted'))\n\t\t\t\t\t.catch(err('delete'))\n\n\t\t\t\t// Ok path => update the element\n\t\t\t} else if (value != null) {\n\t\t\t\tconst current = read(target)\n\t\t\t\tif (Object.is(value, current)) return\n\t\t\t\tenqueue(() => {\n\t\t\t\t\tupdate(target, value)\n\t\t\t\t\treturn true\n\t\t\t\t}, UPDATE_DEDUPE)\n\t\t\t\t\t.then(ok('Updated'))\n\t\t\t\t\t.catch(err('update'))\n\t\t\t}\n\t\t})\n\t}\n\n/**\n * Effect for inserting or removing elements according to a given SignalLike\n *\n * @since 0.12.1\n * @param {SignalLike<P, E, number>} s - state bound to the number of elements to insert (positive) or remove (negative)\n * @param {ElementInserter<E>} inserter - inserter object containing position, insert, and remove methods\n */\nconst insertOrRemoveElement =\n\t<P extends ComponentProps, E extends Element = HTMLElement>(\n\t\ts: SignalLike<P, number, E>,\n\t\tinserter?: ElementInserter<E>,\n\t): FxFunction<P, E> =>\n\t(host: Component<P>, target: E) => {\n\t\tconst ok = (verb: string) => () => {\n\t\t\tif (DEV_MODE && host.debug)\n\t\t\t\tlog(\n\t\t\t\t\ttarget,\n\t\t\t\t\t`${verb} element in ${elementName(target)} in ${elementName(host)}`,\n\t\t\t\t)\n\t\t\tif (isFunction(inserter?.resolve)) {\n\t\t\t\tinserter.resolve(target)\n\t\t\t} else {\n\t\t\t\tconst signal = isSignal(s)\n\t\t\t\t\t? s\n\t\t\t\t\t: isString(s)\n\t\t\t\t\t\t? host.getSignal(s)\n\t\t\t\t\t\t: undefined\n\t\t\t\tif (isState<number>(signal)) signal.set(0)\n\t\t\t}\n\t\t}\n\t\tconst err = (verb: string) => (error: unknown) => {\n\t\t\tlog(\n\t\t\t\terror,\n\t\t\t\t`Failed to ${verb} element in ${elementName(target)} in ${elementName(host)}`,\n\t\t\t\tLOG_ERROR,\n\t\t\t)\n\t\t\tinserter?.reject?.(error)\n\t\t}\n\n\t\treturn effect(() => {\n\t\t\tconst INSERT_DEDUPE = Symbol('i')\n\t\t\tconst REMOVE_DEDUPE = Symbol('d')\n\t\t\tlet diff = 0\n\t\t\ttry {\n\t\t\t\tdiff = resolveSignalLike(s, host, target)\n\t\t\t} catch (error) {\n\t\t\t\tlog(\n\t\t\t\t\terror,\n\t\t\t\t\t`Failed to resolve value of ${valueString(s)} for insertion or deletion in ${elementName(target)} in ${elementName(host)}`,\n\t\t\t\t\tLOG_ERROR,\n\t\t\t\t)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (diff === RESET) diff = 0\n\n\t\t\tif (diff > 0) {\n\t\t\t\t// Positive diff => insert element\n\t\t\t\tif (!inserter) throw new TypeError(`No inserter provided`)\n\t\t\t\tenqueue(() => {\n\t\t\t\t\tfor (let i = 0; i < diff; i++) {\n\t\t\t\t\t\tconst element = inserter.create(target)\n\t\t\t\t\t\tif (!element) continue\n\t\t\t\t\t\ttarget.insertAdjacentElement(\n\t\t\t\t\t\t\tinserter.position ?? 'beforeend',\n\t\t\t\t\t\t\telement,\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\treturn true\n\t\t\t\t}, INSERT_DEDUPE)\n\t\t\t\t\t.then(ok('Inserted'))\n\t\t\t\t\t.catch(err('insert'))\n\t\t\t} else if (diff < 0) {\n\t\t\t\t// Negative diff => remove element\n\t\t\t\tenqueue(() => {\n\t\t\t\t\tif (\n\t\t\t\t\t\tinserter &&\n\t\t\t\t\t\t(inserter.position === 'afterbegin' ||\n\t\t\t\t\t\t\tinserter.position === 'beforeend')\n\t\t\t\t\t) {\n\t\t\t\t\t\tfor (let i = 0; i > diff; i--) {\n\t\t\t\t\t\t\tif (inserter.position === 'afterbegin')\n\t\t\t\t\t\t\t\ttarget.firstElementChild?.remove()\n\t\t\t\t\t\t\telse target.lastElementChild?.remove()\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget.remove()\n\t\t\t\t\t}\n\t\t\t\t\treturn true\n\t\t\t\t}, REMOVE_DEDUPE)\n\t\t\t\t\t.then(ok('Removed'))\n\t\t\t\t\t.catch(err('remove'))\n\t\t\t}\n\t\t})\n\t}\n\n/**\n * Set text content of an element\n *\n * @since 0.8.0\n * @param {SignalLike<string>} s - state bound to the text content\n */\nconst setText = <P extends ComponentProps, E extends Element = HTMLElement>(\n\ts: SignalLike<P, string, E>,\n): FxFunction<P, E> =>\n\tupdateElement(s, {\n\t\top: 't',\n\t\tread: el => el.textContent,\n\t\tupdate: (el, value) => {\n\t\t\tArray.from(el.childNodes)\n\t\t\t\t.filter(node => node.nodeType !== Node.COMMENT_NODE)\n\t\t\t\t.forEach(node => node.remove())\n\t\t\tel.append(document.createTextNode(value))\n\t\t},\n\t})\n\n/**\n * Set property of an element\n *\n * @since 0.8.0\n * @param {string} key - name of property to be set\n * @param {SignalLike<E[K]>} s - state bound to the property value\n */\nconst setProperty = <\n\tP extends ComponentProps,\n\tK extends keyof E,\n\tE extends Element = HTMLElement,\n>(\n\tkey: K,\n\ts: SignalLike<P, E[K], E> = key as SignalLike<P, E[K], E>,\n): FxFunction<P, E> =>\n\tupdateElement(s, {\n\t\top: 'p',\n\t\tname: String(key),\n\t\tread: el => (key in el ? el[key] : UNSET),\n\t\tupdate: (el, value) => {\n\t\t\tel[key] = value\n\t\t},\n\t})\n\n/**\n * Set 'hidden' property of an element\n *\n * @since 0.13.1\n * @param {SignalLike<boolean>} s - state bound to the 'hidden' property value\n */\nconst show = <P extends ComponentProps, E extends HTMLElement = HTMLElement>(\n\ts: SignalLike<P, boolean, E>,\n): FxFunction<P, E> =>\n\tupdateElement(s, {\n\t\top: 'p',\n\t\tname: 'hidden',\n\t\tread: el => !el.hidden,\n\t\tupdate: (el, value) => {\n\t\t\tel.hidden = !value\n\t\t},\n\t})\n\n/**\n * Set attribute of an element\n *\n * @since 0.8.0\n * @param {string} name - name of attribute to be set\n * @param {SignalLike<string>} s - state bound to the attribute value\n */\nconst setAttribute = <\n\tP extends ComponentProps,\n\tE extends Element = HTMLElement,\n>(\n\tname: string,\n\ts: SignalLike<P, string, E> = name,\n): FxFunction<P, E> =>\n\tupdateElement(s, {\n\t\top: 'a',\n\t\tname,\n\t\tread: el => el.getAttribute(name),\n\t\tupdate: (el, value) => {\n\t\t\tsafeSetAttribute(el, name, value)\n\t\t},\n\t\tdelete: el => {\n\t\t\tel.removeAttribute(name)\n\t\t},\n\t})\n\n/**\n * Toggle a boolan attribute of an element\n *\n * @since 0.8.0\n * @param {string} name - name of attribute to be toggled\n * @param {SignalLike<boolean>} s - state bound to the attribute existence\n */\nconst toggleAttribute = <\n\tP extends ComponentProps,\n\tE extends Element = HTMLElement,\n>(\n\tname: string,\n\ts: SignalLike<P, boolean, E> = name,\n): FxFunction<P, E> =>\n\tupdateElement(s, {\n\t\top: 'a',\n\t\tname,\n\t\tread: el => el.hasAttribute(name),\n\t\tupdate: (el, value) => {\n\t\t\tel.toggleAttribute(name, value)\n\t\t},\n\t})\n\n/**\n * Toggle a classList token of an element\n *\n * @since 0.8.0\n * @param {string} token - class token to be toggled\n * @param {SignalLike<boolean>} s - state bound to the class existence\n */\nconst toggleClass = <P extends ComponentProps, E extends Element = HTMLElement>(\n\ttoken: string,\n\ts: SignalLike<P, boolean, E> = token,\n): FxFunction<P, E> =>\n\tupdateElement(s, {\n\t\top: 'c',\n\t\tname: token,\n\t\tread: el => el.classList.contains(token),\n\t\tupdate: (el, value) => {\n\t\t\tel.classList.toggle(token, value)\n\t\t},\n\t})\n\n/**\n * Set a style property of an element\n *\n * @since 0.8.0\n * @param {string} prop - name of style property to be set\n * @param {SignalLike<string>} s - state bound to the style property value\n */\nconst setStyle = <\n\tP extends ComponentProps,\n\tE extends HTMLElement | SVGElement | MathMLElement,\n>(\n\tprop: string,\n\ts: SignalLike<P, string, E> = prop,\n): FxFunction<P, E> =>\n\tupdateElement(s, {\n\t\top: 's',\n\t\tname: prop,\n\t\tread: el => el.style.getPropertyValue(prop),\n\t\tupdate: (el, value) => {\n\t\t\tel.style.setProperty(prop, value)\n\t\t},\n\t\tdelete: el => {\n\t\t\tel.style.removeProperty(prop)\n\t\t},\n\t})\n\n/**\n * Set inner HTML of an element\n *\n * @since 0.11.0\n * @param {SignalLike<string>} s - state bound to the inner HTML\n * @param {DangerouslySetInnerHTMLOptions} options - options for setting inner HTML: shadowRootMode, allowScripts\n */\nconst dangerouslySetInnerHTML = <\n\tP extends ComponentProps,\n\tE extends Element = HTMLElement,\n>(\n\ts: SignalLike<P, string, E>,\n\toptions: DangerouslySetInnerHTMLOptions = {},\n): FxFunction<P, E> =>\n\tupdateElement(s, {\n\t\top: 'h',\n\t\tread: el =>\n\t\t\t(el.shadowRoot || !options.shadowRootMode ? el : null)?.innerHTML ??\n\t\t\t'',\n\t\tupdate: (el, html) => {\n\t\t\tconst { shadowRootMode, allowScripts } = options\n\t\t\tif (!html) {\n\t\t\t\tif (el.shadowRoot) el.shadowRoot.innerHTML = '<slot></slot>'\n\t\t\t\treturn ''\n\t\t\t}\n\t\t\tif (shadowRootMode && !el.shadowRoot)\n\t\t\t\tel.attachShadow({ mode: shadowRootMode })\n\t\t\tconst target = el.shadowRoot || el\n\t\t\ttarget.innerHTML = html\n\t\t\tif (!allowScripts) return ''\n\t\t\ttarget.querySelectorAll('script').forEach(script => {\n\t\t\t\tconst newScript = document.createElement('script')\n\t\t\t\tnewScript.appendChild(\n\t\t\t\t\tdocument.createTextNode(script.textContent ?? ''),\n\t\t\t\t)\n\t\t\t\ttarget.appendChild(newScript)\n\t\t\t\tscript.remove()\n\t\t\t})\n\t\t\treturn ' with scripts'\n\t\t},\n\t})\n\n/* === Exported Types === */\n\nexport {\n\ttype SignalLike,\n\ttype UpdateOperation,\n\ttype ElementUpdater,\n\ttype ElementInserter,\n\ttype DangerouslySetInnerHTMLOptions,\n\tupdateElement,\n\tinsertOrRemoveElement,\n\tsetText,\n\tsetProperty,\n\tshow,\n\tsetAttribute,\n\ttoggleAttribute,\n\ttoggleClass,\n\tsetStyle,\n\tdangerouslySetInnerHTML,\n}\n"
  ],
  "mappings": "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",
  "debugId": "9079A5C747393B2064756E2164756E21",
  "names": []
}