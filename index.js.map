{
  "version": 3,
  "sources": ["node_modules/@zeix/cause-effect/src/util.ts", "node_modules/@zeix/cause-effect/src/scheduler.ts", "node_modules/@zeix/cause-effect/src/state.ts", "node_modules/@zeix/cause-effect/src/computed.ts", "node_modules/@zeix/cause-effect/src/signal.ts", "node_modules/@zeix/cause-effect/src/effect.ts", "src/core/util.ts", "src/core/dom.ts", "src/component.ts", "src/core/reactive.ts", "src/core/events.ts", "src/core/context.ts", "src/lib/parsers.ts", "src/lib/effects.ts", "src/lib/extractors.ts"],
  "sourcesContent": [
    "/* === Utility Functions === */\n\nconst isFunction = /*#__PURE__*/ <T>(\n\tvalue: unknown,\n): value is (...args: unknown[]) => T => typeof value === 'function'\n\nconst isObjectOfType = /*#__PURE__*/ <T>(\n\tvalue: unknown,\n\ttype: string,\n): value is T => Object.prototype.toString.call(value) === `[object ${type}]`\n\nconst toError = (reason: unknown): Error =>\n\treason instanceof Error ? reason : Error(String(reason))\n\nclass CircularDependencyError extends Error {\n\tconstructor(where: string) {\n\t\tsuper(`Circular dependency in ${where} detected`)\n\t\treturn this\n\t}\n}\n\n/* === Exports === */\n\nexport { isFunction, isObjectOfType, toError, CircularDependencyError }\n",
    "/* === Types === */\n\ntype Cleanup = () => void\n\ntype Watcher = {\n\t(): void\n\toff(cleanup: Cleanup): void\n\tcleanup(): void\n}\n\ntype Updater = <T>() => T | boolean | void\n\n/* === Internal === */\n\n// Currently active watcher\nlet active: Watcher | undefined\n\n// Pending queue for batched change notifications\nconst pending = new Set<Watcher>()\nlet batchDepth = 0\n\n// Map of deduplication symbols to update functions (using Symbol keys prevents unintended overwrites)\nconst updateMap = new Map<symbol, Updater>()\nlet requestId: number | undefined\n\nconst updateDOM = () => {\n\trequestId = undefined\n\tconst updates = Array.from(updateMap.values())\n\tupdateMap.clear()\n\tfor (const update of updates) {\n\t\tupdate()\n\t}\n}\n\nconst requestTick = () => {\n\tif (requestId) cancelAnimationFrame(requestId)\n\trequestId = requestAnimationFrame(updateDOM)\n}\n\n// Initial render when the call stack is empty\nqueueMicrotask(updateDOM)\n\n/* === Functions === */\n\n/**\n * Create a watcher that can be used to observe changes to a signal\n *\n * @since 0.14.1\n * @param {() => void} notice - function to be called when the state changes\n * @returns {Watcher} - watcher object with off and cleanup methods\n */\nconst watch = (notice: () => void): Watcher => {\n\tconst cleanups = new Set<Cleanup>()\n\tconst w = notice as Partial<Watcher>\n\tw.off = (on: Cleanup) => {\n\t\tcleanups.add(on)\n\t}\n\tw.cleanup = () => {\n\t\tfor (const cleanup of cleanups) {\n\t\t\tcleanup()\n\t\t}\n\t\tcleanups.clear()\n\t}\n\treturn w as Watcher\n}\n\n/**\n * Add active watcher to the Set of watchers\n *\n * @param {Set<Watcher>} watchers - watchers of the signal\n */\nconst subscribe = (watchers: Set<Watcher>) => {\n\tif (active && !watchers.has(active)) {\n\t\tconst watcher = active\n\t\twatchers.add(watcher)\n\t\tactive.off(() => {\n\t\t\twatchers.delete(watcher)\n\t\t})\n\t}\n}\n\n/**\n * Add watchers to the pending set of change notifications\n *\n * @param {Set<Watcher>} watchers - watchers of the signal\n */\nconst notify = (watchers: Set<Watcher>) => {\n\tfor (const watcher of watchers) {\n\t\tif (batchDepth) pending.add(watcher)\n\t\telse watcher()\n\t}\n}\n\n/**\n * Flush all pending changes to notify watchers\n */\nconst flush = () => {\n\twhile (pending.size) {\n\t\tconst watchers = Array.from(pending)\n\t\tpending.clear()\n\t\tfor (const watcher of watchers) {\n\t\t\twatcher()\n\t\t}\n\t}\n}\n\n/**\n * Batch multiple changes in a single signal graph and DOM update cycle\n *\n * @param {() => void} fn - function with multiple signal writes to be batched\n */\nconst batch = (fn: () => void) => {\n\tbatchDepth++\n\ttry {\n\t\tfn()\n\t} finally {\n\t\tflush()\n\t\tbatchDepth--\n\t}\n}\n\n/**\n * Run a function in a reactive context\n *\n * @param {() => void} run - function to run the computation or effect\n * @param {Watcher} watcher - function to be called when the state changes or undefined for temporary unwatching while inserting auto-hydrating DOM nodes that might read signals (e.g., web components)\n */\nconst observe = (run: () => void, watcher?: Watcher): void => {\n\tconst prev = active\n\tactive = watcher\n\ttry {\n\t\trun()\n\t} finally {\n\t\tactive = prev\n\t}\n}\n\n/**\n * Enqueue a function to be executed on the next animation frame\n *\n * If the same Symbol is provided for multiple calls before the next animation frame,\n * only the latest call will be executed (deduplication).\n *\n * @param {Updater} fn - function to be executed on the next animation frame; can return updated value <T>, success <boolean> or void\n * @param {symbol} dedupe - Symbol for deduplication; if not provided, a unique Symbol is created ensuring the update is always executed\n */\nconst enqueue = <T>(fn: Updater, dedupe?: symbol) =>\n\tnew Promise<T | boolean | void>((resolve, reject) => {\n\t\tupdateMap.set(dedupe || Symbol(), () => {\n\t\t\ttry {\n\t\t\t\tresolve(fn())\n\t\t\t} catch (error) {\n\t\t\t\treject(error)\n\t\t\t}\n\t\t})\n\t\trequestTick()\n\t})\n\n/* === Exports === */\n\nexport {\n\ttype Cleanup,\n\ttype Watcher,\n\ttype Updater,\n\tsubscribe,\n\tnotify,\n\tflush,\n\tbatch,\n\twatch,\n\tobserve,\n\tenqueue,\n}\n",
    "import { UNSET } from './signal'\nimport { isObjectOfType } from './util'\nimport { type Watcher, notify, subscribe } from './scheduler'\n\n/* === Types === */\n\ntype State<T extends {}> = {\n\t[Symbol.toStringTag]: 'State'\n\tget(): T\n\tset(v: T): void\n\tupdate(fn: (v: T) => T): void\n}\n\n/* === Constants === */\n\nconst TYPE_STATE = 'State'\n\n/* === Functions === */\n\n/**\n * Create a new state signal\n *\n * @since 0.9.0\n * @param {T} initialValue - initial value of the state\n * @returns {State<T>} - new state signal\n */\nconst state = /*#__PURE__*/ <T extends {}>(initialValue: T): State<T> => {\n\tconst watchers: Set<Watcher> = new Set()\n\tlet value: T = initialValue\n\n\tconst s: State<T> = {\n\t\t[Symbol.toStringTag]: TYPE_STATE,\n\n\t\t/**\n\t\t * Get the current value of the state\n\t\t *\n\t\t * @since 0.9.0\n\t\t * @returns {T} - current value of the state\n\t\t */\n\t\tget: (): T => {\n\t\t\tsubscribe(watchers)\n\t\t\treturn value\n\t\t},\n\n\t\t/**\n\t\t * Set a new value of the state\n\t\t *\n\t\t * @since 0.9.0\n\t\t * @param {T} v\n\t\t * @returns {void}\n\t\t */\n\t\tset: (v: T): void => {\n\t\t\tif (Object.is(value, v)) return\n\t\t\tvalue = v\n\t\t\tnotify(watchers)\n\n\t\t\t// Setting to UNSET clears the watchers so the signal can be garbage collected\n\t\t\tif (UNSET === value) watchers.clear()\n\t\t},\n\n\t\t/**\n\t\t * Update the state with a new value using a function\n\t\t *\n\t\t * @since 0.10.0\n\t\t * @param {(v: T) => T} fn - function to update the state\n\t\t * @returns {void} - updates the state with the result of the function\n\t\t */\n\t\tupdate: (fn: (v: T) => T): void => {\n\t\t\ts.set(fn(value))\n\t\t},\n\t}\n\n\treturn s\n}\n\n/**\n * Check if the provided value is a State instance\n *\n * @since 0.9.0\n * @param {unknown} value - value to check\n * @returns {boolean} - true if the value is a State instance, false otherwise\n */\nconst isState = /*#__PURE__*/ <T extends {}>(\n\tvalue: unknown,\n): value is State<T> => isObjectOfType(value, TYPE_STATE)\n\n/* === Exports === */\n\nexport { type State, TYPE_STATE, state, isState }\n",
    "import {\n\tCircularDependencyError,\n\tisFunction,\n\tisObjectOfType,\n\ttoError,\n} from './util'\nimport {\n\ttype Watcher,\n\twatch,\n\tsubscribe,\n\tnotify,\n\tflush,\n\tobserve,\n} from './scheduler'\nimport { UNSET } from './signal'\n\n/* === Types === */\n\ntype Computed<T extends {}> = {\n\t[Symbol.toStringTag]: 'Computed'\n\tget(): T\n}\ntype ComputedCallback<T extends {} & { then?: void }> =\n\t| ((abort: AbortSignal) => Promise<T>)\n\t| (() => T)\n\n/* === Constants === */\n\nconst TYPE_COMPUTED = 'Computed'\n\n/* === Functions === */\n\n/**\n * Create a derived signal from existing signals\n *\n * @since 0.9.0\n * @param {ComputedCallback<T>} fn - computation callback function\n * @returns {Computed<T>} - Computed signal\n */\nconst computed = <T extends {}>(fn: ComputedCallback<T>): Computed<T> => {\n\tconst watchers: Set<Watcher> = new Set()\n\n\t// Internal state\n\tlet value: T = UNSET\n\tlet error: Error | undefined\n\tlet controller: AbortController | undefined\n\tlet dirty = true\n\tlet changed = false\n\tlet computing = false\n\n\t// Functions to update internal state\n\tconst ok = (v: T) => {\n\t\tif (!Object.is(v, value)) {\n\t\t\tvalue = v\n\t\t\tchanged = true\n\t\t}\n\t\terror = undefined\n\t\tdirty = false\n\t}\n\tconst nil = () => {\n\t\tchanged = UNSET !== value\n\t\tvalue = UNSET\n\t\terror = undefined\n\t}\n\tconst err = (e: unknown) => {\n\t\tconst newError = toError(e)\n\t\tchanged =\n\t\t\t!error ||\n\t\t\tnewError.name !== error.name ||\n\t\t\tnewError.message !== error.message\n\t\tvalue = UNSET\n\t\terror = newError\n\t}\n\tconst settle =\n\t\t<T>(settleFn: (arg: T) => void) =>\n\t\t(arg: T) => {\n\t\t\tcomputing = false\n\t\t\tcontroller = undefined\n\t\t\tsettleFn(arg)\n\t\t\tif (changed) notify(watchers)\n\t\t}\n\n\t// Own watcher: called when notified from sources (push)\n\tconst mark = watch(() => {\n\t\tdirty = true\n\t\tcontroller?.abort('Aborted because source signal changed')\n\t\tif (watchers.size) notify(watchers)\n\t\telse mark.cleanup()\n\t})\n\n\t// Called when requested by dependencies (pull)\n\tconst compute = () =>\n\t\tobserve(() => {\n\t\t\tif (computing) throw new CircularDependencyError('computed')\n\t\t\tchanged = false\n\t\t\tif (isFunction(fn) && fn.constructor.name === 'AsyncFunction') {\n\t\t\t\tif (controller) return value // return current value until promise resolves\n\t\t\t\tcontroller = new AbortController()\n\t\t\t\tcontroller.signal.addEventListener(\n\t\t\t\t\t'abort',\n\t\t\t\t\t() => {\n\t\t\t\t\t\tcomputing = false\n\t\t\t\t\t\tcontroller = undefined\n\t\t\t\t\t\tcompute() // retry\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tonce: true,\n\t\t\t\t\t},\n\t\t\t\t)\n\t\t\t}\n\t\t\tlet result: T | Promise<T>\n\t\t\tcomputing = true\n\t\t\ttry {\n\t\t\t\tresult = controller ? fn(controller.signal) : (fn as () => T)()\n\t\t\t} catch (e) {\n\t\t\t\tif (e instanceof DOMException && e.name === 'AbortError') nil()\n\t\t\t\telse err(e)\n\t\t\t\tcomputing = false\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (result instanceof Promise) result.then(settle(ok), settle(err))\n\t\t\telse if (null == result || UNSET === result) nil()\n\t\t\telse ok(result)\n\t\t\tcomputing = false\n\t\t}, mark)\n\n\tconst c: Computed<T> = {\n\t\t[Symbol.toStringTag]: TYPE_COMPUTED,\n\n\t\t/**\n\t\t * Get the current value of the computed\n\t\t *\n\t\t * @since 0.9.0\n\t\t * @returns {T} - current value of the computed\n\t\t */\n\t\tget: (): T => {\n\t\t\tsubscribe(watchers)\n\t\t\tflush()\n\t\t\tif (dirty) compute()\n\t\t\tif (error) throw error\n\t\t\treturn value\n\t\t},\n\t}\n\treturn c\n}\n\n/**\n * Check if a value is a computed state\n *\n * @since 0.9.0\n * @param {unknown} value - value to check\n * @returns {boolean} - true if value is a computed state, false otherwise\n */\nconst isComputed = /*#__PURE__*/ <T extends {}>(\n\tvalue: unknown,\n): value is Computed<T> => isObjectOfType(value, TYPE_COMPUTED)\n\n/**\n * Check if the provided value is a callback that may be used as input for toSignal() to derive a computed state\n *\n * @since 0.12.0\n * @param {unknown} value - value to check\n * @returns {boolean} - true if value is a callback or callbacks object, false otherwise\n */\nconst isComputedCallback = /*#__PURE__*/ <T extends {}>(\n\tvalue: unknown,\n): value is ComputedCallback<T> => isFunction(value) && value.length < 2\n\n/* === Exports === */\n\nexport {\n\ttype Computed,\n\ttype ComputedCallback,\n\tTYPE_COMPUTED,\n\tcomputed,\n\tisComputed,\n\tisComputedCallback,\n}\n",
    "import { isState, state } from './state'\nimport {\n\ttype ComputedCallback,\n\tisComputed,\n\tisComputedCallback,\n\tcomputed,\n} from './computed'\n\n/* === Types === */\n\ntype Signal<T extends {}> = {\n\tget(): T\n}\ntype MaybeSignal<T extends {}> = T | Signal<T> | ComputedCallback<T>\n\ntype SignalValues<S extends Signal<{}>[]> = {\n\t[K in keyof S]: S[K] extends Signal<infer T> ? T : never\n}\n\n/* === Constants === */\n\nconst UNSET: any = Symbol()\n\n/* === Functions === */\n\n/**\n * Check whether a value is a Signal or not\n *\n * @since 0.9.0\n * @param {unknown} value - value to check\n * @returns {boolean} - true if value is a Signal, false otherwise\n */\nconst isSignal = /*#__PURE__*/ <T extends {}>(\n\tvalue: unknown,\n): value is Signal<T> => isState(value) || isComputed(value)\n\n/**\n * Convert a value to a Signal if it's not already a Signal\n *\n * @since 0.9.6\n * @param {MaybeSignal<T>} value - value to convert to a Signal\n * @returns {Signal<T>} - converted Signal\n */\nconst toSignal = /*#__PURE__*/ <T extends {}>(\n\tvalue: MaybeSignal<T>,\n): Signal<T> =>\n\tisSignal<T>(value)\n\t\t? value\n\t\t: isComputedCallback<T>(value)\n\t\t\t? computed(value)\n\t\t\t: state(value as T)\n\n/* === Exports === */\n\nexport {\n\ttype Signal,\n\ttype MaybeSignal,\n\ttype SignalValues,\n\tUNSET,\n\tisSignal,\n\tisComputedCallback,\n\ttoSignal,\n}\n",
    "import { type Signal, type SignalValues, UNSET } from './signal'\nimport { CircularDependencyError, isFunction, toError } from './util'\nimport { type Cleanup, watch, observe } from './scheduler'\n\n/* === Types === */\n\ntype EffectMatcher<S extends Signal<{}>[]> = {\n\tsignals: S\n\tok: (...values: SignalValues<S>) => void | Cleanup\n\terr?: (...errors: Error[]) => void | Cleanup\n\tnil?: () => void | Cleanup\n}\n\n/* === Functions === */\n\n/**\n * Define what happens when a reactive state changes\n *\n * @since 0.1.0\n * @param {EffectMatcher<S> | (() => void | Cleanup)} matcher - effect matcher or callback\n * @returns {Cleanup} - cleanup function for the effect\n */\nfunction effect<S extends Signal<{}>[]>(\n\tmatcher: EffectMatcher<S> | (() => void | Cleanup),\n): Cleanup {\n\tconst {\n\t\tsignals,\n\t\tok,\n\t\terr = console.error,\n\t\tnil = () => {},\n\t} = isFunction(matcher)\n\t\t? { signals: [] as unknown as S, ok: matcher }\n\t\t: matcher\n\n\tlet running = false\n\tconst run = watch(() =>\n\t\tobserve(() => {\n\t\t\tif (running) throw new CircularDependencyError('effect')\n\t\t\trunning = true\n\n\t\t\t// Pure part\n\t\t\tconst errors: Error[] = []\n\t\t\tlet pending = false\n\t\t\tconst values = signals.map(signal => {\n\t\t\t\ttry {\n\t\t\t\t\tconst value = signal.get()\n\t\t\t\t\tif (value === UNSET) pending = true\n\t\t\t\t\treturn value\n\t\t\t\t} catch (e) {\n\t\t\t\t\terrors.push(toError(e))\n\t\t\t\t\treturn UNSET\n\t\t\t\t}\n\t\t\t}) as SignalValues<S>\n\n\t\t\t// Effectful part\n\t\t\tlet cleanup: void | Cleanup = undefined\n\t\t\ttry {\n\t\t\t\tcleanup = pending\n\t\t\t\t\t? nil()\n\t\t\t\t\t: errors.length\n\t\t\t\t\t\t? err(...errors)\n\t\t\t\t\t\t: ok(...values)\n\t\t\t} catch (e) {\n\t\t\t\tcleanup = err(toError(e))\n\t\t\t} finally {\n\t\t\t\tif (isFunction(cleanup)) run.off(cleanup)\n\t\t\t}\n\n\t\t\trunning = false\n\t\t}, run),\n\t)\n\trun()\n\treturn () => run.cleanup()\n}\n\n/* === Exports === */\n\nexport { type EffectMatcher, effect }\n",
    "/* === Types === */\n\nimport { isFunction } from '@zeix/cause-effect'\n\ntype LogLevel = 'debug' | 'info' | 'warn' | 'error'\n\n/* === Constants === */\n\nconst DEV_MODE = process.env.DEV_MODE\n\nconst LOG_DEBUG: LogLevel = 'debug'\nconst LOG_INFO: LogLevel = 'info'\nconst LOG_WARN: LogLevel = 'warn'\nconst LOG_ERROR: LogLevel = 'error'\n\n/* === Internal Functions === */\n\n/**\n * Return selector string for the id of the element\n *\n * @since 0.7.0\n * @param {string | undefined | null} id\n * @returns {string} - id string for the element with '#' prefix\n */\nconst idString = (id: string | undefined | null): string => (id ? `#${id}` : '')\n\n/**\n * Return a selector string for classes of the element\n *\n * @since 0.7.0\n * @param {DOMTokenList | undefined | null} classList - DOMTokenList to convert to a string\n * @returns {string} - class string for the DOMTokenList with '.' prefix if any\n */\nconst classString = (classList: DOMTokenList | undefined | null): string =>\n\tclassList?.length ? `.${Array.from(classList).join('.')}` : ''\n\n/* === Exported Functions === */\n\nconst isDefinedObject = /*#__PURE__*/ (\n\tvalue: unknown,\n): value is Record<string, unknown> => !!value && typeof value === 'object'\n\nconst isString = /*#__PURE__*/ (value: unknown): value is string =>\n\ttypeof value === 'string'\n\nconst hasMethod = /*#__PURE__*/ <T extends object, K extends PropertyKey, R>(\n\tobj: T,\n\tmethodName: K,\n): obj is T & Record<K, (...args: any[]) => R> =>\n\tisString(methodName) &&\n\tmethodName in obj &&\n\tisFunction<R>((obj as any)[methodName])\n\n/**\n * Check if a node is an Element\n *\n * @param {Node} node - node to check\n * @returns {boolean} - `true` if node is an element node, otherwise `false`\n */\nconst isElement = /*#__PURE__*/ (node: Node): node is Element =>\n\tnode.nodeType === Node.ELEMENT_NODE\n\n/**\n * Check whether an element is a custom element\n *\n * @param {E} element - Element to check\n * @returns {boolean} - True if the element is a custom element\n */\nconst isCustomElement = /*#__PURE__*/ <E extends Element>(\n\telement: E,\n): boolean => element.localName.includes('-')\n\n/**\n * Check whether a custom element is upgraded or a regular element\n *\n * @param {E} element - Element to check\n * @returns {boolean} - True if the element is an upgraded custom element or a regular element\n */\nconst isUpgradedComponent = <E extends Element>(element: E): boolean => {\n\tif (!isCustomElement(element)) return true\n\tconst ctor = customElements.get(element.localName)\n\treturn !!ctor && element instanceof ctor\n}\n\n/**\n * Return a string representation of the Element instance\n *\n * @since 0.7.0\n * @param {Element | undefined | null} el\n * @returns {string}\n */\nconst elementName = /*#__PURE__*/ (el: Element | undefined | null): string =>\n\tel\n\t\t? `<${el.localName}${idString(el.id)}${classString(el.classList)}>`\n\t\t: '<unknown>'\n\n/**\n * Return a string representation of a JavaScript variable\n *\n * @since 0.7.0\n * @param {unknown} value\n * @returns {string}\n */\nconst valueString = /*#__PURE__*/ (value: unknown): string =>\n\tisString(value)\n\t\t? `\"${value}\"`\n\t\t: isDefinedObject(value)\n\t\t\t? JSON.stringify(value)\n\t\t\t: String(value)\n\n/**\n * Return a detailed type of a JavaScript variable\n *\n * @since 0.11.0\n * @param {unknown} value\n * @returns {string}\n */\nconst typeString = /*#__PURE__*/ (value: unknown): string => {\n\tif (value === null) return 'null'\n\tif (typeof value !== 'object') return typeof value\n\tif (Array.isArray(value)) return 'Array'\n\n\t// Check for Symbol.toStringTag\n\tif (Symbol.toStringTag in Object(value)) {\n\t\treturn (value as any)[Symbol.toStringTag]\n\t}\n\n\t// For other objects, return the constructor name if available\n\treturn value.constructor?.name || 'Object'\n}\n\n/**\n * Log a message to the console with the specified level\n *\n * @since 0.7.0\n * @param {T} value - value to inspect\n * @param {string} msg - message to log\n * @param {LogLevel} level - log level\n * @returns {T} - value passed through\n */\nconst log = <T>(value: T, msg: string, level: LogLevel = LOG_DEBUG): T => {\n\tif (DEV_MODE || ([LOG_ERROR, LOG_WARN] as LogLevel[]).includes(level))\n\t\tconsole[level](msg, value)\n\treturn value\n}\n\nexport {\n\ttype LogLevel,\n\thasMethod,\n\tisString,\n\tisDefinedObject,\n\tisElement,\n\tisCustomElement,\n\tisUpgradedComponent,\n\tlog,\n\telementName,\n\tvalueString,\n\ttypeString,\n\tDEV_MODE,\n\tLOG_DEBUG,\n\tLOG_INFO,\n\tLOG_WARN,\n\tLOG_ERROR,\n}\n",
    "import {\n\ttype Computed,\n\tTYPE_COMPUTED,\n\tUNSET,\n\ttype Watcher,\n\tcomputed,\n\tisFunction,\n\tnotify,\n\tsubscribe,\n} from '@zeix/cause-effect'\n\nimport {\n\telementName,\n\tisCustomElement,\n\tisString,\n\tisUpgradedComponent,\n} from './util'\n\n/* === Types === */\n\ntype ElementFromSelector<\n\tK extends string,\n\tE extends Element = HTMLElement,\n> = K extends keyof HTMLElementTagNameMap\n\t? HTMLElementTagNameMap[K]\n\t: K extends keyof SVGElementTagNameMap\n\t\t? SVGElementTagNameMap[K]\n\t\t: K extends keyof MathMLElementTagNameMap\n\t\t\t? MathMLElementTagNameMap[K]\n\t\t\t: E\n\ntype Extractor<T extends {}, E extends Element = HTMLElement> = (\n\telement: E,\n) => T\n\ntype LooseExtractor<T, E extends Element = HTMLElement> = (\n\telement: E,\n) => T | null | undefined\n\ntype Parser<T extends {}, E extends Element = HTMLElement> = (\n\telement: E,\n\tvalue: string | null | undefined,\n\told?: string | null,\n) => T\n\ntype Fallback<T extends {}, E extends Element = HTMLElement> =\n\t| T\n\t| Extractor<T, E>\n\ntype ParserOrFallback<T extends {}, E extends Element = HTMLElement> =\n\t| Parser<T, E>\n\t| Fallback<T, E>\n\n/* === Error Class === */\n\n/**\n * Error thrown when a circular dependency is detected in a selection signal\n */\nclass CircularMutationError extends Error {\n\tconstructor(message: string) {\n\t\tsuper(message)\n\t\tthis.name = 'CircularMutationError'\n\t}\n}\n\n/* === Internal === */\n\n/**\n * Extract attribute names from a CSS selector\n * Handles various attribute selector formats: .class, #id, [attr], [attr=value], [attr^=value], etc.\n *\n * @param {string} selector - CSS selector to parse\n * @returns {string[]} - Array of attribute names found in the selector\n */\nconst extractAttributes = (selector: string): string[] => {\n\tconst attributes = new Set<string>()\n\tif (selector.includes('.')) attributes.add('class')\n\tif (selector.includes('#')) attributes.add('id')\n\tif (selector.includes('[')) {\n\t\tconst parts = selector.split('[')\n\t\tfor (let i = 1; i < parts.length; i++) {\n\t\t\tconst part = parts[i]\n\t\t\tif (!part.includes(']')) continue\n\t\t\tconst attrName = part\n\t\t\t\t.split('=')[0]\n\t\t\t\t.trim()\n\t\t\t\t.replace(/[^a-zA-Z0-9_-]/g, '')\n\t\t\tif (attrName) attributes.add(attrName)\n\t\t}\n\t}\n\treturn [...attributes]\n}\n\n/**\n * Compare two arrays of elements to determine if they contain the same elements\n *\n * @param {E[]} arr1 - First array of elements to compare\n * @param {E[]} arr2 - Second array of elements to compare\n * @returns {boolean} - True if arrays contain the same elements, false otherwise\n */\nconst areElementArraysEqual = <E extends Element>(\n\tarr1: E[],\n\tarr2: E[],\n): boolean => {\n\tif (arr1.length !== arr2.length) return false\n\tconst set1 = new Set(arr1)\n\tfor (const el of arr2) {\n\t\tif (!set1.has(el)) return false\n\t}\n\treturn true\n}\n\n/* === Exported Functions === */\n\n/**\n * Check if a value is a string parser\n *\n * @since 0.13.4\n * @param {unknown} value - Value to check if it is a string parser\n * @returns {boolean} True if the value is a string parser, false otherwise\n */\nconst isParser = <T extends {}, E extends Element = HTMLElement>(\n\tvalue: unknown,\n): value is Parser<T, E> => isFunction(value) && value.length >= 2\n\n/**\n * Get a fallback value for an element\n *\n * @since 0.13.4\n * @param {E} element - Element to get fallback value for\n * @param {ParserOrFallback<T, E>} fallback - Fallback value or parser function\n * @returns {T} Fallback value or parsed value\n */\nconst getFallback = <T extends {}, E extends Element = HTMLElement>(\n\telement: E,\n\tfallback: ParserOrFallback<T, E>,\n): T => (isFunction(fallback) ? fallback(element) : fallback) as T\n\n/**\n * Get a value from the first element matching a selector\n *\n * @since 0.13.4\n * @param {string} selector - Selector to match\n * @param {LooseExtractor<T | string | null | undefined, ElementFromSelector<S, E>>[]} extractors - Extractor functions to apply to the element\n * @returns {LooseExtractor<T | string | null | undefined, C>} Loose extractor function to apply to the host element\n */\nconst fromFirst =\n\t<\n\t\tT,\n\t\tE extends Element = HTMLElement,\n\t\tC extends HTMLElement = HTMLElement,\n\t\tS extends string = string,\n\t>(\n\t\tselector: S,\n\t\t...extractors: LooseExtractor<T | string, ElementFromSelector<S, E>>[]\n\t): LooseExtractor<T | string, C> =>\n\t(host: C) => {\n\t\tconst target = host.querySelector<ElementFromSelector<S, E>>(selector)\n\t\tif (!target) return\n\t\tfor (const extractor of extractors) {\n\t\t\tconst value = extractor(target)\n\t\t\tif (value !== undefined) return value\n\t\t}\n\t}\n\nconst fromDOM =\n\t<\n\t\tT extends {},\n\t\tE extends Element = HTMLElement,\n\t\tC extends HTMLElement = HTMLElement,\n\t\tS extends {\n\t\t\t[K in keyof S & string]: LooseExtractor<\n\t\t\t\tT | string,\n\t\t\t\tElementFromSelector<K, E>\n\t\t\t>\n\t\t} = {},\n\t>(\n\t\tfallback: ParserOrFallback<T, C>,\n\t\tselectors: S,\n\t): Extractor<T, C> =>\n\t(host: C): T => {\n\t\tconst fromFirst = <K extends keyof S & string>(\n\t\t\tselector: K,\n\t\t\textractor: LooseExtractor<T | string, ElementFromSelector<K, E>>,\n\t\t) => {\n\t\t\tconst target =\n\t\t\t\thost.querySelector<ElementFromSelector<K, E>>(selector)\n\t\t\tif (!target) return\n\t\t\t// for (const extractor of extractors) {\n\t\t\tconst value = extractor(target)\n\t\t\tif (value != null) return value\n\t\t\t// }\n\t\t}\n\n\t\tlet value: T | string | null | undefined = undefined\n\t\tfor (const [selector, extractor] of Object.entries(selectors)) {\n\t\t\tvalue = fromFirst(\n\t\t\t\tselector as keyof S & string,\n\t\t\t\textractor as LooseExtractor<\n\t\t\t\t\tT,\n\t\t\t\t\tElementFromSelector<keyof S & string, E>\n\t\t\t\t>,\n\t\t\t)\n\t\t\tif (value != null) break\n\t\t}\n\t\treturn isString(value) && isParser<T, C>(fallback)\n\t\t\t? fallback(host, value)\n\t\t\t: ((value as T) ?? getFallback(host, fallback))\n\t}\n\n/**\n * Observe a DOM subtree with a mutation observer\n *\n * @since 0.12.2\n * @param {ParentNode} parent - parent node\n * @param {string} selector - selector for matching elements to observe\n * @param {MutationCallback} callback - mutation callback\n * @returns {MutationObserver} - the created mutation observer\n */\nconst observeSubtree = (\n\tparent: ParentNode,\n\tselector: string,\n\tcallback: MutationCallback,\n): MutationObserver => {\n\tconst observer = new MutationObserver(callback)\n\tconst observerConfig: MutationObserverInit = {\n\t\tchildList: true,\n\t\tsubtree: true,\n\t}\n\tconst observedAttributes = extractAttributes(selector)\n\tif (observedAttributes.length) {\n\t\tobserverConfig.attributes = true\n\t\tobserverConfig.attributeFilter = observedAttributes\n\t}\n\tobserver.observe(parent, observerConfig)\n\treturn observer\n}\n\n/**\n * Produce a computed signal of an array of elements matching a selector\n *\n * @since 0.13.1\n * @param {K} selector - CSS selector for descendant elements\n * @returns {Extractor<Computed<ElementFromSelector<S, E>[]>, C>} Signal producer for descendant element collection from a selector\n */\nconst fromSelector =\n\t<\n\t\tE extends Element = HTMLElement,\n\t\tC extends HTMLElement = HTMLElement,\n\t\tS extends string = string,\n\t>(\n\t\tselector: S,\n\t): Extractor<Computed<ElementFromSelector<S, E>[]>, C> =>\n\t(host: C): Computed<ElementFromSelector<S, E>[]> => {\n\t\tconst watchers: Set<Watcher> = new Set()\n\t\tconst select = () =>\n\t\t\tArray.from(\n\t\t\t\thost.querySelectorAll<ElementFromSelector<S, E>>(selector),\n\t\t\t)\n\t\tlet value: ElementFromSelector<S, E>[] = UNSET\n\t\tlet observer: MutationObserver | undefined\n\t\tlet mutationDepth = 0\n\t\tconst MAX_MUTATION_DEPTH = 2 // Consider a depth > 1 as circular\n\n\t\tconst observe = () => {\n\t\t\tvalue = select()\n\t\t\tobserver = observeSubtree(host, selector, () => {\n\t\t\t\t// If we have no watchers, just disconnect\n\t\t\t\tif (!watchers.size) {\n\t\t\t\t\tobserver?.disconnect()\n\t\t\t\t\tobserver = undefined\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tmutationDepth++\n\t\t\t\tif (mutationDepth > MAX_MUTATION_DEPTH) {\n\t\t\t\t\tobserver?.disconnect()\n\t\t\t\t\tobserver = undefined\n\t\t\t\t\tmutationDepth = 0\n\t\t\t\t\tthrow new CircularMutationError(\n\t\t\t\t\t\t'Circular mutation in element selection detected',\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tconst newElements = select()\n\t\t\t\t\tif (!areElementArraysEqual(value, newElements)) {\n\t\t\t\t\t\tvalue = newElements\n\t\t\t\t\t\tnotify(watchers)\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tmutationDepth--\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\treturn {\n\t\t\t[Symbol.toStringTag]: TYPE_COMPUTED,\n\n\t\t\tget(): ElementFromSelector<S, E>[] {\n\t\t\t\tsubscribe(watchers)\n\t\t\t\tif (!watchers.size) value = select()\n\t\t\t\telse if (!observer) observe()\n\t\t\t\treturn value\n\t\t\t},\n\t\t}\n\t}\n\n/**\n * Reduced properties of descendant elements\n *\n * @since 0.13.3\n * @param {C} host - Host element for computed property\n * @param {S} selector - CSS selector for descendant elements\n * @param {(accumulator: T, currentElement: ElementFromSelector<S, E>, currentIndex: number, array: ElementFromSelector<S, E>[]) => T} reducer - Function to reduce values\n * @param {T} initialValue - Initial value function for reduction\n * @returns {Computed<T>} Computed signal of reduced values of descendant elements\n */\nconst reduced = <\n\tT extends {},\n\tE extends Element = HTMLElement,\n\tC extends HTMLElement = HTMLElement,\n\tS extends string = string,\n>(\n\thost: C,\n\tselector: S,\n\treducer: (\n\t\taccumulator: T,\n\t\tcurrentElement: ElementFromSelector<S, E>,\n\t\tcurrentIndex: number,\n\t\tarray: ElementFromSelector<S, E>[],\n\t) => T,\n\tinitialValue: T,\n): Computed<T> =>\n\tcomputed(() =>\n\t\t(\n\t\t\tfromSelector<ElementFromSelector<S, E>>(selector)(host) as Computed<\n\t\t\t\tElementFromSelector<S, E>[]\n\t\t\t>\n\t\t)\n\t\t\t.get()\n\t\t\t.reduce(reducer, initialValue),\n\t)\n\n/**\n * Read from a descendant element and map the result\n *\n * @since 0.13.3\n * @param {C} host - Host element\n * @param {S} selector - CSS selector for descendant element\n * @param {(element: ElementFromSelector<S, E> | null, isUpgraded: boolean) => T} map - Function to map over the element\n * @returns {T} The mapped result from the descendant element\n */\nconst read = <\n\tT extends {},\n\tE extends Element = HTMLElement,\n\tC extends HTMLElement = HTMLElement,\n\tS extends string = string,\n>(\n\thost: C,\n\tselector: S,\n\tmap: (element: ElementFromSelector<S, E> | null, isUpgraded: boolean) => T,\n): T => {\n\tconst source = host.querySelector<ElementFromSelector<S, E>>(selector)\n\treturn map(source, source ? isUpgradedComponent(source) : false)\n}\n\n/**\n * Assert that an element contains an expected descendant element\n *\n * @since 0.13.4\n * @param {HTMLElement} host - Host element\n * @param {S} selector - Selector for element to check for\n * @returns {ElementFromSelector<S, E>} First found descendant element\n * @throws {Error} If the element does not contain the required descendant element\n */\nconst requireElement = <\n\tS extends string = string,\n\tE extends Element = HTMLElement,\n>(\n\thost: HTMLElement,\n\tselector: S,\n\tassertCustomElement = false,\n): ElementFromSelector<S, E> => {\n\tconst target = host.querySelector<ElementFromSelector<S, E>>(selector)\n\tif (target) {\n\t\tif (assertCustomElement && !isCustomElement(target))\n\t\t\tthrow new Error(`Element ${selector} is not a custom element`)\n\t\treturn target\n\t}\n\tthrow new Error(\n\t\t`Component ${elementName(host)} does not contain required <${selector}> element`,\n\t)\n}\n\nconst fromComponent =\n\t<\n\t\tT extends {},\n\t\tE extends Element = HTMLElement,\n\t\tC extends HTMLElement = HTMLElement,\n\t\tS extends string = string,\n\t>(\n\t\tselector: S,\n\t\textractor: Extractor<T, ElementFromSelector<S, E>>,\n\t\tfallback: Fallback<T>,\n\t): Extractor<Computed<T>, C> =>\n\t(host: C): Computed<T> => {\n\t\tconst target = requireElement<S, E>(host, selector, true)\n\t\treturn computed(async () => {\n\t\t\tawait customElements.whenDefined(target.localName)\n\t\t\treturn extractor(target) ?? getFallback(host, fallback)\n\t\t})\n\t}\n\nexport {\n\ttype ElementFromSelector,\n\ttype Extractor,\n\ttype Fallback,\n\ttype LooseExtractor,\n\ttype Parser,\n\ttype ParserOrFallback,\n\tfromComponent,\n\tfromDOM,\n\tfromFirst,\n\tfromSelector,\n\tgetFallback,\n\tisParser,\n\treduced,\n\tread,\n\tobserveSubtree,\n\trequireElement,\n}\n",
    "import {\n\ttype Cleanup,\n\ttype MaybeSignal,\n\ttype Signal,\n\tUNSET,\n\tisComputed,\n\tisFunction,\n\tisSignal,\n\tisState,\n\ttoSignal,\n} from '@zeix/cause-effect'\n\nimport {\n\ttype ElementFromSelector,\n\ttype Extractor,\n\ttype Parser,\n\tisParser,\n\tobserveSubtree,\n} from './core/dom'\nimport type { Effect } from './core/reactive'\nimport {\n\tDEV_MODE,\n\telementName,\n\tisElement,\n\tlog,\n\ttypeString,\n\tvalueString,\n} from './core/util'\n\n/* === Types === */\n\ntype ReservedWords =\n\t| 'constructor'\n\t| 'prototype'\n\t| '__proto__'\n\t| 'toString'\n\t| 'valueOf'\n\t| 'hasOwnProperty'\n\t| 'isPrototypeOf'\n\t| 'propertyIsEnumerable'\n\t| 'toLocaleString'\n\ntype ValidPropertyKey<T> = T extends keyof HTMLElement | ReservedWords\n\t? never\n\t: T\n\ntype ValidateComponentProps<P> = {\n\t[K in keyof P]: ValidPropertyKey<K> extends never ? never : P[K]\n}\n\ntype ComponentProps = { [K in string as ValidPropertyKey<K>]: {} }\n\ntype Component<P extends ComponentProps> = HTMLElement &\n\tP & {\n\t\t// Common Web Component lifecycle hooks\n\t\tattributeChangedCallback<K extends keyof P & string>(\n\t\t\tname: K,\n\t\t\toldValue: string | null,\n\t\t\tnewValue: string | null,\n\t\t): void\n\n\t\t// Custom element properties\n\t\tdebug?: boolean\n\n\t\t// Component-specific signal methods\n\t\tgetSignal<K extends keyof P & string>(prop: K): Signal<P[K]>\n\t\tsetSignal<K extends keyof P & string>(\n\t\t\tprop: K,\n\t\t\tsignal: Signal<P[K]>,\n\t\t): void\n\t}\n\ntype SignalProducer<\n\tT extends {},\n\tC extends HTMLElement = HTMLElement,\n> = Extractor<MaybeSignal<T>, C>\n\ntype MethodProducer<C extends HTMLElement> = (host: C) => void\n\ntype Initializer<T extends {}, C extends HTMLElement> =\n\t| T\n\t| Parser<T, C>\n\t| SignalProducer<T, C>\n\t| MethodProducer<C>\n\ntype SelectorFunctions<P extends ComponentProps> = {\n\tfirst: <E extends Element = never, S extends string = string>(\n\t\tselector: S,\n\t\t...effects: Effect<P, ElementFromSelector<S, E>>[]\n\t) => (host: Component<P>) => Cleanup | void\n\tall: <E extends Element = never, S extends string = string>(\n\t\tselector: S,\n\t\t...effects: Effect<P, ElementFromSelector<S, E>>[]\n\t) => (host: Component<P>) => Cleanup\n}\n\n/* === Constants === */\n\n// Reserved words that should never be used as property names\n// These are fundamental JavaScript/Object properties that cause serious issues\nconst RESERVED_WORDS = new Set([\n\t'constructor',\n\t'prototype',\n\t// Expand this list based on user feedback for other reserved words like:\n\t// '__proto__', 'toString', 'valueOf', 'hasOwnProperty', etc.\n])\n\n// HTMLElement properties that commonly cause conflicts\n// These are properties that exist on HTMLElement and cause confusion when overridden\n// in our reactive components because we use the same name for both attributes and properties\nconst HTML_ELEMENT_PROPS = new Set([\n\t'id', // DOM selector conflicts\n\t'class', // CSS class management conflicts (note: property is 'className')\n\t'className', // CSS class management conflicts (note: HTML attribute is 'class')\n\t'title', // Conflicts with tooltip behavior\n\t'role', // ARIA/accessibility conflicts\n\t'style', // Conflicts with style object\n\t'dataset', // Conflicts with data-* attribute access\n\t'lang', // Language/i18n conflicts\n\t'dir', // Text direction conflicts\n\t'hidden', // Visibility control conflicts\n\t'children', // DOM manipulation conflicts\n\t'innerHTML', // DOM manipulation conflicts\n\t'outerHTML', // Full element HTML conflicts\n\t'textContent', // Text manipulation conflicts\n\t'innerText', // Text manipulation conflicts\n\t// TO EXPAND: Add properties based on user feedback and common mistakes\n\t// 'tabindex', 'tabIndex', 'slot', 'part', etc.\n])\n\n/* === Internal Functions === */\n\n/**\n * Simple fail-fast validation that checks for specific problematic cases\n *\n * This validation prevents common mistakes where developers accidentally\n * use property names that conflict with native HTMLElement functionality.\n */\nconst validatePropertyName = (prop: string): string | null => {\n\tif (RESERVED_WORDS.has(prop))\n\t\treturn `Property name \"${prop}\" is a reserved word`\n\tif (HTML_ELEMENT_PROPS.has(prop))\n\t\treturn `Property name \"${prop}\" conflicts with inherited HTMLElement property`\n\treturn null\n}\n\n/**\n * Run one or more functions on a component's element\n *\n * @since 0.12.0\n * @param {Effect<P, E>[]} effects - Effect functions to run\n * @param {Component<P>} host - Component host element\n * @param {E} target - Target element\n * @returns {Cleanup} - Cleanup function that runs collected cleanup functions\n */\nconst runEffects = <P extends ComponentProps, E extends Element = Component<P>>(\n\teffects: Effect<P, E>[],\n\thost: Component<P>,\n\ttarget: E = host as unknown as E,\n): Cleanup => {\n\tconst cleanups = effects\n\t\t.filter(isFunction)\n\t\t.map(effect => effect(host, target))\n\treturn () => {\n\t\tcleanups.filter(isFunction).forEach(cleanup => cleanup())\n\t\tcleanups.length = 0\n\t}\n}\n\n/**\n * Create partially applied helper functions to select sub-elements\n *\n * @since 0.13.0\n * @returns {SelectorFunctions<P>} - Helper functions for selecting sub-elements\n */\nconst select = <P extends ComponentProps>(): SelectorFunctions<P> => ({\n\t/**\n\t * Apply effect functions to a first matching sub-element within the custom element\n\t *\n\t * @since 0.12.0\n\t * @param {S} selector - Selector to match sub-element\n\t */\n\tfirst:\n\t\t<E extends Element = never, S extends string = string>(\n\t\t\tselector: S,\n\t\t\t...effects: Effect<P, ElementFromSelector<S, E>>[]\n\t\t) =>\n\t\t(host: Component<P>): Cleanup | void => {\n\t\t\tconst el = (host.shadowRoot || host).querySelector<\n\t\t\t\tElementFromSelector<S, E>\n\t\t\t>(selector)\n\t\t\tif (el) runEffects(effects, host, el)\n\t\t},\n\n\t/**\n\t * Apply effect functions to all matching descendant elements within the custom element\n\t *\n\t * @since 0.12.0\n\t * @param {S} selector - Selector to match descendants\n\t */\n\tall:\n\t\t<E extends Element = never, S extends string = string>(\n\t\t\tselector: S,\n\t\t\t...effects: Effect<P, ElementFromSelector<S, E>>[]\n\t\t) =>\n\t\t(host: Component<P>): Cleanup => {\n\t\t\tconst cleanups = new Map<ElementFromSelector<S, E>, Cleanup>()\n\t\t\tconst root = host.shadowRoot || host\n\n\t\t\tconst attach = (target: ElementFromSelector<S, E>) => {\n\t\t\t\tif (!cleanups.has(target))\n\t\t\t\t\tcleanups.set(target, runEffects(effects, host, target))\n\t\t\t}\n\n\t\t\tconst detach = (target: ElementFromSelector<S, E>) => {\n\t\t\t\tconst cleanup = cleanups.get(target)\n\t\t\t\tif (isFunction(cleanup)) cleanup()\n\t\t\t\tcleanups.delete(target)\n\t\t\t}\n\n\t\t\tconst applyToMatching =\n\t\t\t\t(fn: (target: ElementFromSelector<S, E>) => void) =>\n\t\t\t\t(node: Node) => {\n\t\t\t\t\tif (isElement(node)) {\n\t\t\t\t\t\tif (node.matches(selector))\n\t\t\t\t\t\t\tfn(node as ElementFromSelector<S, E>)\n\t\t\t\t\t\tnode.querySelectorAll<ElementFromSelector<S, E>>(\n\t\t\t\t\t\t\tselector,\n\t\t\t\t\t\t).forEach(fn)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tconst observer = observeSubtree(root, selector, mutations => {\n\t\t\t\tfor (const mutation of mutations) {\n\t\t\t\t\tmutation.addedNodes.forEach(applyToMatching(attach))\n\t\t\t\t\tmutation.removedNodes.forEach(applyToMatching(detach))\n\t\t\t\t}\n\t\t\t})\n\n\t\t\troot.querySelectorAll<ElementFromSelector<S, E>>(selector).forEach(\n\t\t\t\tattach,\n\t\t\t)\n\n\t\t\treturn () => {\n\t\t\t\tobserver.disconnect()\n\t\t\t\tcleanups.forEach(cleanup => cleanup())\n\t\t\t\tcleanups.clear()\n\t\t\t}\n\t\t},\n})\n\n/* === Exported Functions === */\n\n/**\n * Define a component with its states and setup function (connectedCallback)\n *\n * @since 0.12.0\n * @param {string} name - Name of the custom element\n * @param {{ [K in keyof P]: Initializer<P[K], Component<P>> }} init - Signals of the component\n * @param {FxFunction<S>[]} setup - Setup function to be called in connectedCallback(), may return cleanup function to be called in disconnectedCallback()\n * @returns: void\n */\nconst component = <P extends ComponentProps & ValidateComponentProps<P>>(\n\tname: string,\n\tinit: {\n\t\t[K in keyof P]: Initializer<P[K], Component<P>>\n\t} = {} as {\n\t\t[K in keyof P]: Initializer<P[K], Component<P>>\n\t},\n\tsetup: (\n\t\thost: Component<P>,\n\t\tselect: SelectorFunctions<P>,\n\t) => Effect<P, Component<P>>[],\n): void => {\n\tfor (const prop of Object.keys(init)) {\n\t\tconst error = validatePropertyName(prop)\n\t\tif (error) throw new TypeError(`${error} in component \"${name}\".`)\n\t}\n\n\tclass CustomElement extends HTMLElement {\n\t\tdebug?: boolean\n\t\t#signals: {\n\t\t\t[K in keyof P & string]: Signal<P[K]>\n\t\t} = {} as {\n\t\t\t[K in keyof P & string]: Signal<P[K]>\n\t\t}\n\t\t#cleanup: Cleanup | undefined\n\n\t\tstatic observedAttributes =\n\t\t\tObject.entries(init)\n\t\t\t\t?.filter(([, initializer]) => isParser(initializer))\n\t\t\t\t.map(([prop]) => prop) ?? []\n\n\t\t/**\n\t\t * Native callback function when the custom element is first connected to the document\n\t\t */\n\t\tconnectedCallback() {\n\t\t\tif (DEV_MODE) {\n\t\t\t\tthis.debug = this.hasAttribute('debug')\n\t\t\t\tif (this.debug) log(this, 'Connected')\n\t\t\t}\n\n\t\t\t// Initialize signals\n\t\t\tfor (const [prop, initializer] of Object.entries(init)) {\n\t\t\t\tif (initializer == null || prop in this) continue\n\t\t\t\tconst result = isFunction(initializer)\n\t\t\t\t\t? initializer(this, null)\n\t\t\t\t\t: initializer\n\t\t\t\tif (result != null) this.setSignal(prop, toSignal(result))\n\t\t\t}\n\n\t\t\t// Run setup function\n\t\t\tconst effects = setup(this as unknown as Component<P>, select())\n\t\t\tif (!Array.isArray(effects))\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Expected array of functions as return value of setup function in ${elementName(this)}`,\n\t\t\t\t)\n\t\t\tthis.#cleanup = runEffects(effects, this as unknown as Component<P>)\n\t\t}\n\n\t\t/**\n\t\t * Native callback function when the custom element is disconnected from the document\n\t\t */\n\t\tdisconnectedCallback() {\n\t\t\tif (isFunction(this.#cleanup)) this.#cleanup()\n\t\t\tif (DEV_MODE && this.debug) log(this, 'Disconnected')\n\t\t}\n\n\t\t/**\n\t\t * Native callback function when an observed attribute of the custom element changes\n\t\t *\n\t\t * @param {K} attr - Name of the modified attribute\n\t\t * @param {string | null} old - Old value of the modified attribute\n\t\t * @param {string | null} value - New value of the modified attribute\n\t\t */\n\t\tattributeChangedCallback<K extends keyof P & string>(\n\t\t\tattr: K,\n\t\t\told: string | null,\n\t\t\tvalue: string | null,\n\t\t) {\n\t\t\tif (value === old || isComputed(this.#signals[attr])) return // unchanged or controlled by computed\n\t\t\tconst parser = init[attr]\n\t\t\tif (!isParser<P[K]>(parser)) return\n\t\t\tconst parsed = parser(this, value, old)\n\t\t\tif (DEV_MODE && this.debug)\n\t\t\t\tlog(\n\t\t\t\t\tvalue,\n\t\t\t\t\t`Attribute \"${String(attr)}\" of ${elementName(this)} changed from ${valueString(old)} to ${valueString(value)}, parsed as <${typeString(parsed)}> ${valueString(parsed)}`,\n\t\t\t\t)\n\t\t\tif (attr in this) (this as unknown as P)[attr] = parsed\n\t\t\telse this.setSignal(attr, toSignal(parsed))\n\t\t}\n\n\t\t/**\n\t\t * Get the the signal for a given key\n\t\t *\n\t\t * @since 0.12.0\n\t\t * @param {K} key - Key to get signal for\n\t\t * @returns {P[K]} Current value of signal; undefined if state does not exist\n\t\t */\n\t\tgetSignal<K extends keyof P & string>(key: K): Signal<P[K]> {\n\t\t\tconst signal = this.#signals[key]\n\t\t\tif (DEV_MODE && this.debug)\n\t\t\t\tlog(\n\t\t\t\t\tsignal,\n\t\t\t\t\t`Get ${typeString(signal)} \"${String(key)}\" in ${elementName(this)}`,\n\t\t\t\t)\n\t\t\treturn signal\n\t\t}\n\n\t\t/**\n\t\t * Set the signal for a given key\n\t\t *\n\t\t * @since 0.12.0\n\t\t * @param {K} key - Key to set signal for\n\t\t * @param {Signal<P[keyof P]>} signal - Signal to set value to\n\t\t * @throws {TypeError} If key is not a valid property key\n\t\t * @throws {TypeError} If signal is not a valid signal\n\t\t * @returns {void}\n\t\t */\n\t\tsetSignal<K extends keyof P & string>(\n\t\t\tkey: K,\n\t\t\tsignal: Signal<P[K]>,\n\t\t): void {\n\t\t\tconst error = validatePropertyName(String(key))\n\t\t\tif (error) throw new TypeError(`${error} on ${elementName(this)}.`)\n\t\t\tif (!isSignal(signal))\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Expected signal as value for property \"${String(key)}\" on ${elementName(this)}.`,\n\t\t\t\t)\n\t\t\tconst prev = this.#signals[key]\n\t\t\tconst writable = isState(signal)\n\t\t\tthis.#signals[key] = signal\n\t\t\tObject.defineProperty(this, key, {\n\t\t\t\tget: signal.get,\n\t\t\t\tset: writable ? signal.set : undefined,\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: writable,\n\t\t\t})\n\t\t\tif (prev && isState(prev)) prev.set(UNSET)\n\t\t\tif (DEV_MODE && this.debug)\n\t\t\t\tlog(\n\t\t\t\t\tsignal,\n\t\t\t\t\t`Set ${typeString(signal)} \"${String(key)} in ${elementName(this)}`,\n\t\t\t\t)\n\t\t}\n\t}\n\n\tcustomElements.define(name, CustomElement)\n\t// return customElements.get(name) as unknown as Component<P>\n}\n\nexport {\n\ttype Component,\n\ttype ComponentProps,\n\ttype ReservedWords,\n\ttype ValidPropertyKey,\n\ttype ValidateComponentProps,\n\ttype Initializer,\n\ttype SignalProducer,\n\ttype MethodProducer,\n\ttype SelectorFunctions,\n\tcomponent,\n}\n",
    "import {\n\ttype Cleanup,\n\ttype Signal,\n\tisFunction,\n\tisSignal,\n} from '@zeix/cause-effect'\n\nimport type { Component, ComponentProps } from '../component'\nimport type { LooseExtractor } from './dom'\nimport { LOG_ERROR, elementName, isString, log, valueString } from './util'\n\n/* === Types === */\n\ntype Effect<P extends ComponentProps, E extends Element> = (\n\thost: Component<P>,\n\telement: E,\n) => Cleanup | void\n\ntype Reactive<T, P extends ComponentProps, E extends Element = HTMLElement> =\n\t| keyof P\n\t| Signal<NonNullable<T>>\n\t| LooseExtractor<T | null | undefined, E>\n\n/* === Constants === */\n\n// Special value explicitly marked as any so it can be used as signal value of any type\nconst RESET: any = Symbol('RESET')\n\n/* === Exported Functions === */\n\nconst resolveReactive = <\n\tT extends {},\n\tP extends ComponentProps,\n\tE extends Element = Component<P>,\n>(\n\treactive: Reactive<T, P, E>,\n\thost: Component<P>,\n\ttarget: E,\n\tcontext?: string,\n): T => {\n\ttry {\n\t\treturn isString(reactive)\n\t\t\t? (host.getSignal(reactive).get() as unknown as T)\n\t\t\t: isSignal(reactive)\n\t\t\t\t? reactive.get()\n\t\t\t\t: isFunction<T>(reactive)\n\t\t\t\t\t? reactive(target)\n\t\t\t\t\t: RESET\n\t} catch (error) {\n\t\tif (context) {\n\t\t\tlog(\n\t\t\t\terror,\n\t\t\t\t`Failed to resolve value of ${valueString(reactive)}${\n\t\t\t\t\tcontext ? ` for ${context}` : ''\n\t\t\t\t} in ${elementName(target)}${\n\t\t\t\t\t(host as unknown as E) !== target\n\t\t\t\t\t\t? ` in ${elementName(host)}`\n\t\t\t\t\t\t: ''\n\t\t\t\t}`,\n\t\t\t\tLOG_ERROR,\n\t\t\t)\n\t\t}\n\t\treturn RESET\n\t}\n}\n\n/* === Exports === */\n\nexport { type Effect, type Reactive, RESET, resolveReactive }\n",
    "import {\n\ttype Cleanup,\n\ttype Computed,\n\tTYPE_COMPUTED,\n\tUNSET,\n\ttype Watcher,\n\teffect,\n\tisFunction,\n\tnotify,\n\tsubscribe,\n} from '@zeix/cause-effect'\nimport type { ComponentProps } from '../component'\nimport {\n\ttype ElementFromSelector,\n\ttype Extractor,\n\ttype Fallback,\n\tgetFallback,\n} from './dom'\nimport { type Effect, RESET, type Reactive, resolveReactive } from './reactive'\nimport { elementName } from './util'\n\n/* === Types === */\n\ntype EventType<K extends string> = K extends keyof HTMLElementEventMap\n\t? HTMLElementEventMap[K]\n\t: Event\n\ntype EventTransformerContext<\n\tT extends {},\n\tE extends Element,\n\tC extends HTMLElement,\n\tEvt extends Event,\n> = {\n\tevent: Evt\n\thost: C\n\ttarget: E\n\tvalue: T\n}\n\ntype EventTransformer<\n\tT extends {},\n\tE extends Element,\n\tC extends HTMLElement,\n\tEvt extends Event,\n> = (context: EventTransformerContext<T, E, C, Evt>) => T | void\n\ntype EventTransformers<\n\tT extends {},\n\tE extends Element,\n\tC extends HTMLElement,\n> = {\n\t[K in keyof HTMLElementEventMap]?: EventTransformer<T, E, C, EventType<K>>\n}\n\n/* === Exported Functions === */\n\n/**\n * Produce a computed signal from transformed event data\n *\n * @since 0.13.3\n * @param {ValueOrExtractor<T>} initialize - Initial value or extractor function\n * @param {S} selector - CSS selector for the source element\n * @param {EventTransformers<T, ElementFromSelector<S, E>, C>} events - Transformation functions for events\n * @returns {Extractor<Computed<T>, C>} Extractor function for value from event\n */\nconst fromEvents =\n\t<\n\t\tT extends {},\n\t\tE extends Element = HTMLElement,\n\t\tC extends HTMLElement = HTMLElement,\n\t\tS extends string = string,\n\t>(\n\t\tinitialize: Fallback<T, C>,\n\t\tselector: S,\n\t\tevents: EventTransformers<T, ElementFromSelector<S, E>, C>,\n\t): Extractor<Computed<T>, C> =>\n\t(host: C) => {\n\t\tconst watchers: Set<Watcher> = new Set()\n\t\tlet value: T = getFallback(host, initialize)\n\t\tconst eventMap = new Map<string, EventListener>()\n\t\tlet cleanup: Cleanup | undefined\n\n\t\tconst listen = () => {\n\t\t\tfor (const [type, transform] of Object.entries(events)) {\n\t\t\t\tconst listener = ((e: Event) => {\n\t\t\t\t\tconst target = e.target as Element\n\t\t\t\t\tif (!target) return\n\n\t\t\t\t\tconst source = target.closest(\n\t\t\t\t\t\tselector,\n\t\t\t\t\t) as ElementFromSelector<S, E> | null\n\t\t\t\t\tif (!source || !host.contains(source)) return\n\t\t\t\t\te.stopPropagation()\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst newValue = transform({\n\t\t\t\t\t\t\tevent: e as any,\n\t\t\t\t\t\t\thost,\n\t\t\t\t\t\t\ttarget: source,\n\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t})\n\t\t\t\t\t\tif (newValue == null) return\n\t\t\t\t\t\tif (!Object.is(newValue, value)) {\n\t\t\t\t\t\t\tvalue = newValue\n\t\t\t\t\t\t\tif (watchers.size > 0) notify(watchers)\n\t\t\t\t\t\t\telse if (cleanup) cleanup()\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\te.stopImmediatePropagation()\n\t\t\t\t\t\tthrow error\n\t\t\t\t\t}\n\t\t\t\t}) as EventListener\n\t\t\t\teventMap.set(type, listener)\n\t\t\t\thost.addEventListener(type, listener)\n\t\t\t}\n\t\t\tcleanup = () => {\n\t\t\t\tif (eventMap.size) {\n\t\t\t\t\tfor (const [type, listener] of eventMap) {\n\t\t\t\t\t\thost.removeEventListener(type, listener)\n\t\t\t\t\t}\n\t\t\t\t\teventMap.clear()\n\t\t\t\t}\n\t\t\t\tcleanup = undefined\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\t[Symbol.toStringTag]: TYPE_COMPUTED,\n\n\t\t\tget(): T {\n\t\t\t\tsubscribe(watchers)\n\t\t\t\tif (watchers.size && !eventMap.size) listen()\n\t\t\t\treturn value\n\t\t\t},\n\t\t}\n\t}\n\n/**\n * Effect for attaching an event listener to an element.\n * Provides proper cleanup when the effect is disposed.\n *\n * @since 0.12.0\n * @param {string} type - Event type\n * @param {(event: EventType<K>) => void} listener - Event listener function\n * @param {AddEventListenerOptions | boolean} options - Event listener options\n * @returns {Effect<ComponentProps, E>} Effect function that manages the event listener\n */\nconst on =\n\t<K extends keyof HTMLElementEventMap | string, E extends HTMLElement>(\n\t\ttype: K,\n\t\tlistener: (event: EventType<K>) => void,\n\t\toptions: AddEventListenerOptions | boolean = false,\n\t): Effect<ComponentProps, E> =>\n\t(_, target): Cleanup => {\n\t\tif (!isFunction(listener))\n\t\t\tthrow new TypeError(\n\t\t\t\t`Invalid event listener provided for \"${type} event on element ${elementName(target)}`,\n\t\t\t)\n\t\ttarget.addEventListener(type, listener, options)\n\t\treturn () => target.removeEventListener(type, listener)\n\t}\n\n/**\n * Effect for emitting custom events with reactive detail values.\n * Creates and dispatches CustomEvent instances with bubbling enabled by default.\n *\n * @since 0.13.3\n * @param {string} type - Event type to emit\n * @param {Reactive<T, P, E>} reactive - Reactive value bound to the event detail\n * @returns {Effect<P, E>} Effect function that emits custom events\n */\nconst emitEvent =\n\t<T, P extends ComponentProps, E extends Element = HTMLElement>(\n\t\ttype: string,\n\t\treactive: Reactive<T, P, E>,\n\t): Effect<P, E> =>\n\t(host, target): Cleanup =>\n\t\teffect(() => {\n\t\t\tconst value = resolveReactive(\n\t\t\t\treactive,\n\t\t\t\thost,\n\t\t\t\ttarget,\n\t\t\t\t`custom event \"${type}\" detail`,\n\t\t\t)\n\t\t\tif (value === RESET || value === UNSET) return\n\t\t\ttarget.dispatchEvent(\n\t\t\t\tnew CustomEvent(type, {\n\t\t\t\t\tdetail: value,\n\t\t\t\t\tbubbles: true,\n\t\t\t\t}),\n\t\t\t)\n\t\t})\n\n/* === Exports === */\n\nexport {\n\ttype EventType,\n\ttype EventTransformer,\n\ttype EventTransformers,\n\ttype EventTransformerContext,\n\temitEvent,\n\tfromEvents,\n\ton,\n}\n",
    "import {\n\ttype Cleanup,\n\ttype Signal,\n\tisFunction,\n\ttoSignal,\n} from '@zeix/cause-effect'\n\nimport type { Component, ComponentProps } from '../component'\nimport { type Extractor, type Fallback, getFallback } from './dom'\n\n/** @see https://github.com/webcomponents-cg/community-protocols/blob/main/proposals/context.md */\n\n/* === Types === */\n\n/**\n * A context key.\n *\n * A context key can be any type of object, including strings and symbols. The\n *  Context type brands the key type with the `__context__` property that\n * carries the type of the value the context references.\n */\ntype Context<K, V> = K & { __context__: V }\n\n/**\n * An unknown context type\n */\ntype UnknownContext = Context<unknown, unknown>\n\n/**\n * A helper type which can extract a Context value type from a Context type\n */\ntype ContextType<T extends UnknownContext> = T extends Context<infer _, infer V>\n\t? V\n\t: never\n\n/**\n * A callback which is provided by a context requester and is called with the value satisfying the request.\n * This callback can be called multiple times by context providers as the requested value is changed.\n */\ntype ContextCallback<V> = (value: V, unsubscribe?: () => void) => void\n\ndeclare global {\n\tinterface HTMLElementEventMap {\n\t\t/**\n\t\t * A 'context-request' event can be emitted by any element which desires\n\t\t * a context value to be injected by an external provider.\n\t\t */\n\t\t'context-request': ContextRequestEvent<UnknownContext>\n\t}\n}\n\n/* === Constants === */\n\nconst CONTEXT_REQUEST = 'context-request'\n\n/* === Exported class === */\n\n/**\n * Class for context-request events\n *\n * An event fired by a context requester to signal it desires a named context.\n *\n * A provider should inspect the `context` property of the event to determine if it has a value that can\n * satisfy the request, calling the `callback` with the requested value if so.\n *\n * If the requested context event contains a truthy `subscribe` value, then a provider can call the callback\n * multiple times if the value is changed, if this is the case the provider should pass an `unsubscribe`\n * function to the callback which requesters can invoke to indicate they no longer wish to receive these updates.\n *\n * @class ContextRequestEvent\n * @extends {Event}\n *\n * @property {T} context - context key\n * @property {ContextCallback<ContextType<T>>} callback - callback function for value getter and unsubscribe function\n * @property {boolean} [subscribe=false] - whether to subscribe to context changes\n */\nclass ContextRequestEvent<T extends UnknownContext> extends Event {\n\tconstructor(\n\t\tpublic readonly context: T,\n\t\tpublic readonly callback: ContextCallback<ContextType<T>>,\n\t\tpublic readonly subscribe: boolean = false,\n\t) {\n\t\tsuper(CONTEXT_REQUEST, {\n\t\t\tbubbles: true,\n\t\t\tcomposed: true,\n\t\t})\n\t}\n}\n\n/**\n * Provide a context for descendant component consumers\n *\n * @since 0.13.3\n * @param {Context<K, Signal<P[K]>>[]} contexts - Array of contexts to provide\n * @returns {(host: Component<P>) => Cleanup} Function to add an event listener for ContextRequestEvent returning a cleanup function to remove the event listener\n */\nconst provideContexts =\n\t<P extends ComponentProps, K extends keyof P>(\n\t\tcontexts: Context<K, Signal<P[K]>>[],\n\t): ((host: Component<P>) => Cleanup) =>\n\t(host: Component<P>) => {\n\t\tconst listener = (e: ContextRequestEvent<UnknownContext>) => {\n\t\t\tconst { context, callback } = e\n\t\t\tif (\n\t\t\t\tcontexts.includes(context as Context<K, Signal<P[K]>>) &&\n\t\t\t\tisFunction(callback)\n\t\t\t) {\n\t\t\t\te.stopImmediatePropagation()\n\t\t\t\tcallback(host.getSignal(String(context)))\n\t\t\t}\n\t\t}\n\t\thost.addEventListener(CONTEXT_REQUEST, listener)\n\t\treturn () => host.removeEventListener(CONTEXT_REQUEST, listener)\n\t}\n\n/**\n * Consume a context value for a component.\n *\n * @since 0.13.1\n * @param {Context<K, Signal<T>>} context - Context key to consume\n * @param {Fallback<P[K]>} fallback - Fallback value or extractor function\n * @returns {Extractor<Signal<T>, C>} Function that returns the consumed context signal or a signal of the fallback value\n */\nconst fromContext =\n\t<T extends {}, C extends HTMLElement = HTMLElement>(\n\t\tcontext: Context<string, Signal<T>>,\n\t\tfallback: Fallback<T, C>,\n\t): Extractor<Signal<T>, C> =>\n\t(host: C) => {\n\t\tlet consumed: Signal<T> = toSignal(getFallback(host, fallback))\n\t\thost.dispatchEvent(\n\t\t\tnew ContextRequestEvent(context, (value: Signal<T>) => {\n\t\t\t\tconsumed = value\n\t\t\t}),\n\t\t)\n\t\treturn consumed\n\t}\n\nexport {\n\ttype Context,\n\ttype UnknownContext,\n\ttype ContextType,\n\tCONTEXT_REQUEST,\n\tContextRequestEvent,\n\tprovideContexts,\n\tfromContext,\n}\n",
    "import { type Fallback, type Parser, getFallback } from '../core/dom'\n\n/* === Internal Function === */\n\nconst parseNumber = (\n\tparseFn: (v: string) => number,\n\tvalue: string | null | undefined,\n) => {\n\tif (value == null) return\n\tconst parsed = parseFn(value)\n\treturn Number.isFinite(parsed) ? parsed : undefined\n}\n\n/* === Exported Functions === */\n\n/**\n * Parse a boolean attribute as an actual boolean value\n *\n * @since 0.13.1\n * @returns {Parser<boolean>}\n */\nconst asBoolean =\n\t(): Parser<boolean> => (_: HTMLElement, value: string | null | undefined) =>\n\t\tvalue != null && value !== 'false'\n\n/**\n * Parse a string as a number forced to integer with a fallback\n *\n * Supports hexadecimal and scientific notation\n *\n * @since 0.11.0\n * @param {Fallback<number, E>} [fallback=0] - Fallback value or extractor function\n * @returns {Parser<number, E>} Parser function\n */\nconst asInteger =\n\t<E extends Element = HTMLElement>(\n\t\tfallback: Fallback<number, E> = 0,\n\t): Parser<number, E> =>\n\t(element: E, value: string | null | undefined) => {\n\t\tif (value == null) return getFallback(element, fallback)\n\n\t\t// Handle hexadecimal notation\n\t\tconst trimmed = value.trim()\n\t\tif (trimmed.toLowerCase().startsWith('0x'))\n\t\t\treturn (\n\t\t\t\tparseNumber(v => parseInt(v, 16), trimmed) ??\n\t\t\t\tgetFallback(element, fallback)\n\t\t\t)\n\n\t\t// Handle other formats (including scientific notation)\n\t\tconst parsed = parseNumber(parseFloat, value)\n\t\treturn parsed != null\n\t\t\t? Math.trunc(parsed)\n\t\t\t: getFallback(element, fallback)\n\t}\n\n/**\n * Parse a string as a number with a fallback\n *\n * @since 0.11.0\n * @param {Fallback<number, E>} [fallback=0] - Fallback value or extractor function\n * @returns {Parser<number, E>} Parser function\n */\nconst asNumber =\n\t<E extends Element = HTMLElement>(\n\t\tfallback: Fallback<number, E> = 0,\n\t): Parser<number, E> =>\n\t(element: E, value: string | null | undefined) =>\n\t\tparseNumber(parseFloat, value) ?? getFallback(element, fallback)\n\n/**\n * Parse a string as a string with a fallback\n *\n * @since 0.11.0\n * @param {Fallback<string, E>} [fallback=''] - Fallback value or extractor function\n * @returns {Parser<string, E>} Parser function\n */\nconst asString =\n\t<E extends Element = HTMLElement>(\n\t\tfallback: Fallback<string, E> = '',\n\t): Parser<string, E> =>\n\t(element: E, value: string | null | undefined) =>\n\t\tvalue ?? getFallback(element, fallback)\n\n/**\n * Parse a string as a multi-state value (for examnple: true, false, mixed), defaulting to the first valid option\n *\n * @since 0.9.0\n * @param {[string, ...string[]]} valid - Array of valid values\n * @returns {Parser<string>} Parser function\n */\nconst asEnum =\n\t(valid: [string, ...string[]]): Parser<string> =>\n\t(_: Element, value: string | null | undefined) => {\n\t\tif (value == null) return valid[0]\n\t\tconst lowerValue = value.toLowerCase()\n\t\tconst matchingValid = valid.find(v => v.toLowerCase() === lowerValue)\n\t\treturn matchingValid ? value : valid[0]\n\t}\n\n/**\n * Parse a string as a JSON serialized object with a fallback\n *\n * @since 0.11.0\n * @param {Fallback<T, E>} fallback - Fallback value or extractor function\n * @returns {Parser<T, E>} Parser function\n * @throws {TypeError} If the value and fallback are both null or undefined\n * @throws {SyntaxError} If value is not a valid JSON string\n */\nconst asJSON =\n\t<T extends {}, E extends Element = HTMLElement>(\n\t\tfallback: Fallback<T, E>,\n\t): Parser<T, E> =>\n\t(element: E, value: string | null | undefined) => {\n\t\tif ((value ?? fallback) == null)\n\t\t\tthrow new TypeError(\n\t\t\t\t'asJSON: Value and fallback are both null or undefined',\n\t\t\t)\n\t\tif (value == null) return getFallback(element, fallback)\n\t\tif (value === '') throw new TypeError('Empty string is not valid JSON')\n\t\tlet result: T | undefined\n\t\ttry {\n\t\t\tresult = JSON.parse(value)\n\t\t} catch (error) {\n\t\t\tthrow new SyntaxError(`Failed to parse JSON: ${String(error)}`, {\n\t\t\t\tcause: error,\n\t\t\t})\n\t\t}\n\t\treturn result ?? getFallback(element, fallback)\n\t}\n\nexport { asBoolean, asInteger, asNumber, asString, asEnum, asJSON }\n",
    "import {\n\ttype Cleanup,\n\tUNSET,\n\teffect,\n\tenqueue,\n\tisFunction,\n\tisSignal,\n\tisState,\n\ttoSignal,\n} from '@zeix/cause-effect'\n\nimport type { Component, ComponentProps } from '../component'\nimport {\n\ttype Effect,\n\tRESET,\n\ttype Reactive,\n\tresolveReactive,\n} from '../core/reactive'\nimport {\n\tDEV_MODE,\n\tLOG_ERROR,\n\telementName,\n\thasMethod,\n\tisCustomElement,\n\tisDefinedObject,\n\tisString,\n\tlog,\n} from '../core/util'\n\n/* === Types === */\n\ntype Reactives<E extends Element, P extends ComponentProps> = {\n\t[K in keyof E]?: Reactive<E[K], P, E>\n}\n\ntype UpdateOperation = 'a' | 'c' | 'd' | 'h' | 'm' | 'p' | 's' | 't'\n\ntype ElementUpdater<E extends Element, T> = {\n\top: UpdateOperation\n\tname?: string\n\tread: (element: E) => T | null\n\tupdate: (element: E, value: T) => void\n\tdelete?: (element: E) => void\n\tresolve?: (element: E) => void\n\treject?: (error: unknown) => void\n}\n\ntype ElementInserter<E extends Element> = {\n\tposition?: InsertPosition\n\tcreate: (parent: E) => Element | null\n\tresolve?: (parent: E) => void\n\treject?: (error: unknown) => void\n}\n\ntype DangerouslySetInnerHTMLOptions = {\n\tshadowRootMode?: ShadowRootMode\n\tallowScripts?: boolean\n}\n\n/* === Internal Functions === */\n\nconst getOperationDescription = (\n\top: UpdateOperation,\n\tname: string = '',\n): string => {\n\tconst ops: Record<UpdateOperation, string> = {\n\t\ta: 'attribute ',\n\t\tc: 'class ',\n\t\td: 'dataset ',\n\t\th: 'inner HTML',\n\t\tm: 'method call ',\n\t\tp: 'property ',\n\t\ts: 'style property ',\n\t\tt: 'text content',\n\t}\n\treturn ops[op] + name\n}\n\nconst createOperationHandlers = <P extends ComponentProps, E extends Element>(\n\thost: Component<P>,\n\ttarget: E,\n\toperationDesc: string,\n\tresolve?: (target: E) => void,\n\treject?: (error: unknown) => void,\n) => {\n\tconst ok = (verb: string) => () => {\n\t\tif (DEV_MODE && host.debug) {\n\t\t\tlog(\n\t\t\t\ttarget,\n\t\t\t\t`${verb} ${operationDesc} of ${elementName(target)} in ${elementName(host)}`,\n\t\t\t)\n\t\t}\n\t\tresolve?.(target)\n\t}\n\n\tconst err = (verb: string) => (error: unknown) => {\n\t\tlog(\n\t\t\terror,\n\t\t\t`Failed to ${verb} ${operationDesc} of ${elementName(target)} in ${elementName(host)}`,\n\t\t\tLOG_ERROR,\n\t\t)\n\t\treject?.(error)\n\t}\n\n\treturn { ok, err }\n}\n\nconst isSafeURL = (value: string): boolean => {\n\tif (/^(mailto|tel):/i.test(value)) return true\n\tif (value.includes('://')) {\n\t\ttry {\n\t\t\tconst url = new URL(value, window.location.origin)\n\t\t\treturn ['http:', 'https:', 'ftp:'].includes(url.protocol)\n\t\t} catch {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nconst safeSetAttribute = (\n\telement: Element,\n\tattr: string,\n\tvalue: string,\n): void => {\n\tif (/^on/i.test(attr)) throw new Error(`Unsafe attribute: ${attr}`)\n\tvalue = String(value).trim()\n\tif (!isSafeURL(value)) throw new Error(`Unsafe URL for ${attr}: ${value}`)\n\telement.setAttribute(attr, value)\n}\n\n/* === Exported Functions === */\n\n/**\n * Core effect function for updating element properties based on reactive values.\n * This function handles the lifecycle of reading, updating, and deleting element properties\n * while providing proper error handling and debugging support.\n *\n * @since 0.9.0\n * @param {Reactive<T, P, E>} reactive - The reactive value that drives the element updates\n * @param {ElementUpdater<E, T>} updater - Configuration object defining how to read, update, and delete the element property\n * @returns {Effect<P, E>} Effect function that manages the element property updates\n */\nconst updateElement =\n\t<P extends ComponentProps, T extends {}, E extends Element = HTMLElement>(\n\t\treactive: Reactive<T, P, E>,\n\t\tupdater: ElementUpdater<E, T>,\n\t): Effect<P, E> =>\n\t(host, target): Cleanup => {\n\t\tconst { op, name = '', read, update } = updater\n\t\tconst fallback = read(target)\n\t\tconst operationDesc = getOperationDescription(op, name)\n\n\t\t// If not yet set, set signal value to value read from DOM\n\t\tif (\n\t\t\tisString(reactive) &&\n\t\t\tisString(fallback) &&\n\t\t\thost[reactive] === RESET\n\t\t) {\n\t\t\thost.attributeChangedCallback(reactive, null, fallback)\n\t\t}\n\n\t\tconst { ok, err } = createOperationHandlers(\n\t\t\thost,\n\t\t\ttarget,\n\t\t\toperationDesc,\n\t\t\tupdater.resolve,\n\t\t\tupdater.reject,\n\t\t)\n\n\t\treturn effect(() => {\n\t\t\tconst updateSymbol = Symbol(name ? `${op}:${name}` : op)\n\n\t\t\tconst value = resolveReactive(reactive, host, target, operationDesc)\n\t\t\tconst resolvedValue =\n\t\t\t\tvalue === RESET\n\t\t\t\t\t? fallback\n\t\t\t\t\t: value === UNSET\n\t\t\t\t\t\t? updater.delete\n\t\t\t\t\t\t\t? null\n\t\t\t\t\t\t\t: fallback\n\t\t\t\t\t\t: value\n\n\t\t\tif (updater.delete && resolvedValue === null) {\n\t\t\t\tenqueue(() => {\n\t\t\t\t\tupdater.delete!(target)\n\t\t\t\t\treturn true\n\t\t\t\t}, updateSymbol)\n\t\t\t\t\t.then(ok('Deleted'))\n\t\t\t\t\t.catch(err('delete'))\n\t\t\t} else if (resolvedValue != null) {\n\t\t\t\tconst current = read(target)\n\t\t\t\tif (Object.is(resolvedValue, current)) return\n\n\t\t\t\tenqueue(() => {\n\t\t\t\t\tupdate(target, resolvedValue)\n\t\t\t\t\treturn true\n\t\t\t\t}, updateSymbol)\n\t\t\t\t\t.then(ok('Updated'))\n\t\t\t\t\t.catch(err('update'))\n\t\t\t}\n\t\t})\n\t}\n\n/**\n * Effect for dynamically inserting or removing elements based on a reactive numeric value.\n * Positive values insert elements, negative values remove them.\n *\n * @since 0.12.1\n * @param {Reactive<number, P, E>} reactive - Reactive value determining number of elements to insert (positive) or remove (negative)\n * @param {ElementInserter<E>} inserter - Configuration object defining how to create and position elements\n * @returns {Effect<P, E>} Effect function that manages element insertion and removal\n */\nconst insertOrRemoveElement =\n\t<P extends ComponentProps, E extends Element = HTMLElement>(\n\t\treactive: Reactive<number, P, E>,\n\t\tinserter?: ElementInserter<E>,\n\t): Effect<P, E> =>\n\t(host, target) => {\n\t\t// Custom ok handler for insertOrRemoveElement\n\t\tconst insertRemoveOk = (verb: string) => () => {\n\t\t\tif (DEV_MODE && host.debug) {\n\t\t\t\tlog(\n\t\t\t\t\ttarget,\n\t\t\t\t\t`${verb} element in ${elementName(target)} in ${elementName(host)}`,\n\t\t\t\t)\n\t\t\t}\n\t\t\tif (isFunction(inserter?.resolve)) {\n\t\t\t\tinserter.resolve(target)\n\t\t\t} else {\n\t\t\t\tconst signal = isSignal(reactive)\n\t\t\t\t\t? reactive\n\t\t\t\t\t: isString(reactive)\n\t\t\t\t\t\t? host.getSignal(reactive)\n\t\t\t\t\t\t: undefined\n\t\t\t\tif (isState<number>(signal)) signal.set(0)\n\t\t\t}\n\t\t}\n\n\t\tconst insertRemoveErr = (verb: string) => (error: unknown) => {\n\t\t\tlog(\n\t\t\t\terror,\n\t\t\t\t`Failed to ${verb} element in ${elementName(target)} in ${elementName(host)}`,\n\t\t\t\tLOG_ERROR,\n\t\t\t)\n\t\t\tinserter?.reject?.(error)\n\t\t}\n\n\t\treturn effect(() => {\n\t\t\tconst insertSymbol = Symbol('i')\n\t\t\tconst removeSymbol = Symbol('r')\n\n\t\t\tconst diff = resolveReactive(\n\t\t\t\treactive,\n\t\t\t\thost,\n\t\t\t\ttarget,\n\t\t\t\t'insertion or deletion',\n\t\t\t)\n\t\t\tconst resolvedDiff = diff === RESET ? 0 : diff\n\n\t\t\tif (resolvedDiff > 0) {\n\t\t\t\t// Positive diff => insert element\n\t\t\t\tif (!inserter) throw new TypeError(`No inserter provided`)\n\t\t\t\tenqueue(() => {\n\t\t\t\t\tfor (let i = 0; i < resolvedDiff; i++) {\n\t\t\t\t\t\tconst element = inserter.create(target)\n\t\t\t\t\t\tif (!element) continue\n\t\t\t\t\t\ttarget.insertAdjacentElement(\n\t\t\t\t\t\t\tinserter.position ?? 'beforeend',\n\t\t\t\t\t\t\telement,\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\treturn true\n\t\t\t\t}, insertSymbol)\n\t\t\t\t\t.then(insertRemoveOk('Inserted'))\n\t\t\t\t\t.catch(insertRemoveErr('insert'))\n\t\t\t} else if (resolvedDiff < 0) {\n\t\t\t\t// Negative diff => remove element\n\t\t\t\tenqueue(() => {\n\t\t\t\t\tif (\n\t\t\t\t\t\tinserter &&\n\t\t\t\t\t\t(inserter.position === 'afterbegin' ||\n\t\t\t\t\t\t\tinserter.position === 'beforeend')\n\t\t\t\t\t) {\n\t\t\t\t\t\tfor (let i = 0; i > resolvedDiff; i--) {\n\t\t\t\t\t\t\tif (inserter.position === 'afterbegin')\n\t\t\t\t\t\t\t\ttarget.firstElementChild?.remove()\n\t\t\t\t\t\t\telse target.lastElementChild?.remove()\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget.remove()\n\t\t\t\t\t}\n\t\t\t\t\treturn true\n\t\t\t\t}, removeSymbol)\n\t\t\t\t\t.then(insertRemoveOk('Removed'))\n\t\t\t\t\t.catch(insertRemoveErr('remove'))\n\t\t\t}\n\t\t})\n\t}\n\n/**\n * Effect for setting the text content of an element.\n * Replaces all child nodes (except comments) with a single text node.\n *\n * @since 0.8.0\n * @param {Reactive<string, P, E>} reactive - Reactive value bound to the text content\n * @returns {Effect<P, E>} Effect function that sets the text content of the element\n */\nconst setText = <P extends ComponentProps, E extends Element = HTMLElement>(\n\treactive: Reactive<string, P, E>,\n): Effect<P, E> =>\n\tupdateElement(reactive, {\n\t\top: 't',\n\t\tread: el => el.textContent,\n\t\tupdate: (el, value) => {\n\t\t\tArray.from(el.childNodes)\n\t\t\t\t.filter(node => node.nodeType !== Node.COMMENT_NODE)\n\t\t\t\t.forEach(node => node.remove())\n\t\t\tel.append(document.createTextNode(value))\n\t\t},\n\t})\n\n/**\n * Effect for setting a property on an element.\n * Sets the specified property directly on the element object.\n *\n * @since 0.8.0\n * @param {K} key - Name of the property to set\n * @param {Reactive<E[K], P, E>} reactive - Reactive value bound to the property value (defaults to property name)\n * @returns {Effect<P, E>} Effect function that sets the property on the element\n */\nconst setProperty = <\n\tP extends ComponentProps,\n\tK extends keyof E & string,\n\tE extends Element = HTMLElement,\n>(\n\tkey: K,\n\treactive: Reactive<E[K], P, E> = key as Reactive<E[K], P, E>,\n): Effect<P, E> =>\n\tupdateElement(reactive, {\n\t\top: 'p',\n\t\tname: key,\n\t\tread: el => (key in el ? el[key] : UNSET),\n\t\tupdate: (el, value) => {\n\t\t\tel[key] = value\n\t\t},\n\t})\n\n/**\n * Effect for controlling element visibility by setting the 'hidden' property.\n * When the reactive value is true, the element is shown; when false, it's hidden.\n *\n * @since 0.13.1\n * @param {Reactive<boolean, P, E>} reactive - Reactive value bound to the visibility state\n * @returns {Effect<P, E>} Effect function that controls element visibility\n */\nconst show = <P extends ComponentProps, E extends HTMLElement = HTMLElement>(\n\treactive: Reactive<boolean, P, E>,\n): Effect<P, E> =>\n\tupdateElement(reactive, {\n\t\top: 'p',\n\t\tname: 'hidden',\n\t\tread: el => !el.hidden,\n\t\tupdate: (el, value) => {\n\t\t\tel.hidden = !value\n\t\t},\n\t})\n\n/**\n * Effect for calling a method on an element.\n *\n * @since 0.13.3\n * @param {K} methodName - Name of the method to call\n * @param {Reactive<boolean, P, E>} reactive - Reactive value bound to the method call\n * @param {unknown[]} args - Arguments to pass to the method\n * @returns Effect function that calls the method on the element\n */\nconst callMethod = <\n\tP extends ComponentProps,\n\tK extends keyof E,\n\tE extends HTMLElement = HTMLElement,\n>(\n\tmethodName: K,\n\treactive: Reactive<boolean, P, E>,\n\targs?: unknown[],\n): Effect<P, E> =>\n\tupdateElement(reactive, {\n\t\top: 'm',\n\t\tname: String(methodName),\n\t\tread: () => null,\n\t\tupdate: (el, value) => {\n\t\t\tif (value && hasMethod(el, methodName)) {\n\t\t\t\tif (args) el[methodName](...args)\n\t\t\t\telse el[methodName]()\n\t\t\t}\n\t\t},\n\t})\n\n/**\n * Effect for controlling element focus by calling the 'focus()' method.\n * If the reactive value is true, element will be focussed; when false, nothing happens.\n *\n * @since 0.13.3\n * @param {Reactive<boolean, P, E>} reactive - Reactive value bound to the focus state\n * @returns {Effect<P, E>} Effect function that sets element focus\n */\nconst focus = <P extends ComponentProps, E extends HTMLElement = HTMLElement>(\n\treactive: Reactive<boolean, P, E>,\n): Effect<P, E> =>\n\tupdateElement(reactive, {\n\t\top: 'm',\n\t\tname: 'focus',\n\t\tread: el => el === document.activeElement,\n\t\tupdate: (el, value) => {\n\t\t\tif (value && hasMethod(el, 'focus')) el.focus()\n\t\t},\n\t})\n\n/**\n * Effect for setting an attribute on an element.\n * Sets the specified attribute with security validation for unsafe values.\n *\n * @since 0.8.0\n * @param {string} name - Name of the attribute to set\n * @param {Reactive<string, P, E>} reactive - Reactive value bound to the attribute value (defaults to attribute name)\n * @returns {Effect<P, E>} Effect function that sets the attribute on the element\n */\nconst setAttribute = <\n\tP extends ComponentProps,\n\tE extends Element = HTMLElement,\n>(\n\tname: string,\n\treactive: Reactive<string, P, E> = name,\n): Effect<P, E> =>\n\tupdateElement(reactive, {\n\t\top: 'a',\n\t\tname,\n\t\tread: el => el.getAttribute(name),\n\t\tupdate: (el, value) => {\n\t\t\tsafeSetAttribute(el, name, value)\n\t\t},\n\t\tdelete: el => {\n\t\t\tel.removeAttribute(name)\n\t\t},\n\t})\n\n/**\n * Effect for toggling a boolean attribute on an element.\n * When the reactive value is true, the attribute is present; when false, it's absent.\n *\n * @since 0.8.0\n * @param {string} name - Name of the attribute to toggle\n * @param {Reactive<boolean, P, E>} reactive - Reactive value bound to the attribute presence (defaults to attribute name)\n * @returns {Effect<P, E>} Effect function that toggles the attribute on the element\n */\nconst toggleAttribute = <\n\tP extends ComponentProps,\n\tE extends Element = HTMLElement,\n>(\n\tname: string,\n\treactive: Reactive<boolean, P, E> = name,\n): Effect<P, E> =>\n\tupdateElement(reactive, {\n\t\top: 'a',\n\t\tname,\n\t\tread: el => el.hasAttribute(name),\n\t\tupdate: (el, value) => {\n\t\t\tel.toggleAttribute(name, value)\n\t\t},\n\t})\n\n/**\n * Effect for toggling a CSS class token on an element.\n * When the reactive value is true, the class is added; when false, it's removed.\n *\n * @since 0.8.0\n * @param {string} token - CSS class token to toggle\n * @param {Reactive<boolean, P, E>} reactive - Reactive value bound to the class presence (defaults to class name)\n * @returns {Effect<P, E>} Effect function that toggles the class on the element\n */\nconst toggleClass = <P extends ComponentProps, E extends Element = HTMLElement>(\n\ttoken: string,\n\treactive: Reactive<boolean, P, E> = token,\n): Effect<P, E> =>\n\tupdateElement(reactive, {\n\t\top: 'c',\n\t\tname: token,\n\t\tread: el => el.classList.contains(token),\n\t\tupdate: (el, value) => {\n\t\t\tel.classList.toggle(token, value)\n\t\t},\n\t})\n\n/**\n * Effect for setting a CSS style property on an element.\n * Sets the specified style property with support for deletion via UNSET.\n *\n * @since 0.8.0\n * @param {string} prop - Name of the CSS style property to set\n * @param {Reactive<string, P, E>} reactive - Reactive value bound to the style property value (defaults to property name)\n * @returns {Effect<P, E>} Effect function that sets the style property on the element\n */\nconst setStyle = <\n\tP extends ComponentProps,\n\tE extends HTMLElement | SVGElement | MathMLElement = HTMLElement,\n>(\n\tprop: string,\n\treactive: Reactive<string, P, E> = prop,\n): Effect<P, E> =>\n\tupdateElement(reactive, {\n\t\top: 's',\n\t\tname: prop,\n\t\tread: el => el.style.getPropertyValue(prop),\n\t\tupdate: (el, value) => {\n\t\t\tel.style.setProperty(prop, value)\n\t\t},\n\t\tdelete: el => {\n\t\t\tel.style.removeProperty(prop)\n\t\t},\n\t})\n\n/**\n * Effect for setting the inner HTML of an element with optional Shadow DOM support.\n * Provides security options for script execution and shadow root creation.\n *\n * @since 0.11.0\n * @param {Reactive<string, P, E>} reactive - Reactive value bound to the inner HTML content\n * @param {DangerouslySetInnerHTMLOptions} options - Configuration options: shadowRootMode, allowScripts\n * @returns {Effect<P, E>} Effect function that sets the inner HTML of the element\n */\nconst dangerouslySetInnerHTML = <\n\tP extends ComponentProps,\n\tE extends Element = HTMLElement,\n>(\n\treactive: Reactive<string, P, E>,\n\toptions: DangerouslySetInnerHTMLOptions = {},\n): Effect<P, E> =>\n\tupdateElement(reactive, {\n\t\top: 'h',\n\t\tread: el =>\n\t\t\t(el.shadowRoot || !options.shadowRootMode ? el : null)?.innerHTML ??\n\t\t\t'',\n\t\tupdate: (el, html) => {\n\t\t\tconst { shadowRootMode, allowScripts } = options\n\t\t\tif (!html) {\n\t\t\t\tif (el.shadowRoot) el.shadowRoot.innerHTML = '<slot></slot>'\n\t\t\t\treturn ''\n\t\t\t}\n\t\t\tif (shadowRootMode && !el.shadowRoot)\n\t\t\t\tel.attachShadow({ mode: shadowRootMode })\n\t\t\tconst target = el.shadowRoot || el\n\t\t\ttarget.innerHTML = html\n\t\t\tif (!allowScripts) return ''\n\t\t\ttarget.querySelectorAll('script').forEach(script => {\n\t\t\t\tconst newScript = document.createElement('script')\n\t\t\t\tnewScript.appendChild(\n\t\t\t\t\tdocument.createTextNode(script.textContent ?? ''),\n\t\t\t\t)\n\t\t\t\ttarget.appendChild(newScript)\n\t\t\t\tscript.remove()\n\t\t\t})\n\t\t\treturn ' with scripts'\n\t\t},\n\t})\n\n/**\n * Effect for passing reactive values to a descendant UIElement component.\n *\n * @since 0.13.3\n * @param {Reactives<Component<Q>, P>} reactives - Reactive values to pass\n * @returns {Effect<P, E>} Effect function that passes reactive values to the descendant component\n * @throws {TypeError} When the provided reactives are not an object or the target is not a UIElement component\n * @throws {Error} When passing signals failed for some other reason\n */\nconst pass =\n\t<P extends ComponentProps, Q extends ComponentProps>(\n\t\treactives: Reactives<Component<Q>, P>,\n\t): Effect<P, Component<Q>> =>\n\t(host, target): Cleanup | void => {\n\t\tif (!isDefinedObject(reactives))\n\t\t\tthrow new TypeError(`Reactives must be an object of passed signals`)\n\t\tif (!isCustomElement(target))\n\t\t\tthrow new TypeError(\n\t\t\t\t`Target ${elementName(target)} is not a custom element`,\n\t\t\t)\n\t\tcustomElements\n\t\t\t.whenDefined(target.localName)\n\t\t\t.then(() => {\n\t\t\t\tif (!hasMethod(target, 'setSignal'))\n\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t`Target ${elementName(target)} is not a UIElement component`,\n\t\t\t\t\t)\n\t\t\t\tfor (const [prop, reactive] of Object.entries(reactives)) {\n\t\t\t\t\ttarget.setSignal(\n\t\t\t\t\t\tprop,\n\t\t\t\t\t\tisString(reactive)\n\t\t\t\t\t\t\t? host.getSignal(reactive)\n\t\t\t\t\t\t\t: toSignal(reactive),\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t})\n\t\t\t.catch(error => {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Failed to pass signals to ${elementName(target)}`,\n\t\t\t\t\t{ cause: error },\n\t\t\t\t)\n\t\t\t})\n\t}\n\n/* === Exports === */\n\nexport {\n\ttype Reactives,\n\ttype UpdateOperation,\n\ttype ElementUpdater,\n\ttype ElementInserter,\n\ttype DangerouslySetInnerHTMLOptions,\n\tupdateElement,\n\tinsertOrRemoveElement,\n\tsetText,\n\tsetProperty,\n\tshow,\n\tcallMethod,\n\tfocus,\n\tsetAttribute,\n\ttoggleAttribute,\n\ttoggleClass,\n\tsetStyle,\n\tdangerouslySetInnerHTML,\n\tpass,\n}\n",
    "import { type Extractor, type LooseExtractor, fromDOM } from '../core/dom'\n\nconst getText =\n\t<E extends Element = Element>(): LooseExtractor<string, E> =>\n\t(element: E) =>\n\t\telement.textContent?.trim()\n\nconst getProperty =\n\t<E extends Element, K extends keyof E & string>(\n\t\tprop: K,\n\t): LooseExtractor<E[K], E> =>\n\t(element: E) =>\n\t\telement[prop]\n\nconst hasAttribute =\n\t(attr: string): Extractor<boolean, Element> =>\n\t(element: Element) =>\n\t\telement.hasAttribute(attr)\n\nconst getAttribute =\n\t<E extends Element = Element>(attr: string): LooseExtractor<string, E> =>\n\t(element: E) =>\n\t\telement.getAttribute(attr)\n\nconst hasClass =\n\t(token: string): Extractor<boolean, Element> =>\n\t(element: Element) =>\n\t\telement.classList.contains(token)\n\nconst getStyle =\n\t<E extends HTMLElement | SVGElement | MathMLElement = HTMLElement>(\n\t\tprop: string,\n\t): Extractor<string, E> =>\n\t(element: E) =>\n\t\twindow.getComputedStyle(element).getPropertyValue(prop)\n\nconst getLabel = <E extends HTMLElement>(\n\tselector: string,\n): Extractor<string, E> =>\n\tfromDOM('', { '.label': getText(), [selector]: getAttribute('aria-label') })\n\nconst getDescription = <E extends HTMLElement>(\n\tselector: string,\n): Extractor<string, E> =>\n\tfromDOM('', {\n\t\t'.description': getText(),\n\t\t[selector]: getAttribute('aria-describedby'),\n\t})\n\nexport {\n\tgetText,\n\tgetProperty,\n\thasAttribute,\n\tgetAttribute,\n\thasClass,\n\tgetStyle,\n\tgetLabel,\n\tgetDescription,\n}\n"
  ],
  "mappings": "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",
  "debugId": "77E0300DA9024AB764756E2164756E21",
  "names": []
}