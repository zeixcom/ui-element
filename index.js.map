{
  "version": 3,
  "sources": ["node_modules/@zeix/cause-effect/src/util.ts", "node_modules/@zeix/cause-effect/src/scheduler.ts", "node_modules/@zeix/cause-effect/src/state.ts", "node_modules/@zeix/cause-effect/src/computed.ts", "node_modules/@zeix/cause-effect/src/signal.ts", "node_modules/@zeix/cause-effect/src/effect.ts", "src/core/util.ts", "src/core/dom.ts", "src/component.ts", "src/core/context.ts", "src/lib/parsers.ts", "src/lib/effects.ts"],
  "sourcesContent": [
    "/* === Utility Functions === */\n\nconst isFunction = /*#__PURE__*/ <T>(\n\tvalue: unknown,\n): value is (...args: unknown[]) => T => typeof value === 'function'\n\nconst isObjectOfType = /*#__PURE__*/ <T>(\n\tvalue: unknown,\n\ttype: string,\n): value is T => Object.prototype.toString.call(value) === `[object ${type}]`\n\nconst toError = (reason: unknown): Error =>\n\treason instanceof Error ? reason : Error(String(reason))\n\nclass CircularDependencyError extends Error {\n\tconstructor(where: string) {\n\t\tsuper(`Circular dependency in ${where} detected`)\n\t\treturn this\n\t}\n}\n\n/* === Exports === */\n\nexport { isFunction, isObjectOfType, toError, CircularDependencyError }\n",
    "/* === Types === */\n\ntype Cleanup = () => void\n\ntype Watcher = {\n\t(): void\n\toff(cleanup: Cleanup): void\n\tcleanup(): void\n}\n\ntype Updater = <T>() => T | boolean | void\n\n/* === Internal === */\n\n// Currently active watcher\nlet active: Watcher | undefined\n\n// Pending queue for batched change notifications\nconst pending = new Set<Watcher>()\nlet batchDepth = 0\n\n// Map of deduplication symbols to update functions (using Symbol keys prevents unintended overwrites)\nconst updateMap = new Map<symbol, Updater>()\nlet requestId: number | undefined\n\nconst updateDOM = () => {\n\trequestId = undefined\n\tconst updates = Array.from(updateMap.values())\n\tupdateMap.clear()\n\tfor (const update of updates) {\n\t\tupdate()\n\t}\n}\n\nconst requestTick = () => {\n\tif (requestId) cancelAnimationFrame(requestId)\n\trequestId = requestAnimationFrame(updateDOM)\n}\n\n// Initial render when the call stack is empty\nqueueMicrotask(updateDOM)\n\n/* === Functions === */\n\n/**\n * Create a watcher that can be used to observe changes to a signal\n *\n * @since 0.14.1\n * @param {() => void} notice - function to be called when the state changes\n * @returns {Watcher} - watcher object with off and cleanup methods\n */\nconst watch = (notice: () => void): Watcher => {\n\tconst cleanups = new Set<Cleanup>()\n\tconst w = notice as Partial<Watcher>\n\tw.off = (on: Cleanup) => {\n\t\tcleanups.add(on)\n\t}\n\tw.cleanup = () => {\n\t\tfor (const cleanup of cleanups) {\n\t\t\tcleanup()\n\t\t}\n\t\tcleanups.clear()\n\t}\n\treturn w as Watcher\n}\n\n/**\n * Add active watcher to the Set of watchers\n *\n * @param {Set<Watcher>} watchers - watchers of the signal\n */\nconst subscribe = (watchers: Set<Watcher>) => {\n\tif (active && !watchers.has(active)) {\n\t\tconst watcher = active\n\t\twatchers.add(watcher)\n\t\tactive.off(() => {\n\t\t\twatchers.delete(watcher)\n\t\t})\n\t}\n}\n\n/**\n * Add watchers to the pending set of change notifications\n *\n * @param {Set<Watcher>} watchers - watchers of the signal\n */\nconst notify = (watchers: Set<Watcher>) => {\n\tfor (const watcher of watchers) {\n\t\tif (batchDepth) pending.add(watcher)\n\t\telse watcher()\n\t}\n}\n\n/**\n * Flush all pending changes to notify watchers\n */\nconst flush = () => {\n\twhile (pending.size) {\n\t\tconst watchers = Array.from(pending)\n\t\tpending.clear()\n\t\tfor (const watcher of watchers) {\n\t\t\twatcher()\n\t\t}\n\t}\n}\n\n/**\n * Batch multiple changes in a single signal graph and DOM update cycle\n *\n * @param {() => void} fn - function with multiple signal writes to be batched\n */\nconst batch = (fn: () => void) => {\n\tbatchDepth++\n\ttry {\n\t\tfn()\n\t} finally {\n\t\tflush()\n\t\tbatchDepth--\n\t}\n}\n\n/**\n * Run a function in a reactive context\n *\n * @param {() => void} run - function to run the computation or effect\n * @param {Watcher} watcher - function to be called when the state changes or undefined for temporary unwatching while inserting auto-hydrating DOM nodes that might read signals (e.g., web components)\n */\nconst observe = (run: () => void, watcher?: Watcher): void => {\n\tconst prev = active\n\tactive = watcher\n\ttry {\n\t\trun()\n\t} finally {\n\t\tactive = prev\n\t}\n}\n\n/**\n * Enqueue a function to be executed on the next animation frame\n *\n * If the same Symbol is provided for multiple calls before the next animation frame,\n * only the latest call will be executed (deduplication).\n *\n * @param {Updater} fn - function to be executed on the next animation frame; can return updated value <T>, success <boolean> or void\n * @param {symbol} dedupe - Symbol for deduplication; if not provided, a unique Symbol is created ensuring the update is always executed\n */\nconst enqueue = <T>(fn: Updater, dedupe?: symbol) =>\n\tnew Promise<T | boolean | void>((resolve, reject) => {\n\t\tupdateMap.set(dedupe || Symbol(), () => {\n\t\t\ttry {\n\t\t\t\tresolve(fn())\n\t\t\t} catch (error) {\n\t\t\t\treject(error)\n\t\t\t}\n\t\t})\n\t\trequestTick()\n\t})\n\n/* === Exports === */\n\nexport {\n\ttype Cleanup,\n\ttype Watcher,\n\ttype Updater,\n\tsubscribe,\n\tnotify,\n\tflush,\n\tbatch,\n\twatch,\n\tobserve,\n\tenqueue,\n}\n",
    "import { UNSET } from './signal'\nimport { isObjectOfType } from './util'\nimport { type Watcher, notify, subscribe } from './scheduler'\n\n/* === Types === */\n\ntype State<T extends {}> = {\n\t[Symbol.toStringTag]: 'State'\n\tget(): T\n\tset(v: T): void\n\tupdate(fn: (v: T) => T): void\n}\n\n/* === Constants === */\n\nconst TYPE_STATE = 'State'\n\n/* === Functions === */\n\n/**\n * Create a new state signal\n *\n * @since 0.9.0\n * @param {T} initialValue - initial value of the state\n * @returns {State<T>} - new state signal\n */\nconst state = /*#__PURE__*/ <T extends {}>(initialValue: T): State<T> => {\n\tconst watchers: Set<Watcher> = new Set()\n\tlet value: T = initialValue\n\n\tconst s: State<T> = {\n\t\t[Symbol.toStringTag]: TYPE_STATE,\n\n\t\t/**\n\t\t * Get the current value of the state\n\t\t *\n\t\t * @since 0.9.0\n\t\t * @returns {T} - current value of the state\n\t\t */\n\t\tget: (): T => {\n\t\t\tsubscribe(watchers)\n\t\t\treturn value\n\t\t},\n\n\t\t/**\n\t\t * Set a new value of the state\n\t\t *\n\t\t * @since 0.9.0\n\t\t * @param {T} v\n\t\t * @returns {void}\n\t\t */\n\t\tset: (v: T): void => {\n\t\t\tif (Object.is(value, v)) return\n\t\t\tvalue = v\n\t\t\tnotify(watchers)\n\n\t\t\t// Setting to UNSET clears the watchers so the signal can be garbage collected\n\t\t\tif (UNSET === value) watchers.clear()\n\t\t},\n\n\t\t/**\n\t\t * Update the state with a new value using a function\n\t\t *\n\t\t * @since 0.10.0\n\t\t * @param {(v: T) => T} fn - function to update the state\n\t\t * @returns {void} - updates the state with the result of the function\n\t\t */\n\t\tupdate: (fn: (v: T) => T): void => {\n\t\t\ts.set(fn(value))\n\t\t},\n\t}\n\n\treturn s\n}\n\n/**\n * Check if the provided value is a State instance\n *\n * @since 0.9.0\n * @param {unknown} value - value to check\n * @returns {boolean} - true if the value is a State instance, false otherwise\n */\nconst isState = /*#__PURE__*/ <T extends {}>(\n\tvalue: unknown,\n): value is State<T> => isObjectOfType(value, TYPE_STATE)\n\n/* === Exports === */\n\nexport { type State, TYPE_STATE, state, isState }\n",
    "import {\n\tCircularDependencyError,\n\tisFunction,\n\tisObjectOfType,\n\ttoError,\n} from './util'\nimport {\n\ttype Watcher,\n\twatch,\n\tsubscribe,\n\tnotify,\n\tflush,\n\tobserve,\n} from './scheduler'\nimport { UNSET } from './signal'\n\n/* === Types === */\n\ntype Computed<T extends {}> = {\n\t[Symbol.toStringTag]: 'Computed'\n\tget(): T\n}\ntype ComputedCallback<T extends {} & { then?: void }> =\n\t| ((abort: AbortSignal) => Promise<T>)\n\t| (() => T)\n\n/* === Constants === */\n\nconst TYPE_COMPUTED = 'Computed'\n\n/* === Functions === */\n\n/**\n * Create a derived signal from existing signals\n *\n * @since 0.9.0\n * @param {ComputedCallback<T>} fn - computation callback function\n * @returns {Computed<T>} - Computed signal\n */\nconst computed = <T extends {}>(fn: ComputedCallback<T>): Computed<T> => {\n\tconst watchers: Set<Watcher> = new Set()\n\n\t// Internal state\n\tlet value: T = UNSET\n\tlet error: Error | undefined\n\tlet controller: AbortController | undefined\n\tlet dirty = true\n\tlet changed = false\n\tlet computing = false\n\n\t// Functions to update internal state\n\tconst ok = (v: T) => {\n\t\tif (!Object.is(v, value)) {\n\t\t\tvalue = v\n\t\t\tchanged = true\n\t\t}\n\t\terror = undefined\n\t\tdirty = false\n\t}\n\tconst nil = () => {\n\t\tchanged = UNSET !== value\n\t\tvalue = UNSET\n\t\terror = undefined\n\t}\n\tconst err = (e: unknown) => {\n\t\tconst newError = toError(e)\n\t\tchanged =\n\t\t\t!error ||\n\t\t\tnewError.name !== error.name ||\n\t\t\tnewError.message !== error.message\n\t\tvalue = UNSET\n\t\terror = newError\n\t}\n\tconst settle =\n\t\t<T>(settleFn: (arg: T) => void) =>\n\t\t(arg: T) => {\n\t\t\tcomputing = false\n\t\t\tcontroller = undefined\n\t\t\tsettleFn(arg)\n\t\t\tif (changed) notify(watchers)\n\t\t}\n\n\t// Own watcher: called when notified from sources (push)\n\tconst mark = watch(() => {\n\t\tdirty = true\n\t\tcontroller?.abort('Aborted because source signal changed')\n\t\tif (watchers.size) notify(watchers)\n\t\telse mark.cleanup()\n\t})\n\n\t// Called when requested by dependencies (pull)\n\tconst compute = () =>\n\t\tobserve(() => {\n\t\t\tif (computing) throw new CircularDependencyError('computed')\n\t\t\tchanged = false\n\t\t\tif (isFunction(fn) && fn.constructor.name === 'AsyncFunction') {\n\t\t\t\tif (controller) return value // return current value until promise resolves\n\t\t\t\tcontroller = new AbortController()\n\t\t\t\tcontroller.signal.addEventListener(\n\t\t\t\t\t'abort',\n\t\t\t\t\t() => {\n\t\t\t\t\t\tcomputing = false\n\t\t\t\t\t\tcontroller = undefined\n\t\t\t\t\t\tcompute() // retry\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tonce: true,\n\t\t\t\t\t},\n\t\t\t\t)\n\t\t\t}\n\t\t\tlet result: T | Promise<T>\n\t\t\tcomputing = true\n\t\t\ttry {\n\t\t\t\tresult = controller ? fn(controller.signal) : (fn as () => T)()\n\t\t\t} catch (e) {\n\t\t\t\tif (e instanceof DOMException && e.name === 'AbortError') nil()\n\t\t\t\telse err(e)\n\t\t\t\tcomputing = false\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (result instanceof Promise) result.then(settle(ok), settle(err))\n\t\t\telse if (null == result || UNSET === result) nil()\n\t\t\telse ok(result)\n\t\t\tcomputing = false\n\t\t}, mark)\n\n\tconst c: Computed<T> = {\n\t\t[Symbol.toStringTag]: TYPE_COMPUTED,\n\n\t\t/**\n\t\t * Get the current value of the computed\n\t\t *\n\t\t * @since 0.9.0\n\t\t * @returns {T} - current value of the computed\n\t\t */\n\t\tget: (): T => {\n\t\t\tsubscribe(watchers)\n\t\t\tflush()\n\t\t\tif (dirty) compute()\n\t\t\tif (error) throw error\n\t\t\treturn value\n\t\t},\n\t}\n\treturn c\n}\n\n/**\n * Check if a value is a computed state\n *\n * @since 0.9.0\n * @param {unknown} value - value to check\n * @returns {boolean} - true if value is a computed state, false otherwise\n */\nconst isComputed = /*#__PURE__*/ <T extends {}>(\n\tvalue: unknown,\n): value is Computed<T> => isObjectOfType(value, TYPE_COMPUTED)\n\n/**\n * Check if the provided value is a callback that may be used as input for toSignal() to derive a computed state\n *\n * @since 0.12.0\n * @param {unknown} value - value to check\n * @returns {boolean} - true if value is a callback or callbacks object, false otherwise\n */\nconst isComputedCallback = /*#__PURE__*/ <T extends {}>(\n\tvalue: unknown,\n): value is ComputedCallback<T> => isFunction(value) && value.length < 2\n\n/* === Exports === */\n\nexport {\n\ttype Computed,\n\ttype ComputedCallback,\n\tTYPE_COMPUTED,\n\tcomputed,\n\tisComputed,\n\tisComputedCallback,\n}\n",
    "import { isState, state } from './state'\nimport {\n\ttype ComputedCallback,\n\tisComputed,\n\tisComputedCallback,\n\tcomputed,\n} from './computed'\n\n/* === Types === */\n\ntype Signal<T extends {}> = {\n\tget(): T\n}\ntype MaybeSignal<T extends {}> = T | Signal<T> | ComputedCallback<T>\n\ntype SignalValues<S extends Signal<{}>[]> = {\n\t[K in keyof S]: S[K] extends Signal<infer T> ? T : never\n}\n\n/* === Constants === */\n\nconst UNSET: any = Symbol()\n\n/* === Functions === */\n\n/**\n * Check whether a value is a Signal or not\n *\n * @since 0.9.0\n * @param {unknown} value - value to check\n * @returns {boolean} - true if value is a Signal, false otherwise\n */\nconst isSignal = /*#__PURE__*/ <T extends {}>(\n\tvalue: unknown,\n): value is Signal<T> => isState(value) || isComputed(value)\n\n/**\n * Convert a value to a Signal if it's not already a Signal\n *\n * @since 0.9.6\n * @param {MaybeSignal<T>} value - value to convert to a Signal\n * @returns {Signal<T>} - converted Signal\n */\nconst toSignal = /*#__PURE__*/ <T extends {}>(\n\tvalue: MaybeSignal<T>,\n): Signal<T> =>\n\tisSignal<T>(value)\n\t\t? value\n\t\t: isComputedCallback<T>(value)\n\t\t\t? computed(value)\n\t\t\t: state(value as T)\n\n/* === Exports === */\n\nexport {\n\ttype Signal,\n\ttype MaybeSignal,\n\ttype SignalValues,\n\tUNSET,\n\tisSignal,\n\tisComputedCallback,\n\ttoSignal,\n}\n",
    "import { type Signal, type SignalValues, UNSET } from './signal'\nimport { CircularDependencyError, isFunction, toError } from './util'\nimport { type Cleanup, watch, observe } from './scheduler'\n\n/* === Types === */\n\ntype EffectMatcher<S extends Signal<{}>[]> = {\n\tsignals: S\n\tok: (...values: SignalValues<S>) => void | Cleanup\n\terr?: (...errors: Error[]) => void | Cleanup\n\tnil?: () => void | Cleanup\n}\n\n/* === Functions === */\n\n/**\n * Define what happens when a reactive state changes\n *\n * @since 0.1.0\n * @param {EffectMatcher<S> | (() => void | Cleanup)} matcher - effect matcher or callback\n * @returns {Cleanup} - cleanup function for the effect\n */\nfunction effect<S extends Signal<{}>[]>(\n\tmatcher: EffectMatcher<S> | (() => void | Cleanup),\n): Cleanup {\n\tconst {\n\t\tsignals,\n\t\tok,\n\t\terr = console.error,\n\t\tnil = () => {},\n\t} = isFunction(matcher)\n\t\t? { signals: [] as unknown as S, ok: matcher }\n\t\t: matcher\n\n\tlet running = false\n\tconst run = watch(() =>\n\t\tobserve(() => {\n\t\t\tif (running) throw new CircularDependencyError('effect')\n\t\t\trunning = true\n\n\t\t\t// Pure part\n\t\t\tconst errors: Error[] = []\n\t\t\tlet pending = false\n\t\t\tconst values = signals.map(signal => {\n\t\t\t\ttry {\n\t\t\t\t\tconst value = signal.get()\n\t\t\t\t\tif (value === UNSET) pending = true\n\t\t\t\t\treturn value\n\t\t\t\t} catch (e) {\n\t\t\t\t\terrors.push(toError(e))\n\t\t\t\t\treturn UNSET\n\t\t\t\t}\n\t\t\t}) as SignalValues<S>\n\n\t\t\t// Effectful part\n\t\t\tlet cleanup: void | Cleanup = undefined\n\t\t\ttry {\n\t\t\t\tcleanup = pending\n\t\t\t\t\t? nil()\n\t\t\t\t\t: errors.length\n\t\t\t\t\t\t? err(...errors)\n\t\t\t\t\t\t: ok(...values)\n\t\t\t} catch (e) {\n\t\t\t\tcleanup = err(toError(e))\n\t\t\t} finally {\n\t\t\t\tif (isFunction(cleanup)) run.off(cleanup)\n\t\t\t}\n\n\t\t\trunning = false\n\t\t}, run),\n\t)\n\trun()\n\treturn () => run.cleanup()\n}\n\n/* === Exports === */\n\nexport { type EffectMatcher, effect }\n",
    "/* === Types === */\n\nimport { isFunction } from '@zeix/cause-effect'\n\ntype LogLevel = 'debug' | 'info' | 'warn' | 'error'\n\n/* === Constants === */\n\nconst DEV_MODE = process.env.DEV_MODE\n\nconst LOG_DEBUG: LogLevel = 'debug'\nconst LOG_INFO: LogLevel = 'info'\nconst LOG_WARN: LogLevel = 'warn'\nconst LOG_ERROR: LogLevel = 'error'\n\n/* === Internal Functions === */\n\n/**\n * Return selector string for the id of the element\n *\n * @since 0.7.0\n * @param {string} id\n * @returns {string} - id string for the element with '#' prefix\n */\nconst idString = (id: string): string => (id ? `#${id}` : '')\n\n/**\n * Return a selector string for classes of the element\n *\n * @since 0.7.0\n * @param {DOMTokenList} classList - DOMTokenList to convert to a string\n * @returns {string} - class string for the DOMTokenList with '.' prefix if any\n */\nconst classString = (classList: DOMTokenList): string =>\n\tclassList.length ? `.${Array.from(classList).join('.')}` : ''\n\n/* === Exported Functions === */\n\nconst isDefinedObject = /*#__PURE__*/ (\n\tvalue: unknown,\n): value is Record<string, unknown> => !!value && typeof value === 'object'\n\nconst isString = /*#__PURE__*/ (value: unknown): value is string =>\n\ttypeof value === 'string'\n\nconst hasMethod = /*#__PURE__*/ <T extends object, K extends PropertyKey, R>(\n\tobj: T,\n\tmethodName: K,\n): obj is T & Record<K, (...args: any[]) => R> =>\n\tisString(methodName) &&\n\tmethodName in obj &&\n\tisFunction<R>((obj as any)[methodName])\n\n/**\n * Check if a node is an Element\n *\n * @param {Node} node - node to check\n * @returns {boolean} - `true` if node is an element node, otherwise `false`\n */\nconst isElement = /*#__PURE__*/ (node: Node): node is Element =>\n\tnode.nodeType === Node.ELEMENT_NODE\n\n/**\n * Check whether an element is a custom element\n *\n * @param {E} element - Element to check\n * @returns {boolean} - True if the element is a custom element\n */\nconst isCustomElement = /*#__PURE__*/ <E extends Element>(\n\telement: E,\n): boolean => element.localName.includes('-')\n\n/**\n * Check whether a custom element is upgraded or a regular element\n *\n * @param {E} element - Element to check\n * @returns {boolean} - True if the element is an upgraded custom element or a regular element\n */\nconst isUpgradedComponent = <E extends Element>(element: E): boolean => {\n\tif (!isCustomElement(element)) return true\n\tconst ctor = customElements.get(element.localName)\n\treturn !!ctor && element instanceof ctor\n}\n\n/**\n * Return a string representation of the Element instance\n *\n * @since 0.7.0\n * @param {Element} el\n * @returns {string}\n */\nconst elementName = /*#__PURE__*/ (el: Element): string =>\n\t`<${el.localName}${idString(el.id)}${classString(el.classList)}>`\n\n/**\n * Return a string representation of a JavaScript variable\n *\n * @since 0.7.0\n * @param {unknown} value\n * @returns {string}\n */\nconst valueString = /*#__PURE__*/ (value: unknown): string =>\n\tisString(value)\n\t\t? `\"${value}\"`\n\t\t: isDefinedObject(value)\n\t\t\t? JSON.stringify(value)\n\t\t\t: String(value)\n\n/**\n * Return a detailed type of a JavaScript variable\n *\n * @since 0.11.0\n * @param {unknown} value\n * @returns {string}\n */\nconst typeString = /*#__PURE__*/ (value: unknown): string => {\n\tif (value === null) return 'null'\n\tif (typeof value !== 'object') return typeof value\n\tif (Array.isArray(value)) return 'Array'\n\n\t// Check for Symbol.toStringTag\n\tif (Symbol.toStringTag in Object(value)) {\n\t\treturn (value as any)[Symbol.toStringTag]\n\t}\n\n\t// For other objects, return the constructor name if available\n\treturn value.constructor?.name || 'Object'\n}\n\n/**\n * Log a message to the console with the specified level\n *\n * @since 0.7.0\n * @param {T} value - value to inspect\n * @param {string} msg - message to log\n * @param {LogLevel} level - log level\n * @returns {T} - value passed through\n */\nconst log = <T>(value: T, msg: string, level: LogLevel = LOG_DEBUG): T => {\n\tif (DEV_MODE || ([LOG_ERROR, LOG_WARN] as LogLevel[]).includes(level))\n\t\tconsole[level](msg, value)\n\treturn value\n}\n\nexport {\n\ttype LogLevel,\n\thasMethod,\n\tisString,\n\tisDefinedObject,\n\tisElement,\n\tisCustomElement,\n\tisUpgradedComponent,\n\tlog,\n\telementName,\n\tvalueString,\n\ttypeString,\n\tDEV_MODE,\n\tLOG_DEBUG,\n\tLOG_INFO,\n\tLOG_WARN,\n\tLOG_ERROR,\n}\n",
    "import {\n\ttype Cleanup,\n\ttype Computed,\n\tTYPE_COMPUTED,\n\tUNSET,\n\ttype Watcher,\n\tisFunction,\n\tnotify,\n\tsubscribe,\n} from '@zeix/cause-effect'\n\nimport type { ElementFromSelector, SignalProducer } from '../component'\nimport { isUpgradedComponent } from './util'\n\n/* === Types === */\n\n// Helper type to get event type from HTMLElementEventMap\ntype HTMLElementEventType<K extends string> =\n\tK extends keyof HTMLElementEventMap ? HTMLElementEventMap[K] : Event\n\n// Helper type to support both standard HTML events and custom events\ntype ValidEventName = keyof HTMLElementEventMap | string\n\n// Helper type to get event type - use mapped type for known events, Event for custom events\ntype EventType<K extends string> = K extends keyof HTMLElementEventMap\n\t? HTMLElementEventMap[K]\n\t: Event\n\n// Transformer context interface for fromEvent\ninterface TransformerContext<\n\tT extends {},\n\tE extends HTMLElement,\n\tK extends string,\n> {\n\tevent: EventType<K>\n\thost: HTMLElement\n\tsource: E\n\tvalue: T\n}\n\n// Event transformer function type\ntype EventTransformer<T extends {}, E extends HTMLElement, K extends string> = (\n\tcontext: TransformerContext<T, E, K>,\n) => T\n\n/* === Error Class === */\n\n/**\n * Error thrown when a circular dependency is detected in a selection signal\n */\nclass CircularMutationError extends Error {\n\tconstructor(message: string) {\n\t\tsuper(message)\n\t\tthis.name = 'CircularMutationError'\n\t}\n}\n\n/* === Internal === */\n\n/**\n * Extract attribute names from a CSS selector\n * Handles various attribute selector formats: .class, #id, [attr], [attr=value], [attr^=value], etc.\n *\n * @param {string} selector - CSS selector to parse\n * @returns {string[]} - Array of attribute names found in the selector\n */\nconst extractAttributes = (selector: string): string[] => {\n\tconst attributes = new Set<string>()\n\tif (selector.includes('.')) attributes.add('class')\n\tif (selector.includes('#')) attributes.add('id')\n\tif (selector.includes('[')) {\n\t\tconst parts = selector.split('[')\n\t\tfor (let i = 1; i < parts.length; i++) {\n\t\t\tconst part = parts[i]\n\t\t\tif (!part.includes(']')) continue\n\t\t\tconst attrName = part\n\t\t\t\t.split('=')[0]\n\t\t\t\t.trim()\n\t\t\t\t.replace(/[^a-zA-Z0-9_-]/g, '')\n\t\t\tif (attrName) attributes.add(attrName)\n\t\t}\n\t}\n\treturn [...attributes]\n}\n\n/**\n * Compare two arrays of elements to determine if they contain the same elements\n *\n * @param {E[]} arr1 - First array of elements to compare\n * @param {E[]} arr2 - Second array of elements to compare\n * @returns {boolean} - True if arrays contain the same elements, false otherwise\n */\nconst areElementArraysEqual = <E extends Element>(\n\tarr1: E[],\n\tarr2: E[],\n): boolean => {\n\tif (arr1.length !== arr2.length) return false\n\tconst set1 = new Set(arr1)\n\tfor (const el of arr2) {\n\t\tif (!set1.has(el)) return false\n\t}\n\treturn true\n}\n\n/* === Exported Functions === */\n\n/**\n * Observe a DOM subtree with a mutation observer\n *\n * @since 0.12.2\n * @param {ParentNode} parent - parent node\n * @param {string} selectors - selector for matching elements to observe\n * @param {MutationCallback} callback - mutation callback\n * @returns {MutationObserver} - the created mutation observer\n */\nconst observeSubtree = (\n\tparent: ParentNode,\n\tselectors: string,\n\tcallback: MutationCallback,\n): MutationObserver => {\n\tconst observer = new MutationObserver(callback)\n\tconst observedAttributes = extractAttributes(selectors)\n\tconst observerConfig: MutationObserverInit = {\n\t\tchildList: true,\n\t\tsubtree: true,\n\t}\n\tif (observedAttributes.length) {\n\t\tobserverConfig.attributes = true\n\t\tobserverConfig.attributeFilter = observedAttributes\n\t}\n\tobserver.observe(parent, observerConfig)\n\treturn observer\n}\n\n/**\n * Produce a selection signal from a selector with automatic type inference\n *\n * @since 0.13.1\n * @param {K} selectors - CSS selector for descendant elements\n * @returns {(host: HTMLElement) => Computed<ElementFromSelector<K, E>[]} Signal producer for descendant element collection from a selector\n *\n * @example\n * // TypeScript automatically infers HTMLInputElement[] for 'input' selector\n * const inputs = fromSelector('input')(host).get()\n * inputs[0].value // TypeScript knows this is valid\n *\n * @example\n * // Works with custom UIElement components when declared in HTMLElementTagNameMap\n * // declare global { interface HTMLElementTagNameMap { 'my-button': Component<MyButtonProps> } }\n * const buttons = fromSelector('my-button')(host).get()\n * buttons[0].getSignal('disabled').get() // Access UIElement component methods\n */\nconst fromSelector =\n\t<E extends Element = HTMLElement, K extends string = string>(\n\t\tselectors: K,\n\t): SignalProducer<ElementFromSelector<K, E>[]> =>\n\t(host: HTMLElement) => {\n\t\tconst watchers: Set<Watcher> = new Set()\n\t\tconst select = () =>\n\t\t\tArray.from(\n\t\t\t\thost.querySelectorAll<ElementFromSelector<K, E>>(selectors),\n\t\t\t)\n\t\tlet value: ElementFromSelector<K, E>[] = UNSET\n\t\tlet observer: MutationObserver | undefined\n\t\tlet mutationDepth = 0\n\t\tconst MAX_MUTATION_DEPTH = 2 // Consider a depth > 1 as circular\n\n\t\tconst observe = () => {\n\t\t\tvalue = select()\n\t\t\tobserver = observeSubtree(host, selectors, () => {\n\t\t\t\t// If we have no watchers, just disconnect\n\t\t\t\tif (!watchers.size) {\n\t\t\t\t\tobserver?.disconnect()\n\t\t\t\t\tobserver = undefined\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tmutationDepth++\n\t\t\t\tif (mutationDepth > MAX_MUTATION_DEPTH) {\n\t\t\t\t\tobserver?.disconnect()\n\t\t\t\t\tobserver = undefined\n\t\t\t\t\tmutationDepth = 0\n\t\t\t\t\tthrow new CircularMutationError(\n\t\t\t\t\t\t'Circular mutation in element selection detected',\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tconst newElements = select()\n\t\t\t\t\tif (!areElementArraysEqual(value, newElements)) {\n\t\t\t\t\t\tvalue = newElements\n\t\t\t\t\t\tnotify(watchers)\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tmutationDepth--\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\treturn {\n\t\t\t[Symbol.toStringTag]: TYPE_COMPUTED,\n\n\t\t\tget: (): ElementFromSelector<K, E>[] => {\n\t\t\t\tsubscribe(watchers)\n\t\t\t\tif (!watchers.size) value = select()\n\t\t\t\telse if (!observer) observe()\n\t\t\t\treturn value\n\t\t\t},\n\t\t}\n\t}\n\n/**\n * Produce a computed signal from reduced properties of descendant elements with type safety\n *\n * @since 0.13.1\n * @param {K} selectors - CSS selector for descendant elements\n * @param {(accumulator: T, currentElement: ElementFromSelector<K, E>, currentIndex: number, array: ElementFromSelector<K, E>[]) => T} reducer - function to reduce values\n * @param {T} init - initial value for reduction\n * @returns {(host: HTMLElement) => () => T} signal producer that emits reduced value\n *\n * @example\n * // TypeScript knows each 'input' is HTMLInputElement\n * fromDescendants('input', (total, input) => total + input.value.length, 0)\n *\n * @example\n * // Works with UIElement components when properly declared\n * // declare global { interface HTMLElementTagNameMap { 'form-spinbutton': Component<FormSpinbuttonProps> } }\n * fromDescendants('form-spinbutton', (sum, item) => {\n *   // TypeScript knows item is Component<FormSpinbuttonProps>\n *   return sum + item.value // Access reactive property\n * }, 0)\n */\nconst fromDescendants =\n\t<T extends {}, E extends Element = HTMLElement, K extends string = string>(\n\t\tselectors: K,\n\t\treducer: (\n\t\t\taccumulator: T,\n\t\t\tcurrentElement: ElementFromSelector<K, E>,\n\t\t\tcurrentIndex: number,\n\t\t\tarray: ElementFromSelector<K, E>[],\n\t\t) => T,\n\t\tinit: T | ((host: HTMLElement) => T),\n\t): SignalProducer<T> =>\n\t(host: HTMLElement) =>\n\t() =>\n\t\t(\n\t\t\tfromSelector<ElementFromSelector<K, E>>(selectors)(\n\t\t\t\thost,\n\t\t\t) as Computed<ElementFromSelector<K, E>[]>\n\t\t)\n\t\t\t.get()\n\t\t\t.reduce(reducer, isFunction<T>(init) ? init(host) : (init as T))\n\n/**\n * Produce a computed signal from transformed event data\n *\n * @since 0.13.2\n * @param {S} selector - CSS selector for the source element\n * @param {K} type - Event type to listen for\n * @param {EventTransformer<T, ElementFromSelector<S, E>, K>} transformer - Transformation function for the event\n * @param {T | ((host: C) => T)} init - Initial value or initializer function\n * @returns {(host: C) => Computed<T>} Signal producer for value from event\n *\n * @example\n * // Simple input value extraction\n * fromEvent('input', 'input', ({ source }) => source.value, '')\n *\n * @example\n * // Click counter using previous value\n * fromEvent('button', 'click', ({ value }) => value + 1, 0)\n *\n * @example\n * // Form submission with event handling\n * fromEvent('form', 'submit', ({ event, source }) => {\n *   event.preventDefault()\n *   return new FormData(source)\n * }, null)\n *\n * @example\n * // Complex logic using multiple context values\n * fromEvent('input', 'input', ({ event, source, value, host }) => {\n *   if (event.inputType === 'deleteContentBackward') {\n *     host.dispatchEvent(new CustomEvent('deletion'))\n *   }\n *   return source.value.length > value ? source.value : value\n * }, '')\n *\n * @example\n * // TypeScript automatically infers element types from selectors\n * fromEvent('input', 'input', ({ source }) => {\n *   return source.value.length // TypeScript knows source is HTMLInputElement\n * }, 0)\n *\n * @example\n * // Custom event handling with TypeScript declarations\n * // First, declare your custom events and components globally:\n * // declare global {\n * //   interface HTMLElementTagNameMap {\n * //     'my-component': Component<MyComponentProps>\n * //   }\n * //   interface HTMLElementEventMap {\n * //     itemAdded: CustomEvent<{ id: string; quantity: number }>\n * //   }\n * // }\n * fromEvent('my-component', 'itemAdded', ({ event, source }) => {\n *   // TypeScript knows source is Component<MyComponentProps> with UIElement methods\n *   const currentValue = source.getSignal('someProperty').get()\n *   return {\n *     id: source.dataset.id,\n *     quantity: event.detail.quantity, // TypeScript knows this is a number\n *     currentValue,\n *     timestamp: Date.now()\n *   }\n * }, null)\n */\nconst fromEvent =\n\t<\n\t\tT extends {},\n\t\tE extends HTMLElement = HTMLElement,\n\t\tK extends string = string,\n\t\tC extends HTMLElement = HTMLElement,\n\t\tS extends string = string,\n\t>(\n\t\tselector: S,\n\t\ttype: K,\n\t\ttransformer: EventTransformer<T, ElementFromSelector<S, E>, K>,\n\t\tinit: T | ((host: C) => T),\n\t\toptions: boolean | AddEventListenerOptions = false,\n\t): ((host: C) => Computed<T>) =>\n\t(host: C) => {\n\t\tconst watchers: Set<Watcher> = new Set()\n\t\tlet value: T = isFunction<T>(init) ? init(host) : (init as T)\n\t\tlet listener: EventListener | undefined\n\t\tlet cleanup: Cleanup | undefined\n\n\t\tconst listen = () => {\n\t\t\tlistener = ((e: Event) => {\n\t\t\t\tconst target = e.target as Element\n\t\t\t\tif (!target) return\n\n\t\t\t\tconst source = target.closest(selector) as ElementFromSelector<\n\t\t\t\t\tS,\n\t\t\t\t\tE\n\t\t\t\t> | null\n\t\t\t\tif (!source || !host.contains(source)) return\n\t\t\t\te.stopPropagation()\n\n\t\t\t\ttry {\n\t\t\t\t\tconst newValue = transformer({\n\t\t\t\t\t\tevent: e as EventType<K>,\n\t\t\t\t\t\thost,\n\t\t\t\t\t\tsource,\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t})\n\t\t\t\t\tif (!Object.is(newValue, value)) {\n\t\t\t\t\t\tvalue = newValue\n\t\t\t\t\t\tif (watchers.size > 0) notify(watchers)\n\t\t\t\t\t\telse if (cleanup) cleanup()\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\te.stopImmediatePropagation()\n\t\t\t\t\tthrow error\n\t\t\t\t}\n\t\t\t}) as EventListener\n\n\t\t\thost.addEventListener(type, listener, options)\n\t\t\tcleanup = () => {\n\t\t\t\tif (listener) {\n\t\t\t\t\thost.removeEventListener(type, listener)\n\t\t\t\t\tlistener = undefined\n\t\t\t\t}\n\t\t\t\tcleanup = undefined\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\t[Symbol.toStringTag]: TYPE_COMPUTED,\n\n\t\t\tget: (): T => {\n\t\t\t\tsubscribe(watchers)\n\t\t\t\tif (watchers.size && !listener) listen()\n\t\t\t\treturn value\n\t\t\t},\n\t\t}\n\t} /**\n * Create a getter function for a reactive property from a descendant element with type safety\n *\n * @since 0.13.1\n * @param {S} selector - CSS selector for descendant element\n * @param {K} prop - Name of reactive property to get\n * @param {NonNullable<ElementFromSelector<S, E>[K]>} fallback - Fallback value to use until component is upgraded or if value is nullish\n * @returns {(host: HTMLElement) => () => NonNullable<ElementFromSelector<S, E>[K]>} Signal producer that gets the property value from descendant element\n * @example\n * // TypeScript knows 'value' exists on HTMLInputElement\n * fromDescendant('input', 'value', '')\n *\n * @example\n * // Access UIElement component properties with full type safety\n * // declare global { interface HTMLElementTagNameMap { 'my-counter': Component<{count: number}> } }\n * const counterValue = fromDescendant('my-counter', 'count', 0)\n *\n * @example\n * // Access UIElement component signals for advanced patterns\n * const getCounterSignal = fromDescendant('my-counter', 'getSignal', null)\n * if (getCounterSignal) {\n *   const signal = getCounterSignal('count')\n *   // Now you can work with the signal directly\n * }\n */\nconst fromDescendant =\n\t<\n\t\tE extends Element = HTMLElement,\n\t\tS extends string = string,\n\t\tK extends keyof ElementFromSelector<S, E> = keyof ElementFromSelector<\n\t\t\tS,\n\t\t\tE\n\t\t>,\n\t>(\n\t\tselector: S,\n\t\tprop: K,\n\t\tfallback: NonNullable<ElementFromSelector<S, E>[K]>,\n\t): ((\n\t\thost: HTMLElement,\n\t) => () => NonNullable<ElementFromSelector<S, E>[K]>) =>\n\t(host: HTMLElement) =>\n\t() => {\n\t\tconst source = host.querySelector<ElementFromSelector<S, E>>(selector)\n\t\tif (!source || !isUpgradedComponent(source)) return fallback\n\t\tconst value = prop in source ? source[prop] : fallback\n\t\treturn value == null || value === UNSET ? fallback : value\n\t}\n\nexport {\n\ttype HTMLElementEventType,\n\ttype ValidEventName,\n\ttype EventType,\n\ttype TransformerContext,\n\ttype EventTransformer,\n\tfromDescendant,\n\tfromDescendants,\n\tfromEvent,\n\tfromSelector,\n\tobserveSubtree,\n}\n",
    "import {\n\ttype Cleanup,\n\ttype MaybeSignal,\n\ttype Signal,\n\tUNSET,\n\tisComputed,\n\tisFunction,\n\tisSignal,\n\tisState,\n\ttoSignal,\n} from '@zeix/cause-effect'\n\nimport { observeSubtree } from './core/dom'\nimport {\n\tDEV_MODE,\n\telementName,\n\tisElement,\n\tlog,\n\ttypeString,\n\tvalueString,\n} from './core/util'\n\n/* === Types === */\n\ntype ReservedWords =\n\t| 'constructor'\n\t| 'prototype'\n\t| '__proto__'\n\t| 'toString'\n\t| 'valueOf'\n\t| 'hasOwnProperty'\n\t| 'isPrototypeOf'\n\t| 'propertyIsEnumerable'\n\t| 'toLocaleString'\n\ntype ValidPropertyKey<T> = T extends keyof HTMLElement | ReservedWords\n\t? never\n\t: T\n\ntype ComponentProps = { [K in string as ValidPropertyKey<K>]: {} }\n\ntype Component<P extends ComponentProps> = HTMLElement &\n\tP & {\n\t\t// Common Web Component lifecycle properties\n\t\tadoptedCallback?(): void\n\t\tattributeChangedCallback(\n\t\t\tname: string,\n\t\t\toldValue: string | null,\n\t\t\tnewValue: string | null,\n\t\t): void\n\t\tconnectedCallback(): void\n\t\tdisconnectedCallback(): void\n\n\t\t// Custom element properties\n\t\tdebug?: boolean\n\t\tshadowRoot: ShadowRoot | null\n\n\t\t// Component-specific signal methods\n\t\tgetSignal<K extends keyof P>(prop: K): Signal<P[K]>\n\t\tsetSignal<K extends keyof P>(prop: K, signal: Signal<P[K]>): void\n\t}\n\ntype AttributeParser<T extends {}, C extends HTMLElement = HTMLElement> = (\n\thost: C,\n\tvalue: string | null,\n\told?: string | null,\n) => T\n\ntype SignalProducer<T extends {}, C extends HTMLElement = HTMLElement> = (\n\thost: C,\n) => MaybeSignal<T>\n\ntype MethodProducer<C extends HTMLElement> = (host: C) => void\n\ntype Initializer<T extends {}, C extends HTMLElement> =\n\t| T\n\t| AttributeParser<T, C>\n\t| SignalProducer<T, C>\n\t| MethodProducer<C>\n\ntype Effect<P extends ComponentProps, E extends Element> = (\n\thost: Component<P>,\n\telement: E,\n) => Cleanup | void\n\ntype ElementFromSelector<\n\tK extends string,\n\tE extends Element = HTMLElement,\n> = K extends keyof HTMLElementTagNameMap ? HTMLElementTagNameMap[K] : E\n\ntype SelectorFunctions<P extends ComponentProps> = {\n\tfirst: <E extends Element = never, K extends string = string>(\n\t\tselector: K,\n\t\t...fns: Effect<P, ElementFromSelector<K, E>>[]\n\t) => (host: Component<P>) => Cleanup | void\n\tall: <E extends Element = never, K extends string = string>(\n\t\tselector: K,\n\t\t...fns: Effect<P, ElementFromSelector<K, E>>[]\n\t) => (host: Component<P>) => Cleanup\n}\n\n/* === Constants === */\n\n// Special value explicitly marked as any so it can be used as signal value of any type\nconst RESET: any = Symbol()\n\n// Reserved words that should never be used as property names\n// These are fundamental JavaScript/Object properties that cause serious issues\nconst RESERVED_WORDS = new Set([\n\t'constructor',\n\t'prototype',\n\t// Expand this list based on user feedback for other reserved words like:\n\t// '__proto__', 'toString', 'valueOf', 'hasOwnProperty', etc.\n])\n\n// HTMLElement properties that commonly cause conflicts\n// These are properties that exist on HTMLElement and cause confusion when overridden\n// in our reactive components because we use the same name for both attributes and properties\nconst HTML_ELEMENT_PROPS = new Set([\n\t'id', // DOM selector conflicts\n\t'class', // CSS class management conflicts (note: property is 'className')\n\t'className', // CSS class management conflicts (note: HTML attribute is 'class')\n\t'title', // Conflicts with tooltip behavior\n\t'role', // ARIA/accessibility conflicts\n\t'style', // Conflicts with style object\n\t'dataset', // Conflicts with data-* attribute access\n\t'lang', // Language/i18n conflicts\n\t'dir', // Text direction conflicts\n\t'hidden', // Visibility control conflicts\n\t'children', // DOM manipulation conflicts\n\t'innerHTML', // DOM manipulation conflicts\n\t'outerHTML', // Full element HTML conflicts\n\t'textContent', // Text manipulation conflicts\n\t'innerText', // Text manipulation conflicts\n\t// TO EXPAND: Add properties based on user feedback and common mistakes\n\t// 'tabindex', 'tabIndex', 'slot', 'part', etc.\n])\n\n/* === Internal Functions === */\n\nconst isAttributeParser = <T extends {}, C extends HTMLElement = HTMLElement>(\n\tvalue: unknown,\n): value is AttributeParser<T, C> => isFunction(value) && value.length >= 2\n\n/**\n * Simple fail-fast validation that checks for specific problematic cases\n *\n * This validation prevents common mistakes where developers accidentally\n * use property names that conflict with native HTMLElement functionality.\n */\nconst validatePropertyName = (prop: string): string | null => {\n\t// Check for reserved words that should never be used\n\tif (RESERVED_WORDS.has(prop)) {\n\t\treturn `Property name \"${prop}\" is a reserved word`\n\t}\n\n\t// Check for problematic HTMLElement properties\n\tif (HTML_ELEMENT_PROPS.has(prop)) {\n\t\treturn `Property name \"${prop}\" conflicts with inherited HTMLElement property`\n\t}\n\n\treturn null\n}\n\n/**\n * Run one or more functions on a component's element\n *\n * @since 0.12.0\n * @param {Effect<P, E>[]} fns - functions to run\n * @param {Component<P>} host - component host element\n * @param {E} target - target element\n * @returns {Cleanup} - a cleanup function that runs collected cleanup functions\n */\nconst run = <P extends ComponentProps, E extends Element = Component<P>>(\n\tfns: Effect<P, E>[],\n\thost: Component<P>,\n\ttarget: E = host as unknown as E,\n): Cleanup => {\n\tconst cleanups = fns.filter(isFunction).map(fn => fn(host, target))\n\treturn () => {\n\t\tcleanups.filter(isFunction).forEach(cleanup => cleanup())\n\t\tcleanups.length = 0\n\t}\n}\n\n/**\n * Create partially applied helper functions to select sub-elements\n *\n * @since 0.13.0\n * @returns {UI<P>} - helper functions for selecting sub-elements\n */\nconst select = <P extends ComponentProps>(): SelectorFunctions<P> => ({\n\t/**\n\t * Apply effect functions to a first matching sub-element within the custom element\n\t *\n\t * @since 0.12.0\n\t * @param {K} selector - selector to match sub-element\n\t */\n\tfirst:\n\t\t<E extends Element = never, K extends string = string>(\n\t\t\tselector: K,\n\t\t\t...fns: Effect<P, ElementFromSelector<K, E>>[]\n\t\t) =>\n\t\t(host: Component<P>): Cleanup | void => {\n\t\t\tconst el = (host.shadowRoot || host).querySelector<\n\t\t\t\tElementFromSelector<K, E>\n\t\t\t>(selector)\n\t\t\tif (el) run(fns, host, el)\n\t\t},\n\n\t/**\n\t * Apply effect functions to all matching sub-elements within the custom element\n\t *\n\t * @since 0.12.0\n\t * @param {K} selector - selector to match sub-elements\n\t */\n\tall:\n\t\t<E extends Element = never, K extends string = string>(\n\t\t\tselector: K,\n\t\t\t...fns: Effect<P, ElementFromSelector<K, E>>[]\n\t\t) =>\n\t\t(host: Component<P>): Cleanup => {\n\t\t\tconst cleanups = new Map<ElementFromSelector<K, E>, Cleanup>()\n\t\t\tconst root = host.shadowRoot || host\n\n\t\t\tconst attach = (target: ElementFromSelector<K, E>) => {\n\t\t\t\tif (!cleanups.has(target))\n\t\t\t\t\tcleanups.set(target, run(fns, host, target))\n\t\t\t}\n\n\t\t\tconst detach = (target: ElementFromSelector<K, E>) => {\n\t\t\t\tconst cleanup = cleanups.get(target)\n\t\t\t\tif (isFunction(cleanup)) cleanup()\n\t\t\t\tcleanups.delete(target)\n\t\t\t}\n\n\t\t\tconst applyToMatching =\n\t\t\t\t(fn: (target: ElementFromSelector<K, E>) => void) =>\n\t\t\t\t(node: Node) => {\n\t\t\t\t\tif (isElement(node)) {\n\t\t\t\t\t\tif (node.matches(selector))\n\t\t\t\t\t\t\tfn(node as ElementFromSelector<K, E>)\n\t\t\t\t\t\tnode.querySelectorAll<ElementFromSelector<K, E>>(\n\t\t\t\t\t\t\tselector,\n\t\t\t\t\t\t).forEach(fn)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tconst observer = observeSubtree(root, selector, mutations => {\n\t\t\t\tfor (const mutation of mutations) {\n\t\t\t\t\tmutation.addedNodes.forEach(applyToMatching(attach))\n\t\t\t\t\tmutation.removedNodes.forEach(applyToMatching(detach))\n\t\t\t\t}\n\t\t\t})\n\n\t\t\troot.querySelectorAll<ElementFromSelector<K, E>>(selector).forEach(\n\t\t\t\tattach,\n\t\t\t)\n\n\t\t\treturn () => {\n\t\t\t\tobserver.disconnect()\n\t\t\t\tcleanups.forEach(cleanup => cleanup())\n\t\t\t\tcleanups.clear()\n\t\t\t}\n\t\t},\n})\n\n/* === Exported Functions === */\n\n/**\n * Define a component with its states and setup function (connectedCallback)\n *\n * @since 0.12.0\n * @param {string} name - Name of the custom element\n * @param {{ [K in keyof S]: Initializer<S[K], Component<P>> }} init - Signals of the component\n * @param {FxFunction<S>[]} setup - Setup function to be called in connectedCallback(), may return cleanup function to be called in disconnectedCallback()\n * @returns: void\n */\nconst component = <P extends ComponentProps>(\n\tname: string,\n\tinit: {\n\t\t[K in keyof P]: Initializer<P[K], Component<P>>\n\t} = {} as {\n\t\t[K in keyof P]: Initializer<P[K], Component<P>>\n\t},\n\tsetup: (\n\t\thost: Component<P>,\n\t\tselect: SelectorFunctions<P>,\n\t) => Effect<P, Component<P>>[],\n): void => {\n\tfor (const prop of Object.keys(init)) {\n\t\tconst error = validatePropertyName(prop)\n\t\tif (error) {\n\t\t\tthrow new TypeError(`${error} in component \"${name}\".`)\n\t\t}\n\t}\n\n\tcustomElements.define(\n\t\tname,\n\t\tclass extends HTMLElement {\n\t\t\tdebug?: boolean\n\t\t\t#signals: {\n\t\t\t\t[K in keyof P]: Signal<P[K]>\n\t\t\t} = {} as {\n\t\t\t\t[K in keyof P]: Signal<P[K]>\n\t\t\t}\n\t\t\t#cleanup: Cleanup | undefined\n\n\t\t\tstatic observedAttributes =\n\t\t\t\tObject.entries(init)\n\t\t\t\t\t?.filter(([, ini]) => isAttributeParser(ini))\n\t\t\t\t\t.map(([prop]) => prop) ?? []\n\n\t\t\t/**\n\t\t\t * Constructor function for the custom element: initializes signals\n\t\t\t */\n\t\t\tconstructor() {\n\t\t\t\tsuper()\n\t\t\t\tfor (const [prop, ini] of Object.entries(init)) {\n\t\t\t\t\tif (ini == null) continue\n\t\t\t\t\tconst result = isAttributeParser<P[keyof P], Component<P>>(\n\t\t\t\t\t\tini,\n\t\t\t\t\t)\n\t\t\t\t\t\t? ini(this as unknown as Component<P>, null)\n\t\t\t\t\t\t: isFunction<Component<P>>(ini)\n\t\t\t\t\t\t\t? ini(this as unknown as Component<P>)\n\t\t\t\t\t\t\t: ini\n\t\t\t\t\tif (result != null) this.setSignal(prop, toSignal(result))\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Native callback function when the custom element is first connected to the document\n\t\t\t */\n\t\t\tconnectedCallback() {\n\t\t\t\tif (DEV_MODE) {\n\t\t\t\t\tthis.debug = this.hasAttribute('debug')\n\t\t\t\t\tif (this.debug) log(this, 'Connected')\n\t\t\t\t}\n\t\t\t\tconst fns = setup(this as unknown as Component<P>, select())\n\t\t\t\tif (!Array.isArray(fns))\n\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t`Expected array of functions as return value of setup function in ${elementName(this)}`,\n\t\t\t\t\t)\n\t\t\t\tthis.#cleanup = run(fns, this as unknown as Component<P>)\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Native callback function when the custom element is disconnected from the document\n\t\t\t */\n\t\t\tdisconnectedCallback() {\n\t\t\t\tif (isFunction(this.#cleanup)) this.#cleanup()\n\t\t\t\tif (DEV_MODE && this.debug) log(this, 'Disconnected')\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Native callback function when an observed attribute of the custom element changes\n\t\t\t *\n\t\t\t * @param {string} attr - name of the modified attribute\n\t\t\t * @param {string | null} old - old value of the modified attribute\n\t\t\t * @param {string | null} value - new value of the modified attribute\n\t\t\t */\n\t\t\tattributeChangedCallback(\n\t\t\t\tattr: string,\n\t\t\t\told: string | null,\n\t\t\t\tvalue: string | null,\n\t\t\t) {\n\t\t\t\tif (value === old || isComputed(this.#signals[attr])) return // unchanged or controlled by computed\n\t\t\t\tconst parse = init[attr as keyof P]\n\t\t\t\tif (!isAttributeParser<P[keyof P]>(parse)) return\n\t\t\t\tconst parsed = parse(\n\t\t\t\t\tthis as unknown as Component<P>,\n\t\t\t\t\tvalue,\n\t\t\t\t\told,\n\t\t\t\t)\n\t\t\t\tif (DEV_MODE && this.debug)\n\t\t\t\t\tlog(\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t`Attribute \"${attr}\" of ${elementName(this)} changed from ${valueString(old)} to ${valueString(value)}, parsed as <${typeString(parsed)}> ${valueString(parsed)}`,\n\t\t\t\t\t)\n\t\t\t\t;(this as unknown as P)[attr as keyof P] = parsed\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Get the the signal for a given key\n\t\t\t *\n\t\t\t * @since 0.12.0\n\t\t\t * @param {K} key - key to get signal for\n\t\t\t * @returns {S[K]} current value of signal; undefined if state does not exist\n\t\t\t */\n\t\t\tgetSignal(key: keyof P): Signal<P[keyof P]> {\n\t\t\t\tconst signal = this.#signals[key]\n\t\t\t\tif (DEV_MODE && this.debug)\n\t\t\t\t\tlog(\n\t\t\t\t\t\tsignal,\n\t\t\t\t\t\t`Get ${typeString(signal)} \"${String(key)}\" in ${elementName(this)}`,\n\t\t\t\t\t)\n\t\t\t\treturn signal\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Set the signal for a given key\n\t\t\t *\n\t\t\t * @since 0.12.0\n\t\t\t * @param {keyof P} key - key to set signal for\n\t\t\t * @param {Signal<P[keyof P]>} signal - signal to set value to\n\t\t\t * @throws {TypeError} if key is not a valid property key\n\t\t\t * @throws {TypeError} if signal is not a valid signal\n\t\t\t * @returns {void}\n\t\t\t */\n\t\t\tsetSignal(key: keyof P, signal: Signal<P[keyof P]>): void {\n\t\t\t\tconst error = validatePropertyName(String(key))\n\t\t\t\tif (error)\n\t\t\t\t\tthrow new TypeError(`${error} on ${elementName(this)}.`)\n\t\t\t\tif (!isSignal(signal))\n\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t`Expected signal as value for property \"${String(key)}\" on ${elementName(this)}.`,\n\t\t\t\t\t)\n\t\t\t\tconst prev = this.#signals[key]\n\t\t\t\tconst writable = isState(signal)\n\t\t\t\tthis.#signals[key] = signal\n\t\t\t\tObject.defineProperty(this, key, {\n\t\t\t\t\tget: signal.get,\n\t\t\t\t\tset: writable ? signal.set : undefined,\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: writable,\n\t\t\t\t})\n\t\t\t\tif (prev && isState(prev)) prev.set(UNSET)\n\t\t\t\tif (DEV_MODE && this.debug)\n\t\t\t\t\tlog(\n\t\t\t\t\t\tsignal,\n\t\t\t\t\t\t`Set ${typeString(signal)} \"${String(key)} in ${elementName(this)}`,\n\t\t\t\t\t)\n\t\t\t}\n\t\t},\n\t)\n\t// return customElements.get(name) as unknown as Component<P>\n}\n\nexport {\n\ttype Component,\n\ttype ComponentProps,\n\ttype ValidPropertyKey,\n\ttype ReservedWords,\n\ttype Initializer,\n\ttype AttributeParser,\n\ttype SignalProducer,\n\ttype MethodProducer,\n\ttype Effect,\n\ttype ElementFromSelector,\n\ttype SelectorFunctions,\n\tRESET,\n\tcomponent,\n}\n",
    "import {\n\ttype Cleanup,\n\ttype MaybeSignal,\n\ttype Signal,\n\tisFunction,\n\ttoSignal,\n} from '@zeix/cause-effect'\n\nimport { type Component, type ComponentProps } from '../component'\n\n/** @see https://github.com/webcomponents-cg/community-protocols/blob/main/proposals/context.md */\n\n/* === Types === */\n\n/**\n * A context key.\n *\n * A context key can be any type of object, including strings and symbols. The\n *  Context type brands the key type with the `__context__` property that\n * carries the type of the value the context references.\n */\ntype Context<K, V> = K & { __context__: V }\n\n/**\n * An unknown context type\n */\ntype UnknownContext = Context<unknown, unknown>\n\n/**\n * A helper type which can extract a Context value type from a Context type\n */\ntype ContextType<T extends UnknownContext> = T extends Context<infer _, infer V>\n\t? V\n\t: never\n\n/**\n * A callback which is provided by a context requester and is called with the value satisfying the request.\n * This callback can be called multiple times by context providers as the requested value is changed.\n */\ntype ContextCallback<V> = (value: V, unsubscribe?: () => void) => void\n\ndeclare global {\n\tinterface HTMLElementEventMap {\n\t\t/**\n\t\t * A 'context-request' event can be emitted by any element which desires\n\t\t * a context value to be injected by an external provider.\n\t\t */\n\t\t'context-request': ContextRequestEvent<Context<unknown, unknown>>\n\t}\n}\n\n/* === Constants === */\n\nconst CONTEXT_REQUEST = 'context-request'\n\n/* === Exported class === */\n\n/**\n * Class for context-request events\n *\n * An event fired by a context requester to signal it desires a named context.\n *\n * A provider should inspect the `context` property of the event to determine if it has a value that can\n * satisfy the request, calling the `callback` with the requested value if so.\n *\n * If the requested context event contains a truthy `subscribe` value, then a provider can call the callback\n * multiple times if the value is changed, if this is the case the provider should pass an `unsubscribe`\n * function to the callback which requesters can invoke to indicate they no longer wish to receive these updates.\n *\n * @class ContextRequestEvent\n * @extends {Event}\n *\n * @property {T} context - context key\n * @property {ContextCallback<ContextType<T>>} callback - callback function for value getter and unsubscribe function\n * @property {boolean} [subscribe=false] - whether to subscribe to context changes\n */\nclass ContextRequestEvent<T extends UnknownContext> extends Event {\n\tconstructor(\n\t\tpublic readonly context: T,\n\t\tpublic readonly callback: ContextCallback<ContextType<T>>,\n\t\tpublic readonly subscribe: boolean = false,\n\t) {\n\t\tsuper(CONTEXT_REQUEST, {\n\t\t\tbubbles: true,\n\t\t\tcomposed: true,\n\t\t})\n\t}\n}\n\n/**\n * Provide a context for descendant component consumers\n *\n * @since 0.12.0\n * @param {Context<K, Signal<P[K]>>[]} provided - array of contexts to provide\n * @returns {(host: Component<P>) => Cleanup} - function to add an event listener for ContextRequestEvent returning a cleanup function to remove the event listener\n */\nconst provide =\n\t<P extends ComponentProps, K extends keyof P>(\n\t\tprovided: Context<K, Signal<P[K]>>[],\n\t): ((host: Component<P>) => Cleanup) =>\n\t(host: Component<P>) => {\n\t\tconst listener = (e: ContextRequestEvent<UnknownContext>) => {\n\t\t\tconst { context, callback } = e\n\t\t\tif (\n\t\t\t\tprovided.includes(context as Context<K, Signal<P[K]>>) &&\n\t\t\t\tisFunction(callback)\n\t\t\t) {\n\t\t\t\te.stopImmediatePropagation()\n\t\t\t\tcallback(host.getSignal(String(context)))\n\t\t\t}\n\t\t}\n\t\thost.addEventListener(CONTEXT_REQUEST, listener)\n\t\treturn () => host.removeEventListener(CONTEXT_REQUEST, listener)\n\t} /**\n * Consume a context value for a component.\n *\n * @since 0.13.1\n * @param {Context<K, Signal<P[K]>>} context - context key to consume\n * @param {MaybeSignal<P[K]>} fallback - fallback value to use if context is not provided\n * @returns {(host: C) => Signal<T>} - a function that returns the consumed context signal or a signal of the fallback value\n */\nconst fromContext =\n\t<T extends {}, C extends HTMLElement>(\n\t\tcontext: Context<string, Signal<T>>,\n\t\tfallback: MaybeSignal<T>,\n\t): ((host: C) => Signal<T>) =>\n\t(host: C) => {\n\t\tlet consumed: Signal<T> = toSignal(fallback)\n\t\thost.dispatchEvent(\n\t\t\tnew ContextRequestEvent(context, (value: Signal<T>) => {\n\t\t\t\tconsumed = value\n\t\t\t}),\n\t\t)\n\t\treturn consumed\n\t}\n\nexport {\n\ttype Context,\n\ttype UnknownContext,\n\ttype ContextType,\n\tCONTEXT_REQUEST,\n\tContextRequestEvent,\n\tprovide,\n\tfromContext,\n}\n",
    "import type { AttributeParser } from '../component'\n\n/* === Internal Function === */\n\nconst parseNumber = (\n\tparseFn: (v: string) => number,\n\tvalue: string | null,\n): number | undefined => {\n\tif (value == null) return\n\tconst parsed = parseFn(value)\n\treturn Number.isFinite(parsed) ? parsed : undefined\n}\n\n/* === Exported Functions === */\n\n/**\n * Parse a boolean attribute as an actual boolean value\n *\n * @since 0.13.1\n * @returns {AttributeParser<boolean>}\n */\nconst asBoolean =\n\t(): AttributeParser<boolean> =>\n\t(_: HTMLElement, value: string | null): boolean =>\n\t\tvalue !== 'false' && value != null\n\n/**\n * Parse an attribute as as number forced to integer with a fallback\n *\n * Supports hexadecimal and scientific notation\n *\n * @since 0.11.0\n * @param {number} [fallback=0] - fallback value\n * @returns {AttributeParser<number>} parser function\n */\nconst asInteger =\n\t(fallback: number = 0): AttributeParser<number> =>\n\t(_: HTMLElement, value: string | null): number => {\n\t\tif (value == null) return fallback\n\t\tconst trimmed = value.trim()\n\t\tif (trimmed === '') return fallback\n\n\t\t// Handle hexadecimal notation\n\t\tif (trimmed.toLowerCase().startsWith('0x')) {\n\t\t\tconst parsed = parseInt(trimmed, 16)\n\t\t\treturn Number.isFinite(parsed) ? parsed : fallback\n\t\t}\n\n\t\t// Handle other formats (including scientific notation)\n\t\tconst parsed = parseNumber(parseFloat, value)\n\t\treturn parsed != null ? Math.trunc(parsed) : fallback\n\t}\n\n/**\n * Parse an attribute as as number with a fallback\n *\n * @since 0.11.0\n * @param {number} [fallback=0] - fallback value\n * @returns {AttributeParser<number>} parser function\n */\nconst asNumber =\n\t(fallback: number = 0): AttributeParser<number> =>\n\t(_: HTMLElement, value: string | null): number =>\n\t\tparseNumber(parseFloat, value) ?? fallback\n\n/**\n * Parse an attribute as a string with a fallback\n *\n * @since 0.11.0\n * @param {string} [fallback=''] - fallback value\n * @returns {AttributeParser<string>} parser function\n */\nconst asString =\n\t(fallback: string = ''): AttributeParser<string> =>\n\t(_: HTMLElement, value: string | null): string =>\n\t\tvalue ?? fallback\n\n/**\n * Parse an attribute as a multi-state value (for examnple: true, false, mixed), defaulting to the first valid option\n *\n * @since 0.9.0\n * @param {string[]} valid - array of valid values\n * @returns {AttributeParser<string>} parser function\n */\nconst asEnum =\n\t(valid: [string, ...string[]]): AttributeParser<string> =>\n\t(_: HTMLElement, value: string | null): string => {\n\t\tif (value == null) return valid[0]\n\t\tconst lowerValue = value.toLowerCase()\n\t\tconst matchingValid = valid.find(v => v.toLowerCase() === lowerValue)\n\t\treturn matchingValid ? value : valid[0]\n\t}\n\n/**\n * Parse an attribute as a JSON serialized object with a fallback\n *\n * @since 0.11.0\n * @param {T} fallback - fallback value\n * @returns {AttributeParser<T>} parser function\n * @throws {ReferenceError} if the value and fallback are both null or undefined\n * @throws {SyntaxError} if the value is not a valid JSON object\n */\nconst asJSON =\n\t<T extends {}>(fallback: T): AttributeParser<T> =>\n\t(_: HTMLElement, value: string | null): T => {\n\t\tif ((value ?? fallback) == null)\n\t\t\tthrow new ReferenceError(\n\t\t\t\t'Value and fallback are both null or undefined',\n\t\t\t)\n\t\tif (value == null) return fallback\n\t\tif (value === '')\n\t\t\tthrow new SyntaxError('Empty string is not valid JSON')\n\t\tlet result: T | undefined\n\t\ttry {\n\t\t\tresult = JSON.parse(value)\n\t\t} catch (error) {\n\t\t\tthrow new SyntaxError(`Failed to parse JSON: ${String(error)}`, {\n\t\t\t\tcause: error,\n\t\t\t})\n\t\t}\n\t\treturn result ?? fallback\n\t}\n\nexport { asBoolean, asInteger, asNumber, asString, asEnum, asJSON }\n",
    "import {\n\ttype Cleanup,\n\ttype Signal,\n\tUNSET,\n\teffect,\n\tenqueue,\n\tisFunction,\n\tisSignal,\n\tisState,\n\ttoSignal,\n} from '@zeix/cause-effect'\n\nimport {\n\ttype Component,\n\ttype ComponentProps,\n\ttype Effect,\n\tRESET,\n} from '../component'\nimport type { HTMLElementEventType, ValidEventName } from '../core/dom'\nimport {\n\tDEV_MODE,\n\tLOG_ERROR,\n\telementName,\n\thasMethod,\n\tisCustomElement,\n\tisDefinedObject,\n\tisString,\n\tlog,\n\tvalueString,\n} from '../core/util'\n\n/* === Types === */\n\ntype Reactive<T, P extends ComponentProps, E extends Element = HTMLElement> =\n\t| keyof P\n\t| Signal<NonNullable<T>>\n\t| ((element: E) => T | null | undefined)\n\ntype PassedReactives<P extends ComponentProps, E extends Element> = {\n\t[K in keyof E]?: Reactive<E[K], P, E>\n}\n\ntype UpdateOperation = 'a' | 'c' | 'h' | 'p' | 's' | 't'\n\ntype ElementUpdater<E extends Element, T> = {\n\top: UpdateOperation\n\tname?: string\n\tread: (element: E) => T | null\n\tupdate: (element: E, value: T) => void\n\tdelete?: (element: E) => void\n\tresolve?: (element: E) => void\n\treject?: (error: unknown) => void\n}\n\ntype ElementInserter<E extends Element> = {\n\tposition?: InsertPosition\n\tcreate: (parent: E) => Element | null\n\tresolve?: (parent: E) => void\n\treject?: (error: unknown) => void\n}\n\ntype DangerouslySetInnerHTMLOptions = {\n\tshadowRootMode?: ShadowRootMode\n\tallowScripts?: boolean\n}\n\n/* === Internal Functions === */\n\nconst resolveReactive = <\n\tT extends {},\n\tP extends ComponentProps,\n\tE extends Element = Component<P>,\n>(\n\ts: Reactive<T, P, E>,\n\thost: Component<P>,\n\ttarget: E,\n): T =>\n\tisString(s)\n\t\t? (host.getSignal(s).get() as unknown as T)\n\t\t: isSignal(s)\n\t\t\t? s.get()\n\t\t\t: isFunction<T>(s)\n\t\t\t\t? s(target)\n\t\t\t\t: RESET\n\nconst isSafeURL = (value: string): boolean => {\n\tif (/^(mailto|tel):/i.test(value)) return true\n\tif (value.includes('://')) {\n\t\ttry {\n\t\t\tconst url = new URL(value, window.location.origin)\n\t\t\treturn ['http:', 'https:', 'ftp:'].includes(url.protocol)\n\t\t} catch {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nconst safeSetAttribute = (\n\telement: Element,\n\tattr: string,\n\tvalue: string,\n): void => {\n\tif (/^on/i.test(attr)) throw new Error(`Unsafe attribute: ${attr}`)\n\tvalue = String(value).trim()\n\tif (!isSafeURL(value)) throw new Error(`Unsafe URL for ${attr}: ${value}`)\n\telement.setAttribute(attr, value)\n}\n\n/* === Exported Functions === */\n\n/**\n * Effect for setting properties of a target element according to a given Reactive\n *\n * @since 0.9.0\n * @param {Reactive<T, P, E>} s - Reactive bound to the element property\n * @param {ElementUpdater} updater - Updater object containing key, read, update, and delete methods\n * @returns {Effect<P, E>} Effect function that updates the element properties\n */\nconst updateElement =\n\t<P extends ComponentProps, T extends {}, E extends Element = HTMLElement>(\n\t\ts: Reactive<T, P, E>,\n\t\tupdater: ElementUpdater<E, T>,\n\t): Effect<P, E> =>\n\t(host: Component<P>, target: E): Cleanup => {\n\t\tconst { op, name = '', read, update } = updater\n\t\tconst fallback = read(target)\n\t\tconst ops: Record<string, string> = {\n\t\t\ta: 'attribute ',\n\t\t\tc: 'class ',\n\t\t\th: 'inner HTML',\n\t\t\tp: 'property ',\n\t\t\ts: 'style property ',\n\t\t\tt: 'text content',\n\t\t}\n\n\t\t// If not yet set, set signal value to value read from DOM\n\t\tif (isString(s) && isString(fallback) && host[s] === RESET)\n\t\t\thost.attributeChangedCallback(s, null, fallback)\n\n\t\tconst ok = (verb: string) => () => {\n\t\t\tif (DEV_MODE && host.debug)\n\t\t\t\tlog(\n\t\t\t\t\ttarget,\n\t\t\t\t\t`${verb} ${ops[op] + name} of ${elementName(target)} in ${elementName(host)}`,\n\t\t\t\t)\n\t\t\tupdater.resolve?.(target)\n\t\t}\n\t\tconst err = (verb: string) => (error: unknown) => {\n\t\t\tlog(\n\t\t\t\terror,\n\t\t\t\t`Failed to ${verb} ${ops[op] + name} of ${elementName(target)} in ${elementName(host)}`,\n\t\t\t\tLOG_ERROR,\n\t\t\t)\n\t\t\tupdater.reject?.(error)\n\t\t}\n\n\t\t// Update the element's DOM state according to the signal value\n\t\treturn effect(() => {\n\t\t\tconst UPDATE_DEDUPE = Symbol(`${op}:${name}`)\n\t\t\tconst DELETE_DEDUPE = Symbol(`${op}-${name}`)\n\t\t\tlet value = RESET\n\t\t\ttry {\n\t\t\t\tvalue = resolveReactive(s, host, target)\n\t\t\t} catch (error) {\n\t\t\t\tlog(\n\t\t\t\t\terror,\n\t\t\t\t\t`Failed to resolve value of ${valueString(s)} for ${ops[op] + name} of ${elementName(target)} in ${elementName(host)}`,\n\t\t\t\t\tLOG_ERROR,\n\t\t\t\t)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (value === RESET) value = fallback\n\t\t\telse if (value === UNSET) value = updater.delete ? null : fallback\n\n\t\t\tif (updater.delete && value === null) {\n\t\t\t\t// Nil path => delete the attribute or style property of the element\n\t\t\t\tenqueue(() => {\n\t\t\t\t\tupdater.delete!(target)\n\t\t\t\t\treturn true\n\t\t\t\t}, DELETE_DEDUPE)\n\t\t\t\t\t.then(ok('Deleted'))\n\t\t\t\t\t.catch(err('delete'))\n\t\t\t} else if (value != null) {\n\t\t\t\t// Ok path => update the element\n\t\t\t\tconst current = read(target)\n\t\t\t\tif (Object.is(value, current)) return\n\t\t\t\tenqueue(() => {\n\t\t\t\t\tupdate(target, value)\n\t\t\t\t\treturn true\n\t\t\t\t}, UPDATE_DEDUPE)\n\t\t\t\t\t.then(ok('Updated'))\n\t\t\t\t\t.catch(err('update'))\n\t\t\t}\n\t\t})\n\t}\n\n/**\n * Effect for inserting or removing elements according to a given Reactive\n *\n * @since 0.12.1\n * @param {Reactive<number, P, E>} s - Reactive bound to the number of elements to insert (positive) or remove (negative)\n * @param {ElementInserter<E>} inserter - Inserter object containing position, insert, and remove methods\n * @returns {Effect<P, E>} - Effect function that inserts or removes elements\n */\nconst insertOrRemoveElement =\n\t<P extends ComponentProps, E extends Element = HTMLElement>(\n\t\ts: Reactive<number, P, E>,\n\t\tinserter?: ElementInserter<E>,\n\t): Effect<P, E> =>\n\t(host: Component<P>, target: E) => {\n\t\tconst ok = (verb: string) => () => {\n\t\t\tif (DEV_MODE && host.debug)\n\t\t\t\tlog(\n\t\t\t\t\ttarget,\n\t\t\t\t\t`${verb} element in ${elementName(target)} in ${elementName(host)}`,\n\t\t\t\t)\n\t\t\tif (isFunction(inserter?.resolve)) {\n\t\t\t\tinserter.resolve(target)\n\t\t\t} else {\n\t\t\t\tconst signal = isSignal(s)\n\t\t\t\t\t? s\n\t\t\t\t\t: isString(s)\n\t\t\t\t\t\t? host.getSignal(s)\n\t\t\t\t\t\t: undefined\n\t\t\t\tif (isState<number>(signal)) signal.set(0)\n\t\t\t}\n\t\t}\n\t\tconst err = (verb: string) => (error: unknown) => {\n\t\t\tlog(\n\t\t\t\terror,\n\t\t\t\t`Failed to ${verb} element in ${elementName(target)} in ${elementName(host)}`,\n\t\t\t\tLOG_ERROR,\n\t\t\t)\n\t\t\tinserter?.reject?.(error)\n\t\t}\n\n\t\treturn effect(() => {\n\t\t\tconst INSERT_DEDUPE = Symbol('i')\n\t\t\tconst REMOVE_DEDUPE = Symbol('d')\n\t\t\tlet diff = 0\n\t\t\ttry {\n\t\t\t\tdiff = resolveReactive(s, host, target)\n\t\t\t} catch (error) {\n\t\t\t\tlog(\n\t\t\t\t\terror,\n\t\t\t\t\t`Failed to resolve value of ${valueString(s)} for insertion or deletion in ${elementName(target)} in ${elementName(host)}`,\n\t\t\t\t\tLOG_ERROR,\n\t\t\t\t)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (diff === RESET) diff = 0\n\n\t\t\tif (diff > 0) {\n\t\t\t\t// Positive diff => insert element\n\t\t\t\tif (!inserter) throw new TypeError(`No inserter provided`)\n\t\t\t\tenqueue(() => {\n\t\t\t\t\tfor (let i = 0; i < diff; i++) {\n\t\t\t\t\t\tconst element = inserter.create(target)\n\t\t\t\t\t\tif (!element) continue\n\t\t\t\t\t\ttarget.insertAdjacentElement(\n\t\t\t\t\t\t\tinserter.position ?? 'beforeend',\n\t\t\t\t\t\t\telement,\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\treturn true\n\t\t\t\t}, INSERT_DEDUPE)\n\t\t\t\t\t.then(ok('Inserted'))\n\t\t\t\t\t.catch(err('insert'))\n\t\t\t} else if (diff < 0) {\n\t\t\t\t// Negative diff => remove element\n\t\t\t\tenqueue(() => {\n\t\t\t\t\tif (\n\t\t\t\t\t\tinserter &&\n\t\t\t\t\t\t(inserter.position === 'afterbegin' ||\n\t\t\t\t\t\t\tinserter.position === 'beforeend')\n\t\t\t\t\t) {\n\t\t\t\t\t\tfor (let i = 0; i > diff; i--) {\n\t\t\t\t\t\t\tif (inserter.position === 'afterbegin')\n\t\t\t\t\t\t\t\ttarget.firstElementChild?.remove()\n\t\t\t\t\t\t\telse target.lastElementChild?.remove()\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget.remove()\n\t\t\t\t\t}\n\t\t\t\t\treturn true\n\t\t\t\t}, REMOVE_DEDUPE)\n\t\t\t\t\t.then(ok('Removed'))\n\t\t\t\t\t.catch(err('remove'))\n\t\t\t}\n\t\t})\n\t}\n\n/**\n * Set text content of an element\n *\n * @since 0.8.0\n * @param {Reactive<string, P, E>} s - Reactive bound to the text content\n * @returns {Effect<P, E>} An effect function that sets the text content of the element\n */\nconst setText = <P extends ComponentProps, E extends Element = HTMLElement>(\n\ts: Reactive<string, P, E>,\n): Effect<P, E> =>\n\tupdateElement(s, {\n\t\top: 't',\n\t\tread: el => el.textContent,\n\t\tupdate: (el, value) => {\n\t\t\tArray.from(el.childNodes)\n\t\t\t\t.filter(node => node.nodeType !== Node.COMMENT_NODE)\n\t\t\t\t.forEach(node => node.remove())\n\t\t\tel.append(document.createTextNode(value))\n\t\t},\n\t})\n\n/**\n * Set property of an element\n *\n * @since 0.8.0\n * @param {string} key - Name of property to be set\n * @param {Reactive<E[K], P, E>} s - Reactive bound to the property value\n * @returns {Effect<P, E>} An effect function that sets the property of the element\n */\nconst setProperty = <\n\tP extends ComponentProps,\n\tK extends keyof E,\n\tE extends Element = HTMLElement,\n>(\n\tkey: K,\n\ts: Reactive<E[K], P, E> = key as Reactive<E[K], P, E>,\n): Effect<P, E> =>\n\tupdateElement(s, {\n\t\top: 'p',\n\t\tname: String(key),\n\t\tread: el => (key in el ? el[key] : UNSET),\n\t\tupdate: (el, value) => {\n\t\t\tel[key] = value\n\t\t},\n\t})\n\n/**\n * Set 'hidden' property of an element\n *\n * @since 0.13.1\n * @param {Reactive<boolean, P, E>} s - Reactive bound to the 'hidden' property value\n * @returns {Effect<P, E>} An effect function that sets the 'hidden' property of the element\n */\nconst show = <P extends ComponentProps, E extends HTMLElement = HTMLElement>(\n\ts: Reactive<boolean, P, E>,\n): Effect<P, E> =>\n\tupdateElement(s, {\n\t\top: 'p',\n\t\tname: 'hidden',\n\t\tread: el => !el.hidden,\n\t\tupdate: (el, value) => {\n\t\t\tel.hidden = !value\n\t\t},\n\t})\n\n/**\n * Set attribute of an element\n *\n * @since 0.8.0\n * @param {string} name - Name of attribute to be set\n * @param {Reactive<string, P, E>} s - Reactive bound to the attribute value\n * @returns {Effect<P, E>} An effect function that sets the attribute of the element\n */\nconst setAttribute = <\n\tP extends ComponentProps,\n\tE extends Element = HTMLElement,\n>(\n\tname: string,\n\ts: Reactive<string, P, E> = name,\n): Effect<P, E> =>\n\tupdateElement(s, {\n\t\top: 'a',\n\t\tname,\n\t\tread: el => el.getAttribute(name),\n\t\tupdate: (el, value) => {\n\t\t\tsafeSetAttribute(el, name, value)\n\t\t},\n\t\tdelete: el => {\n\t\t\tel.removeAttribute(name)\n\t\t},\n\t})\n\n/**\n * Toggle a boolean attribute of an element\n *\n * @since 0.8.0\n * @param {string} name - Name of attribute to be toggled\n * @param {Reactive<boolean, P, E>} s - Reactive bound to the attribute existence\n * @returns {Effect<P, E>} An effect function that toggles the attribute of the element\n */\nconst toggleAttribute = <\n\tP extends ComponentProps,\n\tE extends Element = HTMLElement,\n>(\n\tname: string,\n\ts: Reactive<boolean, P, E> = name,\n): Effect<P, E> =>\n\tupdateElement(s, {\n\t\top: 'a',\n\t\tname,\n\t\tread: el => el.hasAttribute(name),\n\t\tupdate: (el, value) => {\n\t\t\tel.toggleAttribute(name, value)\n\t\t},\n\t})\n\n/**\n * Toggle a classList token of an element\n *\n * @since 0.8.0\n * @param {string} token - Class token to be toggled\n * @param {Reactive<boolean, P, E>} s - Reactive bound to the class existence\n * @returns {Effect<P, E>} An effect function that toggles the classList token of the element\n */\nconst toggleClass = <P extends ComponentProps, E extends Element = HTMLElement>(\n\ttoken: string,\n\ts: Reactive<boolean, P, E> = token,\n): Effect<P, E> =>\n\tupdateElement(s, {\n\t\top: 'c',\n\t\tname: token,\n\t\tread: el => el.classList.contains(token),\n\t\tupdate: (el, value) => {\n\t\t\tel.classList.toggle(token, value)\n\t\t},\n\t})\n\n/**\n * Set a style property of an element\n *\n * @since 0.8.0\n * @param {string} prop - Name of style property to be set\n * @param {Reactive<string, P, E>} s - Reactive bound to the style property value\n * @returns {Effect<P, E>} An effect function that sets the style property of the element\n */\nconst setStyle = <\n\tP extends ComponentProps,\n\tE extends HTMLElement | SVGElement | MathMLElement,\n>(\n\tprop: string,\n\ts: Reactive<string, P, E> = prop,\n): Effect<P, E> =>\n\tupdateElement(s, {\n\t\top: 's',\n\t\tname: prop,\n\t\tread: el => el.style.getPropertyValue(prop),\n\t\tupdate: (el, value) => {\n\t\t\tel.style.setProperty(prop, value)\n\t\t},\n\t\tdelete: el => {\n\t\t\tel.style.removeProperty(prop)\n\t\t},\n\t})\n\n/**\n * Set inner HTML of an element\n *\n * @since 0.11.0\n * @param {Reactive<string, P, E>} s - Reactive bound to the inner HTML\n * @param {DangerouslySetInnerHTMLOptions} options - Options for setting inner HTML: shadowRootMode, allowScripts\n * @returns {Effect<P, E>} An effect function that sets the inner HTML of the element\n */\nconst dangerouslySetInnerHTML = <\n\tP extends ComponentProps,\n\tE extends Element = HTMLElement,\n>(\n\ts: Reactive<string, P, E>,\n\toptions: DangerouslySetInnerHTMLOptions = {},\n): Effect<P, E> =>\n\tupdateElement(s, {\n\t\top: 'h',\n\t\tread: el =>\n\t\t\t(el.shadowRoot || !options.shadowRootMode ? el : null)?.innerHTML ??\n\t\t\t'',\n\t\tupdate: (el, html) => {\n\t\t\tconst { shadowRootMode, allowScripts } = options\n\t\t\tif (!html) {\n\t\t\t\tif (el.shadowRoot) el.shadowRoot.innerHTML = '<slot></slot>'\n\t\t\t\treturn ''\n\t\t\t}\n\t\t\tif (shadowRootMode && !el.shadowRoot)\n\t\t\t\tel.attachShadow({ mode: shadowRootMode })\n\t\t\tconst target = el.shadowRoot || el\n\t\t\ttarget.innerHTML = html\n\t\t\tif (!allowScripts) return ''\n\t\t\ttarget.querySelectorAll('script').forEach(script => {\n\t\t\t\tconst newScript = document.createElement('script')\n\t\t\t\tnewScript.appendChild(\n\t\t\t\t\tdocument.createTextNode(script.textContent ?? ''),\n\t\t\t\t)\n\t\t\t\ttarget.appendChild(newScript)\n\t\t\t\tscript.remove()\n\t\t\t})\n\t\t\treturn ' with scripts'\n\t\t},\n\t})\n\n/**\n * Attach an event listener to an element\n *\n * @since 0.12.0\n * @param {K} type - event type to listen for\n * @param {(event: HTMLElementEventType<K>) => void} listener - event listener\n * @param {boolean | AddEventListenerOptions} options - event listener options\n * @throws {TypeError} - if the provided handler is not an event listener or a provider function\n */\nconst on =\n\t<E extends HTMLElement, K extends ValidEventName>(\n\t\ttype: K,\n\t\tlistener: (event: HTMLElementEventType<K>) => void,\n\t\toptions: boolean | AddEventListenerOptions = false,\n\t): Effect<ComponentProps, E> =>\n\t<P extends ComponentProps>(\n\t\thost: Component<P>,\n\t\ttarget: E = host as unknown as E,\n\t): Cleanup => {\n\t\tif (!isFunction(listener))\n\t\t\tthrow new TypeError(\n\t\t\t\t`Invalid event listener provided for \"${type} event on element ${elementName(target)}`,\n\t\t\t)\n\t\ttarget.addEventListener(type, listener, options)\n\t\treturn () => target.removeEventListener(type, listener)\n\t}\n\n/**\n * Emit a custom event with the given detail\n *\n * @since 0.13.2\n * @param {string} type - Event type to emit\n * @param {Reactive<T, P, E>} s - State bound to event detail\n * @returns {Effect<P, E>} Effect function\n */\nconst emit =\n\t<T, P extends ComponentProps, E extends Element = HTMLElement>(\n\t\ttype: string,\n\t\ts: Reactive<T, P, E>,\n\t): Effect<P, E> =>\n\t(host: Component<P>, target: E = host as unknown as E): Cleanup =>\n\t\teffect(() => {\n\t\t\tlet detail\n\t\t\ttry {\n\t\t\t\tdetail = resolveReactive(s, host, target)\n\t\t\t} catch (error) {\n\t\t\t\tlog(\n\t\t\t\t\terror,\n\t\t\t\t\t`Failed to resolve value of ${valueString(s)} for custom event detail emitted on ${elementName(target)} in ${elementName(host)}`,\n\t\t\t\t\tLOG_ERROR,\n\t\t\t\t)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (detail === RESET || detail === UNSET) return\n\t\t\ttarget.dispatchEvent(\n\t\t\t\tnew CustomEvent(type, {\n\t\t\t\t\tdetail,\n\t\t\t\t\tbubbles: true,\n\t\t\t\t}),\n\t\t\t)\n\t\t})\n\n/**\n * Pass reactives to a descendent element\n *\n * @since 0.13.2\n * @param {PassedReactives<P, E> | ((target: E) => PassedReactives<P, E>)} reactives - Reactives to be passed to descendent element\n * @returns {Effect<P, E>} An effect function that passes the reactives to the descendent element\n * @throws {TypeError} If the provided signals are not an object or a provider function\n */\nconst pass =\n\t<P extends ComponentProps, E extends Element>(\n\t\treactives:\n\t\t\t| PassedReactives<P, E>\n\t\t\t| ((target: E) => PassedReactives<P, E>),\n\t): Effect<P, E> =>\n\t(host: Component<P>, target: E): Cleanup | void => {\n\t\tconst sources = isFunction<PassedReactives<P, E>>(reactives)\n\t\t\t? reactives(target)\n\t\t\t: reactives\n\t\tif (!isDefinedObject(sources))\n\t\t\tthrow new TypeError(\n\t\t\t\t`Passed signals must be an object or a provider function`,\n\t\t\t)\n\n\t\tconst setProperties = () =>\n\t\t\teffect(() => {\n\t\t\t\tfor (const [prop, source] of Object.entries(sources)) {\n\t\t\t\t\tlet value\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvalue = resolveReactive<NonNullable<E[keyof E]>, P, E>(\n\t\t\t\t\t\t\tsource,\n\t\t\t\t\t\t\thost,\n\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t)\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Failed to resolve signal ${prop} for ${elementName(target)}`,\n\t\t\t\t\t\t\t{ cause: error },\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\tif (value == null || value === RESET) continue\n\t\t\t\t\ttarget[prop as keyof E] = value\n\t\t\t\t}\n\t\t\t})\n\t\tif (!isCustomElement(target)) return setProperties()\n\t\tcustomElements\n\t\t\t.whenDefined(target.localName)\n\t\t\t.then(() => {\n\t\t\t\tif (!hasMethod(target, 'setSignal')) return setProperties()\n\t\t\t\tfor (const [prop, source] of Object.entries(sources)) {\n\t\t\t\t\ttarget.setSignal(\n\t\t\t\t\t\tprop,\n\t\t\t\t\t\tisString(source)\n\t\t\t\t\t\t\t? host.getSignal(source)\n\t\t\t\t\t\t\t: toSignal(source),\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t})\n\t\t\t.catch(error => {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Failed to pass signals to ${elementName(target)}`,\n\t\t\t\t\t{ cause: error },\n\t\t\t\t)\n\t\t\t})\n\t}\n\n/* === Exported Types === */\n\nexport {\n\ttype Reactive,\n\ttype PassedReactives,\n\ttype UpdateOperation,\n\ttype ElementUpdater,\n\ttype ElementInserter,\n\ttype DangerouslySetInnerHTMLOptions,\n\tupdateElement,\n\tinsertOrRemoveElement,\n\tsetText,\n\tsetProperty,\n\tshow,\n\tsetAttribute,\n\ttoggleAttribute,\n\ttoggleClass,\n\tsetStyle,\n\tdangerouslySetInnerHTML,\n\ton,\n\temit,\n\tpass,\n}\n"
  ],
  "mappings": "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",
  "debugId": "71EDA67FFC1BF91C64756E2164756E21",
  "names": []
}