{
  "version": 3,
  "sources": ["node_modules/@zeix/cause-effect/src/errors.ts", "node_modules/@zeix/cause-effect/src/util.ts", "node_modules/@zeix/cause-effect/src/diff.ts", "node_modules/@zeix/cause-effect/src/scheduler.ts", "node_modules/@zeix/cause-effect/src/computed.ts", "node_modules/@zeix/cause-effect/src/effect.ts", "node_modules/@zeix/cause-effect/src/match.ts", "node_modules/@zeix/cause-effect/src/resolve.ts", "node_modules/@zeix/cause-effect/src/state.ts", "node_modules/@zeix/cause-effect/src/store.ts", "node_modules/@zeix/cause-effect/src/signal.ts", "src/core/util.ts", "src/core/errors.ts", "src/core/reactive.ts", "src/core/dom.ts", "src/component.ts", "src/core/context.ts", "src/core/events.ts", "src/lib/effects.ts", "src/lib/extractors.ts", "src/lib/parsers.ts"],
  "sourcesContent": [
    "class CircularDependencyError extends Error {\n\tconstructor(where: string) {\n\t\tsuper(`Circular dependency detected in ${where}`)\n\t\tthis.name = 'CircularDependencyError'\n\t}\n}\n\nclass InvalidSignalValueError extends TypeError {\n\tconstructor(where: string, value: string) {\n\t\tsuper(`Invalid signal value ${value} in ${where}`)\n\t\tthis.name = 'InvalidSignalValueError'\n\t}\n}\n\nclass NullishSignalValueError extends TypeError {\n\tconstructor(where: string) {\n\t\tsuper(`Nullish signal values are not allowed in ${where}`)\n\t\tthis.name = 'NullishSignalValueError'\n\t}\n}\n\nclass StoreKeyExistsError extends Error {\n\tconstructor(key: string, value: string) {\n\t\tsuper(\n\t\t\t`Could not add store key \"${key}\" with value ${value} because it already exists`,\n\t\t)\n\t\tthis.name = 'StoreKeyExistsError'\n\t}\n}\n\nclass StoreKeyRangeError extends RangeError {\n\tconstructor(index: number) {\n\t\tsuper(\n\t\t\t`Could not remove store index ${String(index)} because it is out of range`,\n\t\t)\n\t\tthis.name = 'StoreKeyRangeError'\n\t}\n}\n\nclass StoreKeyReadonlyError extends Error {\n\tconstructor(key: string, value: string) {\n\t\tsuper(\n\t\t\t`Could not set store key \"${key}\" to ${value} because it is readonly`,\n\t\t)\n\t\tthis.name = 'StoreKeyReadonlyError'\n\t}\n}\n\nexport {\n\tCircularDependencyError,\n\tInvalidSignalValueError,\n\tNullishSignalValueError,\n\tStoreKeyExistsError,\n\tStoreKeyRangeError,\n\tStoreKeyReadonlyError,\n}\n",
    "/* === Constants === */\n\n// biome-ignore lint/suspicious/noExplicitAny: Deliberately using any to be used as a placeholder value in any signal\nconst UNSET: any = Symbol()\n\n/* === Utility Functions === */\n\nconst isString = /*#__PURE__*/ (value: unknown): value is string =>\n\ttypeof value === 'string'\n\nconst isNumber = /*#__PURE__*/ (value: unknown): value is number =>\n\ttypeof value === 'number'\n\nconst isSymbol = /*#__PURE__*/ (value: unknown): value is symbol =>\n\ttypeof value === 'symbol'\n\nconst isFunction = /*#__PURE__*/ <T>(\n\tfn: unknown,\n): fn is (...args: unknown[]) => T => typeof fn === 'function'\n\nconst isAsyncFunction = /*#__PURE__*/ <T>(\n\tfn: unknown,\n): fn is (...args: unknown[]) => Promise<T> =>\n\tisFunction(fn) && fn.constructor.name === 'AsyncFunction'\n\nconst isDefinedObject = /*#__PURE__*/ (\n\tvalue: unknown,\n): value is Record<string, unknown> => !!value && typeof value === 'object'\n\nconst isObjectOfType = /*#__PURE__*/ <T>(\n\tvalue: unknown,\n\ttype: string,\n): value is T => Object.prototype.toString.call(value) === `[object ${type}]`\n\nconst isRecord = /*#__PURE__*/ <T extends Record<string, unknown>>(\n\tvalue: unknown,\n): value is T => isObjectOfType(value, 'Object')\n\nconst isRecordOrArray = /*#__PURE__*/ <\n\tT extends Record<string | number, unknown> | ReadonlyArray<unknown>,\n>(\n\tvalue: unknown,\n): value is T => isRecord(value) || Array.isArray(value)\n\nconst validArrayIndexes = /*#__PURE__*/ (\n\tkeys: Array<PropertyKey>,\n): number[] | null => {\n\tif (!keys.length) return null\n\tconst indexes = keys.map(k =>\n\t\tisString(k) ? parseInt(k, 10) : isNumber(k) ? k : NaN,\n\t)\n\treturn indexes.every(index => Number.isFinite(index) && index >= 0)\n\t\t? indexes.sort((a, b) => a - b)\n\t\t: null\n}\n\nconst hasMethod = /*#__PURE__*/ <\n\tT extends object & Record<string, (...args: unknown[]) => unknown>,\n>(\n\tobj: T,\n\tmethodName: string,\n): obj is T & Record<string, (...args: unknown[]) => unknown> =>\n\tmethodName in obj && isFunction(obj[methodName])\n\nconst isAbortError = /*#__PURE__*/ (error: unknown): boolean =>\n\terror instanceof DOMException && error.name === 'AbortError'\n\nconst toError = /*#__PURE__*/ (reason: unknown): Error =>\n\treason instanceof Error ? reason : Error(String(reason))\n\nconst arrayToRecord = /*#__PURE__*/ <T>(array: T[]): Record<string, T> => {\n\tconst record: Record<string, T> = {}\n\tfor (let i = 0; i < array.length; i++) {\n\t\trecord[String(i)] = array[i]\n\t}\n\treturn record\n}\n\nconst recordToArray = /*#__PURE__*/ <T>(\n\trecord: Record<string | number, T>,\n): Record<string, T> | T[] => {\n\tconst indexes = validArrayIndexes(Object.keys(record))\n\tif (indexes === null) return record\n\n\tconst array: T[] = []\n\tfor (const index of indexes) {\n\t\tarray.push(record[String(index)])\n\t}\n\treturn array\n}\n\nconst valueString = /*#__PURE__*/ (value: unknown): string =>\n\tisString(value)\n\t\t? `\"${value}\"`\n\t\t: isDefinedObject(value)\n\t\t\t? JSON.stringify(value)\n\t\t\t: String(value)\n\n/* === Exports === */\n\nexport {\n\tUNSET,\n\tisString,\n\tisNumber,\n\tisSymbol,\n\tisFunction,\n\tisAsyncFunction,\n\tisDefinedObject,\n\tisObjectOfType,\n\tisRecord,\n\tisRecordOrArray,\n\thasMethod,\n\tisAbortError,\n\ttoError,\n\tarrayToRecord,\n\trecordToArray,\n\tvalueString,\n}\n",
    "import { CircularDependencyError } from './errors'\nimport { isRecord, isRecordOrArray, UNSET } from './util'\n\n/* === Types === */\n\ntype UnknownRecord = Record<string, unknown & {}>\ntype UnknownArray = ReadonlyArray<unknown & {}>\ntype ArrayToRecord<T extends UnknownArray> = {\n\t[key: string]: T extends Array<infer U extends {}> ? U : never\n}\ntype UnknownRecordOrArray = UnknownRecord | ArrayToRecord<UnknownArray>\n\ntype DiffResult<T extends UnknownRecordOrArray = UnknownRecord> = {\n\tchanged: boolean\n\tadd: Partial<T>\n\tchange: Partial<T>\n\tremove: Partial<T>\n}\n\n/* === Functions === */\n\n/**\n * Checks if two values are equal with cycle detection\n *\n * @since 0.15.0\n * @param {T} a - First value to compare\n * @param {T} b - Second value to compare\n * @param {WeakSet<object>} visited - Set to track visited objects for cycle detection\n * @returns {boolean} Whether the two values are equal\n */\nconst isEqual = <T>(a: T, b: T, visited?: WeakSet<object>): boolean => {\n\t// Fast paths\n\tif (Object.is(a, b)) return true\n\tif (typeof a !== typeof b) return false\n\tif (typeof a !== 'object' || a === null || b === null) return false\n\n\t// Cycle detection\n\tif (!visited) visited = new WeakSet()\n\tif (visited.has(a as object) || visited.has(b as object))\n\t\tthrow new CircularDependencyError('isEqual')\n\tvisited.add(a as object)\n\tvisited.add(b as object)\n\n\ttry {\n\t\tif (Array.isArray(a) && Array.isArray(b)) {\n\t\t\tif (a.length !== b.length) return false\n\t\t\tfor (let i = 0; i < a.length; i++) {\n\t\t\t\tif (!isEqual(a[i], b[i], visited)) return false\n\t\t\t}\n\t\t\treturn true\n\t\t}\n\n\t\tif (Array.isArray(a) !== Array.isArray(b)) return false\n\n\t\tif (isRecord(a) && isRecord(b)) {\n\t\t\tconst aKeys = Object.keys(a)\n\t\t\tconst bKeys = Object.keys(b)\n\n\t\t\tif (aKeys.length !== bKeys.length) return false\n\t\t\tfor (const key of aKeys) {\n\t\t\t\tif (!(key in b)) return false\n\t\t\t\tif (\n\t\t\t\t\t!isEqual(\n\t\t\t\t\t\t(a as Record<string, unknown>)[key],\n\t\t\t\t\t\t(b as Record<string, unknown>)[key],\n\t\t\t\t\t\tvisited,\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t\treturn false\n\t\t\t}\n\t\t\treturn true\n\t\t}\n\n\t\t// For non-records/non-arrays, they are only equal if they are the same reference\n\t\t// (which would have been caught by Object.is at the beginning)\n\t\treturn false\n\t} finally {\n\t\tvisited.delete(a as object)\n\t\tvisited.delete(b as object)\n\t}\n}\n\n/**\n * Compares two records and returns a result object containing the differences.\n *\n * @since 0.15.0\n * @param {T} oldObj - The old record to compare\n * @param {T} newObj - The new record to compare\n * @returns {DiffResult<T>} The result of the comparison\n */\nconst diff = <T extends UnknownRecordOrArray>(\n\toldObj: T,\n\tnewObj: T,\n): DiffResult<T> => {\n\t// Guard against non-objects that can't be diffed properly with Object.keys and 'in' operator\n\tconst oldValid = isRecordOrArray(oldObj)\n\tconst newValid = isRecordOrArray(newObj)\n\tif (!oldValid || !newValid) {\n\t\t// For non-objects or non-plain objects, treat as complete change if different\n\t\tconst changed = !Object.is(oldObj, newObj)\n\t\treturn {\n\t\t\tchanged,\n\t\t\tadd: changed && newValid ? newObj : {},\n\t\t\tchange: {},\n\t\t\tremove: changed && oldValid ? oldObj : {},\n\t\t}\n\t}\n\n\tconst visited = new WeakSet()\n\n\tconst add: Partial<T> = {}\n\tconst change: Partial<T> = {}\n\tconst remove: Partial<T> = {}\n\n\tconst oldKeys = Object.keys(oldObj)\n\tconst newKeys = Object.keys(newObj)\n\tconst allKeys = new Set([...oldKeys, ...newKeys])\n\n\tfor (const key of allKeys) {\n\t\tconst oldHas = key in oldObj\n\t\tconst newHas = key in newObj\n\n\t\tif (!oldHas && newHas) {\n\t\t\tadd[key as keyof T] = newObj[key] as T[keyof T]\n\t\t\tcontinue\n\t\t} else if (oldHas && !newHas) {\n\t\t\tremove[key as keyof T] = UNSET\n\t\t\tcontinue\n\t\t}\n\n\t\tconst oldValue = oldObj[key] as T[keyof T]\n\t\tconst newValue = newObj[key] as T[keyof T]\n\n\t\tif (!isEqual(oldValue, newValue, visited))\n\t\t\tchange[key as keyof T] = newValue\n\t}\n\n\tconst changed =\n\t\tObject.keys(add).length > 0 ||\n\t\tObject.keys(change).length > 0 ||\n\t\tObject.keys(remove).length > 0\n\n\treturn {\n\t\tchanged,\n\t\tadd,\n\t\tchange,\n\t\tremove,\n\t}\n}\n\n/* === Exports === */\n\nexport {\n\ttype ArrayToRecord,\n\ttype DiffResult,\n\tdiff,\n\tisEqual,\n\ttype UnknownRecord,\n\ttype UnknownArray,\n\ttype UnknownRecordOrArray,\n}\n",
    "/* === Types === */\n\ntype Cleanup = () => void\n\ntype Watcher = {\n\t(): void\n\toff(cleanup: Cleanup): void\n\tcleanup(): void\n}\n\ntype Updater = <T>() => T | boolean | undefined\n\n/* === Internal === */\n\n// Currently active watcher\nlet active: Watcher | undefined\n\n// Pending queue for batched change notifications\nconst pending = new Set<Watcher>()\nlet batchDepth = 0\n\n// Map of deduplication symbols to update functions (using Symbol keys prevents unintended overwrites)\nconst updateMap = new Map<symbol, Updater>()\nlet requestId: number | undefined\n\nconst updateDOM = () => {\n\trequestId = undefined\n\tconst updates = Array.from(updateMap.values())\n\tupdateMap.clear()\n\tfor (const update of updates) {\n\t\tupdate()\n\t}\n}\n\nconst requestTick = () => {\n\tif (requestId) cancelAnimationFrame(requestId)\n\trequestId = requestAnimationFrame(updateDOM)\n}\n\n// Initial render when the call stack is empty\nqueueMicrotask(updateDOM)\n\n/* === Functions === */\n\n/**\n * Create a watcher that can be used to observe changes to a signal\n *\n * @since 0.14.1\n * @param {() => void} notice - function to be called when the state changes\n * @returns {Watcher} - watcher object with off and cleanup methods\n */\nconst watch = (notice: () => void): Watcher => {\n\tconst cleanups = new Set<Cleanup>()\n\tconst w = notice as Partial<Watcher>\n\tw.off = (on: Cleanup) => {\n\t\tcleanups.add(on)\n\t}\n\tw.cleanup = () => {\n\t\tfor (const cleanup of cleanups) {\n\t\t\tcleanup()\n\t\t}\n\t\tcleanups.clear()\n\t}\n\treturn w as Watcher\n}\n\n/**\n * Add active watcher to the Set of watchers\n *\n * @param {Set<Watcher>} watchers - watchers of the signal\n */\nconst subscribe = (watchers: Set<Watcher>) => {\n\tif (active && !watchers.has(active)) {\n\t\tconst watcher = active\n\t\twatchers.add(watcher)\n\t\tactive.off(() => {\n\t\t\twatchers.delete(watcher)\n\t\t})\n\t}\n}\n\n/**\n * Add watchers to the pending set of change notifications\n *\n * @param {Set<Watcher>} watchers - watchers of the signal\n */\nconst notify = (watchers: Set<Watcher>) => {\n\tfor (const watcher of watchers) {\n\t\tif (batchDepth) pending.add(watcher)\n\t\telse watcher()\n\t}\n}\n\n/**\n * Flush all pending changes to notify watchers\n */\nconst flush = () => {\n\twhile (pending.size) {\n\t\tconst watchers = Array.from(pending)\n\t\tpending.clear()\n\t\tfor (const watcher of watchers) {\n\t\t\twatcher()\n\t\t}\n\t}\n}\n\n/**\n * Batch multiple changes in a single signal graph and DOM update cycle\n *\n * @param {() => void} fn - function with multiple signal writes to be batched\n */\nconst batch = (fn: () => void) => {\n\tbatchDepth++\n\ttry {\n\t\tfn()\n\t} finally {\n\t\tflush()\n\t\tbatchDepth--\n\t}\n}\n\n/**\n * Run a function in a reactive context\n *\n * @param {() => void} run - function to run the computation or effect\n * @param {Watcher} watcher - function to be called when the state changes or undefined for temporary unwatching while inserting auto-hydrating DOM nodes that might read signals (e.g., web components)\n */\nconst observe = (run: () => void, watcher?: Watcher): void => {\n\tconst prev = active\n\tactive = watcher\n\ttry {\n\t\trun()\n\t} finally {\n\t\tactive = prev\n\t}\n}\n\n/**\n * Enqueue a function to be executed on the next animation frame\n *\n * If the same Symbol is provided for multiple calls before the next animation frame,\n * only the latest call will be executed (deduplication).\n *\n * @param {Updater} fn - function to be executed on the next animation frame; can return updated value <T>, success <boolean> or void\n * @param {symbol} dedupe - Symbol for deduplication; if not provided, a unique Symbol is created ensuring the update is always executed\n */\nconst enqueue = <T>(fn: Updater, dedupe?: symbol) =>\n\tnew Promise<T | boolean | undefined>((resolve, reject) => {\n\t\tupdateMap.set(dedupe || Symbol(), (): undefined => {\n\t\t\ttry {\n\t\t\t\tresolve(fn())\n\t\t\t} catch (error) {\n\t\t\t\treject(error)\n\t\t\t}\n\t\t})\n\t\trequestTick()\n\t})\n\n/* === Exports === */\n\nexport {\n\ttype Cleanup,\n\ttype Watcher,\n\ttype Updater,\n\tsubscribe,\n\tnotify,\n\tflush,\n\tbatch,\n\twatch,\n\tobserve,\n\tenqueue,\n}\n",
    "import { isEqual } from './diff'\nimport { CircularDependencyError } from './errors'\nimport {\n\tflush,\n\tnotify,\n\tobserve,\n\tsubscribe,\n\ttype Watcher,\n\twatch,\n} from './scheduler'\nimport {\n\tisAbortError,\n\tisAsyncFunction,\n\tisFunction,\n\tisObjectOfType,\n\ttoError,\n\tUNSET,\n} from './util'\n\n/* === Types === */\n\ntype Computed<T extends {}> = {\n\t[Symbol.toStringTag]: 'Computed'\n\tget(): T\n}\ntype ComputedCallback<T extends {} & { then?: undefined }> =\n\t| ((abort: AbortSignal) => Promise<T>)\n\t| (() => T)\n\n/* === Constants === */\n\nconst TYPE_COMPUTED = 'Computed'\n\n/* === Functions === */\n\n/**\n * Create a derived signal from existing signals\n *\n * @since 0.9.0\n * @param {ComputedCallback<T>} fn - computation callback function\n * @returns {Computed<T>} - Computed signal\n */\nconst computed = <T extends {}>(fn: ComputedCallback<T>): Computed<T> => {\n\tconst watchers: Set<Watcher> = new Set()\n\n\t// Internal state\n\tlet value: T = UNSET\n\tlet error: Error | undefined\n\tlet controller: AbortController | undefined\n\tlet dirty = true\n\tlet changed = false\n\tlet computing = false\n\n\t// Functions to update internal state\n\tconst ok = (v: T): undefined => {\n\t\tif (!isEqual(v, value)) {\n\t\t\tvalue = v\n\t\t\tchanged = true\n\t\t}\n\t\terror = undefined\n\t\tdirty = false\n\t}\n\tconst nil = (): undefined => {\n\t\tchanged = UNSET !== value\n\t\tvalue = UNSET\n\t\terror = undefined\n\t}\n\tconst err = (e: unknown): undefined => {\n\t\tconst newError = toError(e)\n\t\tchanged =\n\t\t\t!error ||\n\t\t\tnewError.name !== error.name ||\n\t\t\tnewError.message !== error.message\n\t\tvalue = UNSET\n\t\terror = newError\n\t}\n\tconst settle =\n\t\t<T>(settleFn: (arg: T) => void) =>\n\t\t(arg: T) => {\n\t\t\tcomputing = false\n\t\t\tcontroller = undefined\n\t\t\tsettleFn(arg)\n\t\t\tif (changed) notify(watchers)\n\t\t}\n\n\t// Own watcher: called when notified from sources (push)\n\tconst mark = watch(() => {\n\t\tdirty = true\n\t\tcontroller?.abort()\n\t\tif (watchers.size) notify(watchers)\n\t\telse mark.cleanup()\n\t})\n\tmark.off(() => {\n\t\tcontroller?.abort()\n\t})\n\n\t// Called when requested by dependencies (pull)\n\tconst compute = () =>\n\t\tobserve(() => {\n\t\t\tif (computing) throw new CircularDependencyError('computed')\n\t\t\tchanged = false\n\t\t\tif (isAsyncFunction(fn)) {\n\t\t\t\t// Return current value until promise resolves\n\t\t\t\tif (controller) return value\n\t\t\t\tcontroller = new AbortController()\n\t\t\t\tcontroller.signal.addEventListener(\n\t\t\t\t\t'abort',\n\t\t\t\t\t() => {\n\t\t\t\t\t\tcomputing = false\n\t\t\t\t\t\tcontroller = undefined\n\n\t\t\t\t\t\t// Retry computation with updated state\n\t\t\t\t\t\tcompute()\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tonce: true,\n\t\t\t\t\t},\n\t\t\t\t)\n\t\t\t}\n\t\t\tlet result: T | Promise<T>\n\t\t\tcomputing = true\n\t\t\ttry {\n\t\t\t\tresult = controller ? fn(controller.signal) : (fn as () => T)()\n\t\t\t} catch (e) {\n\t\t\t\tif (isAbortError(e)) nil()\n\t\t\t\telse err(e)\n\t\t\t\tcomputing = false\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (result instanceof Promise) result.then(settle(ok), settle(err))\n\t\t\telse if (null == result || UNSET === result) nil()\n\t\t\telse ok(result)\n\t\t\tcomputing = false\n\t\t}, mark)\n\n\tconst c: Computed<T> = {\n\t\t[Symbol.toStringTag]: TYPE_COMPUTED,\n\n\t\t/**\n\t\t * Get the current value of the computed\n\t\t *\n\t\t * @since 0.9.0\n\t\t * @returns {T} - current value of the computed\n\t\t */\n\t\tget: (): T => {\n\t\t\tsubscribe(watchers)\n\t\t\tflush()\n\t\t\tif (dirty) compute()\n\t\t\tif (error) throw error\n\t\t\treturn value\n\t\t},\n\t}\n\treturn c\n}\n\n/**\n * Check if a value is a computed state\n *\n * @since 0.9.0\n * @param {unknown} value - value to check\n * @returns {boolean} - true if value is a computed state, false otherwise\n */\nconst isComputed = /*#__PURE__*/ <T extends {}>(\n\tvalue: unknown,\n): value is Computed<T> => isObjectOfType(value, TYPE_COMPUTED)\n\n/**\n * Check if the provided value is a callback that may be used as input for toSignal() to derive a computed state\n *\n * @since 0.12.0\n * @param {unknown} value - value to check\n * @returns {boolean} - true if value is a callback or callbacks object, false otherwise\n */\nconst isComputedCallback = /*#__PURE__*/ <T extends {}>(\n\tvalue: unknown,\n): value is ComputedCallback<T> => isFunction(value) && value.length < 2\n\n/* === Exports === */\n\nexport {\n\tTYPE_COMPUTED,\n\tcomputed,\n\tisComputed,\n\tisComputedCallback,\n\ttype Computed,\n\ttype ComputedCallback,\n}\n",
    "import { CircularDependencyError } from './errors'\nimport { type Cleanup, observe, watch } from './scheduler'\nimport { isAbortError, isAsyncFunction, isFunction } from './util'\n\n/* === Types === */\n\n// biome-ignore lint/suspicious/noConfusingVoidType: optional Cleanup return type\ntype MaybeCleanup = Cleanup | undefined | void\n\ntype EffectCallback =\n\t| (() => MaybeCleanup)\n\t| ((abort: AbortSignal) => Promise<MaybeCleanup>)\n\n/* === Functions === */\n\n/**\n * Define what happens when a reactive state changes\n *\n * The callback can be synchronous or asynchronous. Async callbacks receive\n * an AbortSignal parameter, which is automatically aborted when the effect\n * re-runs or is cleaned up, preventing stale async operations.\n *\n * @since 0.1.0\n * @param {EffectCallback} callback - Synchronous or asynchronous effect callback\n * @returns {Cleanup} - Cleanup function for the effect\n */\nconst effect = (callback: EffectCallback): Cleanup => {\n\tconst isAsync = isAsyncFunction<MaybeCleanup>(callback)\n\tlet running = false\n\tlet controller: AbortController | undefined\n\n\tconst run = watch(() =>\n\t\tobserve(() => {\n\t\t\tif (running) throw new CircularDependencyError('effect')\n\t\t\trunning = true\n\n\t\t\t// Abort any previous async operations\n\t\t\tcontroller?.abort()\n\t\t\tcontroller = undefined\n\n\t\t\tlet cleanup: MaybeCleanup | Promise<MaybeCleanup>\n\n\t\t\ttry {\n\t\t\t\tif (isAsync) {\n\t\t\t\t\t// Create AbortController for async callback\n\t\t\t\t\tcontroller = new AbortController()\n\t\t\t\t\tconst currentController = controller\n\t\t\t\t\tcallback(controller.signal)\n\t\t\t\t\t\t.then(cleanup => {\n\t\t\t\t\t\t\t// Only register cleanup if this is still the current controller\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tisFunction(cleanup) &&\n\t\t\t\t\t\t\t\tcontroller === currentController\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\trun.off(cleanup)\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.catch(error => {\n\t\t\t\t\t\t\tif (!isAbortError(error))\n\t\t\t\t\t\t\t\tconsole.error('Async effect error:', error)\n\t\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\tcleanup = (callback as () => MaybeCleanup)()\n\t\t\t\t\tif (isFunction(cleanup)) run.off(cleanup)\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tif (!isAbortError(error))\n\t\t\t\t\tconsole.error('Effect callback error:', error)\n\t\t\t}\n\n\t\t\trunning = false\n\t\t}, run),\n\t)\n\n\trun()\n\treturn () => {\n\t\tcontroller?.abort()\n\t\trun.cleanup()\n\t}\n}\n\n/* === Exports === */\n\nexport { type MaybeCleanup, type EffectCallback, effect }\n",
    "import type { ResolveResult } from './resolve'\nimport type { SignalValues, UnknownSignalRecord } from './signal'\nimport { toError } from './util'\n\n/* === Types === */\n\ntype MatchHandlers<S extends UnknownSignalRecord> = {\n\tok: (values: SignalValues<S>) => void\n\terr?: (errors: readonly Error[]) => void\n\tnil?: () => void\n}\n\n/* === Functions === */\n\n/**\n * Match on resolve result and call appropriate handler for side effects\n *\n * This is a utility function for those who prefer the handler pattern.\n * All handlers are for side effects only and return void. If you need\n * cleanup logic, use a hoisted let variable in your effect.\n *\n * @since 0.15.0\n * @param {ResolveResult<S>} result - Result from resolve()\n * @param {MatchHandlers<S>} handlers - Handlers for different states (side effects only)\n * @returns {void} - Always returns void\n */\nfunction match<S extends UnknownSignalRecord>(\n\tresult: ResolveResult<S>,\n\thandlers: MatchHandlers<S>,\n): void {\n\ttry {\n\t\tif (result.pending) handlers.nil?.()\n\t\telse if (result.errors) handlers.err?.(result.errors)\n\t\telse if (result.ok) handlers.ok(result.values)\n\t} catch (error) {\n\t\t// If handler throws, try error handler, otherwise rethrow\n\t\tif (\n\t\t\thandlers.err &&\n\t\t\t(!result.errors || !result.errors.includes(toError(error)))\n\t\t)\n\t\t\thandlers.err(\n\t\t\t\tresult.errors\n\t\t\t\t\t? [...result.errors, toError(error)]\n\t\t\t\t\t: [toError(error)],\n\t\t\t)\n\t\telse throw error\n\t}\n}\n\n/* === Exports === */\n\nexport { match, type MatchHandlers }\n",
    "import type { UnknownRecord } from './diff'\nimport type { SignalValues, UnknownSignalRecord } from './signal'\nimport { toError, UNSET } from './util'\n\n/* === Types === */\n\ntype ResolveResult<S extends UnknownSignalRecord> =\n\t| { ok: true; values: SignalValues<S>; errors?: never; pending?: never }\n\t| { ok: false; errors: readonly Error[]; values?: never; pending?: never }\n\t| { ok: false; pending: true; values?: never; errors?: never }\n\n/* === Functions === */\n\n/**\n * Resolve signal values with perfect type inference\n *\n * Always returns a discriminated union result, regardless of whether\n * handlers are provided or not. This ensures a predictable API.\n *\n * @since 0.15.0\n * @param {S} signals - Signals to resolve\n * @returns {ResolveResult<S>} - Discriminated union result\n */\nfunction resolve<S extends UnknownSignalRecord>(signals: S): ResolveResult<S> {\n\tconst errors: Error[] = []\n\tlet pending = false\n\tconst values: UnknownRecord = {}\n\n\t// Collect values and errors\n\tfor (const [key, signal] of Object.entries(signals)) {\n\t\ttry {\n\t\t\tconst value = signal.get()\n\t\t\tif (value === UNSET) pending = true\n\t\t\telse values[key] = value\n\t\t} catch (e) {\n\t\t\terrors.push(toError(e))\n\t\t}\n\t}\n\n\t// Return discriminated union\n\tif (pending) return { ok: false, pending: true }\n\tif (errors.length > 0) return { ok: false, errors }\n\treturn { ok: true, values: values as SignalValues<S> }\n}\n\n/* === Exports === */\n\nexport { resolve, type ResolveResult }\n",
    "import { isEqual } from './diff'\nimport { NullishSignalValueError } from './errors'\nimport { notify, subscribe, type Watcher } from './scheduler'\nimport { isObjectOfType, UNSET } from './util'\n\n/* === Types === */\n\ntype State<T extends {}> = {\n\t[Symbol.toStringTag]: 'State'\n\tget(): T\n\tset(v: T): void\n\tupdate(fn: (v: T) => T): void\n}\n\n/* === Constants === */\n\nconst TYPE_STATE = 'State'\n\n/* === Functions === */\n\n/**\n * Create a new state signal\n *\n * @since 0.9.0\n * @param {T} initialValue - initial value of the state\n * @returns {State<T>} - new state signal\n */\nconst state = /*#__PURE__*/ <T extends {}>(initialValue: T): State<T> => {\n\tconst watchers: Set<Watcher> = new Set()\n\tlet value: T = initialValue\n\n\tconst s: State<T> = {\n\t\t[Symbol.toStringTag]: TYPE_STATE,\n\n\t\t/**\n\t\t * Get the current value of the state\n\t\t *\n\t\t * @since 0.9.0\n\t\t * @returns {T} - current value of the state\n\t\t */\n\t\tget: (): T => {\n\t\t\tsubscribe(watchers)\n\t\t\treturn value\n\t\t},\n\n\t\t/**\n\t\t * Set a new value of the state\n\t\t *\n\t\t * @since 0.9.0\n\t\t * @param {T} v\n\t\t * @returns {void}\n\t\t */\n\t\tset: (v: T): void => {\n\t\t\tif (v == null) throw new NullishSignalValueError('state')\n\t\t\tif (isEqual(value, v)) return\n\t\t\tvalue = v\n\t\t\tnotify(watchers)\n\n\t\t\t// Setting to UNSET clears the watchers so the signal can be garbage collected\n\t\t\tif (UNSET === value) watchers.clear()\n\t\t},\n\n\t\t/**\n\t\t * Update the state with a new value using a function\n\t\t *\n\t\t * @since 0.10.0\n\t\t * @param {(v: T) => T} fn - function to update the state\n\t\t * @returns {void} - updates the state with the result of the function\n\t\t */\n\t\tupdate: (fn: (v: T) => T): void => {\n\t\t\ts.set(fn(value))\n\t\t},\n\t}\n\n\treturn s\n}\n\n/**\n * Check if the provided value is a State instance\n *\n * @since 0.9.0\n * @param {unknown} value - value to check\n * @returns {boolean} - true if the value is a State instance, false otherwise\n */\nconst isState = /*#__PURE__*/ <T extends {}>(\n\tvalue: unknown,\n): value is State<T> => isObjectOfType(value, TYPE_STATE)\n\n/* === Exports === */\n\nexport { TYPE_STATE, isState, state, type State }\n",
    "import { isComputed } from './computed'\nimport {\n\ttype ArrayToRecord,\n\tdiff,\n\ttype UnknownArray,\n\ttype UnknownRecord,\n\ttype UnknownRecordOrArray,\n} from './diff'\nimport { effect } from './effect'\nimport {\n\tInvalidSignalValueError,\n\tNullishSignalValueError,\n\tStoreKeyExistsError,\n\tStoreKeyRangeError,\n\tStoreKeyReadonlyError,\n} from './errors'\nimport {\n\tbatch,\n\ttype Cleanup,\n\tnotify,\n\tsubscribe,\n\ttype Watcher,\n} from './scheduler'\nimport { isMutableSignal, type Signal } from './signal'\nimport { isState, type State, state } from './state'\nimport {\n\tisFunction,\n\tisObjectOfType,\n\tisRecord,\n\tisSymbol,\n\trecordToArray,\n\tUNSET,\n\tvalueString,\n} from './util'\n\n/* === Types === */\n\ntype ArrayItem<T> = T extends readonly (infer U extends {})[] ? U : never\n\ntype StoreEventMap<T extends UnknownRecord | UnknownArray> = {\n\t'store-add': StoreAddEvent<T>\n\t'store-change': StoreChangeEvent<T>\n\t'store-remove': StoreRemoveEvent<T>\n\t'store-sort': StoreSortEvent\n}\n\ninterface StoreEventTarget<T extends UnknownRecord | UnknownArray>\n\textends EventTarget {\n\taddEventListener<K extends keyof StoreEventMap<T>>(\n\t\ttype: K,\n\t\tlistener: (event: StoreEventMap<T>[K]) => void,\n\t\toptions?: boolean | AddEventListenerOptions,\n\t): void\n\n\tremoveEventListener<K extends keyof StoreEventMap<T>>(\n\t\ttype: K,\n\t\tlistener: (event: StoreEventMap<T>[K]) => void,\n\t\toptions?: boolean | EventListenerOptions,\n\t): void\n\n\tdispatchEvent(event: Event): boolean\n}\n\ninterface BaseStore<T extends UnknownRecord | UnknownArray>\n\textends StoreEventTarget<T> {\n\treadonly [Symbol.toStringTag]: 'Store'\n\tget(): T\n\tset(value: T): void\n\tupdate(fn: (value: T) => T): void\n\tsort<\n\t\tU = T extends UnknownArray ? ArrayItem<T> : T[Extract<keyof T, string>],\n\t>(\n\t\tcompareFn?: (a: U, b: U) => number,\n\t): void\n\treadonly size: State<number>\n}\n\ntype RecordStore<T extends UnknownRecord> = BaseStore<T> & {\n\t[K in keyof T]: T[K] extends readonly unknown[] | Record<string, unknown>\n\t\t? Store<T[K]>\n\t\t: State<T[K]>\n} & {\n\tadd<K extends Extract<keyof T, string>>(key: K, value: T[K]): void\n\tremove<K extends Extract<keyof T, string>>(key: K): void\n\t[Symbol.iterator](): IterableIterator<\n\t\t[\n\t\t\tExtract<keyof T, string>,\n\t\t\tT[Extract<keyof T, string>] extends\n\t\t\t\t| readonly unknown[]\n\t\t\t\t| Record<string, unknown>\n\t\t\t\t? Store<T[Extract<keyof T, string>]>\n\t\t\t\t: State<T[Extract<keyof T, string>]>,\n\t\t]\n\t>\n}\n\ntype ArrayStore<T extends UnknownArray> = BaseStore<T> & {\n\treadonly length: number\n\t[n: number]: ArrayItem<T> extends\n\t\t| readonly unknown[]\n\t\t| Record<string, unknown>\n\t\t? Store<ArrayItem<T>>\n\t\t: State<ArrayItem<T>>\n\tadd(value: ArrayItem<T>): void\n\tremove(index: number): void\n\t[Symbol.iterator](): IterableIterator<\n\t\tArrayItem<T> extends readonly unknown[] | Record<string, unknown>\n\t\t\t? Store<ArrayItem<T>>\n\t\t\t: State<ArrayItem<T>>\n\t>\n\treadonly [Symbol.isConcatSpreadable]: boolean\n}\n\ninterface StoreAddEvent<T extends UnknownRecord | UnknownArray>\n\textends CustomEvent {\n\ttype: 'store-add'\n\tdetail: Partial<T>\n}\n\ninterface StoreChangeEvent<T extends UnknownRecord | UnknownArray>\n\textends CustomEvent {\n\ttype: 'store-change'\n\tdetail: Partial<T>\n}\n\ninterface StoreRemoveEvent<T extends UnknownRecord | UnknownArray>\n\textends CustomEvent {\n\ttype: 'store-remove'\n\tdetail: Partial<T>\n}\n\ninterface StoreSortEvent extends CustomEvent {\n\ttype: 'store-sort'\n\tdetail: string[]\n}\n\ntype Store<T> = T extends UnknownRecord\n\t? RecordStore<T>\n\t: T extends UnknownArray\n\t\t? ArrayStore<T>\n\t\t: never\n\n/* === Constants === */\n\nconst TYPE_STORE = 'Store'\n\nconst STORE_EVENT_ADD = 'store-add'\nconst STORE_EVENT_CHANGE = 'store-change'\nconst STORE_EVENT_REMOVE = 'store-remove'\nconst STORE_EVENT_SORT = 'store-sort'\n\n/* === Functions === */\n\n/**\n * Create a new store with deeply nested reactive properties\n *\n * Supports both objects and arrays as initial values. Arrays are converted\n * to records internally for storage but maintain their array type through\n * the .get() method, which automatically converts objects with consecutive\n * numeric keys back to arrays.\n *\n * @since 0.15.0\n * @param {T} initialValue - initial object or array value of the store\n * @returns {Store<T>} - new store with reactive properties that preserves the original type T\n */\nconst store = <T extends UnknownRecord | UnknownArray>(\n\tinitialValue: T,\n): Store<T> => {\n\tconst watchers = new Set<Watcher>()\n\tconst eventTarget = new EventTarget()\n\tconst signals = new Map<string, Signal<T[Extract<keyof T, string>] & {}>>()\n\tconst cleanups = new Map<string, Cleanup>()\n\n\t// Determine if this is an array-like store at creation time\n\tconst isArrayLike = Array.isArray(initialValue)\n\n\t// Internal state\n\tconst size = state(0)\n\n\t// Get current record\n\tconst current = () => {\n\t\tconst record: Record<string, unknown> = {}\n\t\tfor (const [key, signal] of signals) {\n\t\t\trecord[key] = signal.get()\n\t\t}\n\t\treturn record\n\t}\n\n\t// Emit event\n\tconst emit = <R>(type: keyof StoreEventMap<T>, detail: R) =>\n\t\teventTarget.dispatchEvent(new CustomEvent(type, { detail }))\n\n\t// Get sorted indexes\n\tconst getSortedIndexes = () =>\n\t\tArray.from(signals.keys())\n\t\t\t.map(k => Number(k))\n\t\t\t.filter(n => Number.isInteger(n))\n\t\t\t.sort((a, b) => a - b)\n\n\t// Validate input\n\tconst isValidValue = <T>(\n\t\tkey: string,\n\t\tvalue: T,\n\t): value is NonNullable<T> => {\n\t\tif (value == null)\n\t\t\tthrow new NullishSignalValueError(`store for key \"${key}\"`)\n\t\tif (value === UNSET) return true\n\t\tif (isSymbol(value) || isFunction(value) || isComputed(value))\n\t\t\tthrow new InvalidSignalValueError(\n\t\t\t\t`store for key \"${key}\"`,\n\t\t\t\tvalueString(value),\n\t\t\t)\n\t\treturn true\n\t}\n\n\t// Add nested signal and effect\n\tconst addProperty = <K extends Extract<keyof T, string>>(\n\t\tkey: K,\n\t\tvalue: T[K] | ArrayItem<T>,\n\t\tsingle = false,\n\t): boolean => {\n\t\tif (!isValidValue(key, value)) return false\n\t\tconst signal =\n\t\t\tisState(value) || isStore(value)\n\t\t\t\t? value\n\t\t\t\t: isRecord(value)\n\t\t\t\t\t? store(value)\n\t\t\t\t\t: Array.isArray(value)\n\t\t\t\t\t\t? store(value)\n\t\t\t\t\t\t: state(value)\n\t\t// @ts-expect-error non-matching signal types\n\t\tsignals.set(key, signal)\n\t\tconst cleanup = effect(() => {\n\t\t\tconst currentValue = signal.get()\n\t\t\tif (currentValue != null)\n\t\t\t\temit(STORE_EVENT_CHANGE, {\n\t\t\t\t\t[key]: currentValue,\n\t\t\t\t} as unknown as Partial<T>)\n\t\t})\n\t\tcleanups.set(key, cleanup)\n\n\t\tif (single) {\n\t\t\tsize.set(signals.size)\n\t\t\tnotify(watchers)\n\t\t\temit(STORE_EVENT_ADD, {\n\t\t\t\t[key]: value,\n\t\t\t} as unknown as Partial<T>)\n\t\t}\n\t\treturn true\n\t}\n\n\t// Remove nested signal and effect\n\tconst removeProperty = <K extends Extract<keyof T, string>>(\n\t\tkey: K,\n\t\tsingle = false,\n\t) => {\n\t\tconst ok = signals.delete(key)\n\t\tif (ok) {\n\t\t\tconst cleanup = cleanups.get(key)\n\t\t\tif (cleanup) cleanup()\n\t\t\tcleanups.delete(key)\n\t\t}\n\n\t\tif (single) {\n\t\t\tsize.set(signals.size)\n\t\t\tnotify(watchers)\n\t\t\temit(STORE_EVENT_REMOVE, {\n\t\t\t\t[key]: UNSET,\n\t\t\t} as unknown as Partial<T>)\n\t\t}\n\t\treturn ok\n\t}\n\n\t// Reconcile data and dispatch events\n\tconst reconcile = (\n\t\toldValue: T,\n\t\tnewValue: T,\n\t\tinitialRun?: boolean,\n\t): boolean => {\n\t\tconst changes = diff(\n\t\t\toldValue as T extends UnknownArray ? ArrayToRecord<T> : T,\n\t\t\tnewValue as T extends UnknownArray ? ArrayToRecord<T> : T,\n\t\t)\n\n\t\tbatch(() => {\n\t\t\t// Additions\n\t\t\tif (Object.keys(changes.add).length) {\n\t\t\t\tfor (const key in changes.add) {\n\t\t\t\t\tconst value = changes.add[key] ?? UNSET\n\t\t\t\t\taddProperty(\n\t\t\t\t\t\tkey as Extract<keyof T, string>,\n\t\t\t\t\t\tvalue as T[Extract<keyof T, string>] & {},\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\t// Queue initial additions event to allow listeners to be added first\n\t\t\t\tif (initialRun) {\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\temit(STORE_EVENT_ADD, changes.add as Partial<T>)\n\t\t\t\t\t}, 0)\n\t\t\t\t} else {\n\t\t\t\t\temit<Partial<T>>(STORE_EVENT_ADD, changes.add as Partial<T>)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Changes\n\t\t\tif (Object.keys(changes.change).length) {\n\t\t\t\tfor (const key in changes.change) {\n\t\t\t\t\tconst value = changes.change[key]\n\t\t\t\t\tif (!isValidValue(key, value)) continue\n\t\t\t\t\tconst signal = signals.get(key as Extract<keyof T, string>)\n\t\t\t\t\tif (isMutableSignal(signal))\n\t\t\t\t\t\tsignal.set(value as T[Extract<keyof T, string>] & {})\n\t\t\t\t\telse\n\t\t\t\t\t\tthrow new StoreKeyReadonlyError(key, valueString(value))\n\t\t\t\t}\n\t\t\t\temit(STORE_EVENT_CHANGE, changes.change as Partial<T>)\n\t\t\t}\n\n\t\t\t// Removals\n\t\t\tif (Object.keys(changes.remove).length) {\n\t\t\t\tfor (const key in changes.remove)\n\t\t\t\t\tremoveProperty(key as Extract<keyof T, string>)\n\t\t\t\temit(STORE_EVENT_REMOVE, changes.remove as Partial<T>)\n\t\t\t}\n\n\t\t\tsize.set(signals.size)\n\t\t})\n\n\t\treturn changes.changed\n\t}\n\n\t// Initialize data - convert arrays to records for internal storage\n\treconcile({} as T, initialValue, true)\n\n\t// Methods and Properties\n\tconst s: Record<string, unknown> = {\n\t\tadd: isArrayLike\n\t\t\t? (v: ArrayItem<T>): void => {\n\t\t\t\t\tconst nextIndex = signals.size\n\t\t\t\t\tconst key = String(nextIndex) as Extract<keyof T, string>\n\t\t\t\t\taddProperty(key, v, true)\n\t\t\t\t}\n\t\t\t: <K extends Extract<keyof T, string>>(k: K, v: T[K]): void => {\n\t\t\t\t\tif (!signals.has(k)) addProperty(k, v, true)\n\t\t\t\t\telse throw new StoreKeyExistsError(k, valueString(v))\n\t\t\t\t},\n\t\tget: (): T => {\n\t\t\tsubscribe(watchers)\n\t\t\treturn recordToArray(current()) as T\n\t\t},\n\t\tremove: isArrayLike\n\t\t\t? (index: number): void => {\n\t\t\t\t\tconst currentArray = recordToArray(current()) as T\n\t\t\t\t\tconst currentLength = signals.size\n\t\t\t\t\tif (\n\t\t\t\t\t\t!Array.isArray(currentArray) ||\n\t\t\t\t\t\tindex <= -currentLength ||\n\t\t\t\t\t\tindex >= currentLength\n\t\t\t\t\t)\n\t\t\t\t\t\tthrow new StoreKeyRangeError(index)\n\t\t\t\t\tconst newArray = [...currentArray]\n\t\t\t\t\tnewArray.splice(index, 1)\n\n\t\t\t\t\tif (reconcile(currentArray, newArray as unknown as T))\n\t\t\t\t\t\tnotify(watchers)\n\t\t\t\t}\n\t\t\t: <K extends Extract<keyof T, string>>(k: K): void => {\n\t\t\t\t\tif (signals.has(k)) removeProperty(k, true)\n\t\t\t\t},\n\t\tset: (v: T): void => {\n\t\t\tif (reconcile(current() as T, v)) {\n\t\t\t\tnotify(watchers)\n\t\t\t\tif (UNSET === v) watchers.clear()\n\t\t\t}\n\t\t},\n\t\tupdate: (fn: (v: T) => T): void => {\n\t\t\tconst oldValue = current()\n\t\t\tconst newValue = fn(recordToArray(oldValue) as T)\n\t\t\tif (reconcile(oldValue as T, newValue)) {\n\t\t\t\tnotify(watchers)\n\t\t\t\tif (UNSET === newValue) watchers.clear()\n\t\t\t}\n\t\t},\n\t\tsort: (\n\t\t\tcompareFn?: <\n\t\t\t\tU = T extends UnknownArray\n\t\t\t\t\t? ArrayItem<T>\n\t\t\t\t\t: T[Extract<keyof T, string>],\n\t\t\t>(\n\t\t\t\ta: U,\n\t\t\t\tb: U,\n\t\t\t) => number,\n\t\t): void => {\n\t\t\t// Get all entries as [key, value] pairs\n\t\t\tconst entries = Array.from(signals.entries())\n\t\t\t\t.map(\n\t\t\t\t\t([key, signal]) =>\n\t\t\t\t\t\t[key, signal.get()] as [\n\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\tT[Extract<keyof T, string>],\n\t\t\t\t\t\t],\n\t\t\t\t)\n\t\t\t\t.sort(\n\t\t\t\t\tcompareFn\n\t\t\t\t\t\t? (a, b) => compareFn(a[1], b[1])\n\t\t\t\t\t\t: (a, b) => String(a[1]).localeCompare(String(b[1])),\n\t\t\t\t)\n\n\t\t\t// Create array of original keys in their new sorted order\n\t\t\tconst newOrder: string[] = entries.map(([key]) => String(key))\n\t\t\tconst newSignals = new Map<\n\t\t\t\tstring,\n\t\t\t\tSignal<T[Extract<keyof T, string>] & {}>\n\t\t\t>()\n\n\t\t\tentries.forEach(([key], newIndex) => {\n\t\t\t\tconst oldKey = String(key)\n\t\t\t\tconst newKey = isArrayLike ? String(newIndex) : String(key)\n\n\t\t\t\tconst signal = signals.get(oldKey)\n\t\t\t\tif (signal) newSignals.set(newKey, signal)\n\t\t\t})\n\n\t\t\t// Replace signals map\n\t\t\tsignals.clear()\n\t\t\tnewSignals.forEach((signal, key) => signals.set(key, signal))\n\t\t\tnotify(watchers)\n\t\t\temit(STORE_EVENT_SORT, newOrder)\n\t\t},\n\t\taddEventListener: eventTarget.addEventListener.bind(eventTarget),\n\t\tremoveEventListener: eventTarget.removeEventListener.bind(eventTarget),\n\t\tdispatchEvent: eventTarget.dispatchEvent.bind(eventTarget),\n\t\tsize,\n\t}\n\n\t// Return proxy directly with integrated signal methods\n\treturn new Proxy({} as Store<T>, {\n\t\tget(_target, prop) {\n\t\t\t// Symbols\n\t\t\tif (prop === Symbol.toStringTag) return TYPE_STORE\n\t\t\tif (prop === Symbol.isConcatSpreadable) return isArrayLike\n\t\t\tif (prop === Symbol.iterator)\n\t\t\t\treturn isArrayLike\n\t\t\t\t\t? function* () {\n\t\t\t\t\t\t\tconst indexes = getSortedIndexes()\n\t\t\t\t\t\t\tfor (const index of indexes) {\n\t\t\t\t\t\t\t\tconst signal = signals.get(\n\t\t\t\t\t\t\t\t\tString(index) as Extract<keyof T, string>,\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\tif (signal) yield signal\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t: function* () {\n\t\t\t\t\t\t\tfor (const [key, signal] of signals)\n\t\t\t\t\t\t\t\tyield [key, signal]\n\t\t\t\t\t\t}\n\t\t\tif (isSymbol(prop)) return undefined\n\n\t\t\t// Methods and Properties\n\t\t\tif (prop in s) return s[prop]\n\t\t\tif (prop === 'length' && isArrayLike) {\n\t\t\t\tsubscribe(watchers)\n\t\t\t\treturn size.get()\n\t\t\t}\n\n\t\t\t// Signals\n\t\t\treturn signals.get(prop as Extract<keyof T, string>)\n\t\t},\n\t\thas(_target, prop) {\n\t\t\tconst stringProp = String(prop)\n\t\t\treturn (\n\t\t\t\t(stringProp &&\n\t\t\t\t\tsignals.has(stringProp as Extract<keyof T, string>)) ||\n\t\t\t\tObject.keys(s).includes(stringProp) ||\n\t\t\t\tprop === Symbol.toStringTag ||\n\t\t\t\tprop === Symbol.iterator ||\n\t\t\t\tprop === Symbol.isConcatSpreadable ||\n\t\t\t\t(prop === 'length' && isArrayLike)\n\t\t\t)\n\t\t},\n\t\townKeys() {\n\t\t\treturn isArrayLike\n\t\t\t\t? getSortedIndexes()\n\t\t\t\t\t\t.map(key => String(key))\n\t\t\t\t\t\t.concat(['length'])\n\t\t\t\t: Array.from(signals.keys()).map(key => String(key))\n\t\t},\n\t\tgetOwnPropertyDescriptor(_target, prop) {\n\t\t\tconst nonEnumerable = <T>(value: T) => ({\n\t\t\t\tenumerable: false,\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: false,\n\t\t\t\tvalue,\n\t\t\t})\n\n\t\t\tif (prop === 'length' && isArrayLike)\n\t\t\t\treturn {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\twritable: false,\n\t\t\t\t\tvalue: size.get(),\n\t\t\t\t}\n\t\t\tif (prop === Symbol.isConcatSpreadable)\n\t\t\t\treturn nonEnumerable(isArrayLike)\n\t\t\tif (prop === Symbol.toStringTag) return nonEnumerable(TYPE_STORE)\n\t\t\tif (isSymbol(prop)) return undefined\n\n\t\t\tif (Object.keys(s).includes(prop)) return nonEnumerable(s[prop])\n\n\t\t\tconst signal = signals.get(prop as Extract<keyof T, string>)\n\t\t\treturn signal\n\t\t\t\t? {\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\twritable: true,\n\t\t\t\t\t\tvalue: signal,\n\t\t\t\t\t}\n\t\t\t\t: undefined\n\t\t},\n\t})\n}\n\n/**\n * Check if the provided value is a Store instance\n *\n * @since 0.15.0\n * @param {unknown} value - value to check\n * @returns {boolean} - true if the value is a Store instance, false otherwise\n */\nconst isStore = <T extends UnknownRecordOrArray>(\n\tvalue: unknown,\n): value is Store<T> => isObjectOfType(value, TYPE_STORE)\n\n/* === Exports === */\n\nexport {\n\tTYPE_STORE,\n\tisStore,\n\tstore,\n\ttype Store,\n\ttype StoreAddEvent,\n\ttype StoreChangeEvent,\n\ttype StoreRemoveEvent,\n\ttype StoreSortEvent,\n\ttype StoreEventMap,\n}\n",
    "import {\n\ttype Computed,\n\ttype ComputedCallback,\n\tcomputed,\n\tisComputed,\n\tisComputedCallback,\n} from './computed'\nimport { isState, type State, state } from './state'\nimport { isStore, type Store, store } from './store'\nimport { isRecord } from './util'\n\n/* === Types === */\n\ntype Signal<T extends {}> = {\n\tget(): T\n}\n\ntype UnknownSignalRecord = Record<string, Signal<unknown & {}>>\n\ntype SignalValues<S extends UnknownSignalRecord> = {\n\t[K in keyof S]: S[K] extends Signal<infer T> ? T : never\n}\n\n/* === Functions === */\n\n/**\n * Check whether a value is a Signal\n *\n * @since 0.9.0\n * @param {unknown} value - value to check\n * @returns {boolean} - true if value is a Signal, false otherwise\n */\nconst isSignal = /*#__PURE__*/ <T extends {}>(\n\tvalue: unknown,\n): value is Signal<T> => isState(value) || isComputed(value) || isStore(value)\n\n/**\n * Check whether a value is a State or Store\n *\n * @since 0.15.2\n * @param {unknown} value - value to check\n * @returns {boolean} - true if value is a State or Store, false otherwise\n */\nconst isMutableSignal = /*#__PURE__*/ <T extends {}>(\n\tvalue: unknown,\n): value is State<T> | Store<T> => isState(value) || isStore(value)\n\n/**\n * Convert a value to a Signal if it's not already a Signal\n *\n * @since 0.9.6\n * @param {T} value - value to convert\n * @returns {Signal<T>} - Signal instance\n */\nfunction toSignal<T extends {}>(\n\tvalue: T,\n): T extends Store<infer U>\n\t? Store<U>\n\t: T extends State<infer U>\n\t\t? State<U>\n\t\t: T extends Computed<infer U>\n\t\t\t? Computed<U>\n\t\t\t: T extends Signal<infer U>\n\t\t\t\t? Signal<U>\n\t\t\t\t: T extends ReadonlyArray<infer U extends {}>\n\t\t\t\t\t? Store<U[]>\n\t\t\t\t\t: T extends Record<string, unknown & {}>\n\t\t\t\t\t\t? Store<{ [K in keyof T]: T[K] }>\n\t\t\t\t\t\t: T extends ComputedCallback<infer U extends {}>\n\t\t\t\t\t\t\t? Computed<U>\n\t\t\t\t\t\t\t: State<T>\nfunction toSignal<T extends {}>(value: T) {\n\tif (isSignal<T>(value)) return value\n\tif (isComputedCallback(value)) return computed(value)\n\tif (Array.isArray(value) || isRecord(value)) return store(value)\n\treturn state(value)\n}\n\n/* === Exports === */\n\nexport {\n\ttype Signal,\n\ttype UnknownSignalRecord,\n\ttype SignalValues,\n\tisSignal,\n\tisMutableSignal,\n\ttoSignal,\n}\n",
    "import { isFunction, isString } from '@zeix/cause-effect'\n\n/* === Types === */\n\ntype LogLevel = 'debug' | 'info' | 'warn' | 'error'\n\n/* === Constants === */\n\nconst DEV_MODE = process.env.DEV_MODE\n\nconst LOG_DEBUG: LogLevel = 'debug'\nconst LOG_INFO: LogLevel = 'info'\nconst LOG_WARN: LogLevel = 'warn'\nconst LOG_ERROR: LogLevel = 'error'\n\n/* === Internal Functions === */\n\n/**\n * Return selector string for the id of the element\n *\n * @since 0.7.0\n * @param {string | undefined | null} id\n * @returns {string} - id string for the element with '#' prefix\n */\nconst idString = (id: string | undefined | null): string => (id ? `#${id}` : '')\n\n/**\n * Return a selector string for classes of the element\n *\n * @since 0.7.0\n * @param {DOMTokenList | undefined | null} classList - DOMTokenList to convert to a string\n * @returns {string} - class string for the DOMTokenList with '.' prefix if any\n */\nconst classString = (classList: DOMTokenList | undefined | null): string =>\n\tclassList?.length ? `.${Array.from(classList).join('.')}` : ''\n\n/* === Exported Functions === */\n\nconst hasMethod = /*#__PURE__*/ <T extends object, K extends PropertyKey, R>(\n\tobj: T,\n\tmethodName: K,\n): obj is T & Record<K, (...args: any[]) => R> =>\n\tisString(methodName) &&\n\tmethodName in obj &&\n\tisFunction<R>((obj as any)[methodName])\n\n/**\n * Check if a node is an Element\n *\n * @param {Node} node - node to check\n * @returns {boolean} - `true` if node is an element node, otherwise `false`\n */\nconst isElement = /*#__PURE__*/ (node: Node): node is Element =>\n\tnode.nodeType === Node.ELEMENT_NODE\n\n/**\n * Check whether an element is a custom element\n *\n * @param {E} element - Element to check\n * @returns {boolean} - True if the element is a custom element\n */\nconst isCustomElement = /*#__PURE__*/ <E extends Element>(\n\telement: E,\n): boolean => element.localName.includes('-')\n\n/**\n * Check whether a custom element is upgraded or a regular element\n *\n * @param {E} element - Element to check\n * @returns {boolean} - True if the element is an upgraded custom element or a regular element\n */\nconst isUpgradedComponent = <E extends Element>(element: E): boolean => {\n\tif (!isCustomElement(element)) return true\n\tconst ctor = customElements.get(element.localName)\n\treturn !!ctor && element instanceof ctor\n}\n\n/**\n * Return a string representation of the Element instance\n *\n * @since 0.7.0\n * @param {Element | undefined | null} el\n * @returns {string}\n */\nconst elementName = /*#__PURE__*/ (el: Element | undefined | null): string =>\n\tel\n\t\t? `<${el.localName}${idString(el.id)}${classString(el.classList)}>`\n\t\t: '<unknown>'\n\n/**\n * Return a string representation of a JavaScript variable\n *\n * @since 0.7.0\n * @param {unknown} value\n * @returns {string}\n */\nconst valueString = /*#__PURE__*/ (value: unknown): string =>\n\tisString(value)\n\t\t? `\"${value}\"`\n\t\t: !!value && typeof value === 'object'\n\t\t\t? JSON.stringify(value)\n\t\t\t: String(value)\n\n/**\n * Return a detailed type of a JavaScript variable\n *\n * @since 0.11.0\n * @param {unknown} value\n * @returns {string}\n */\nconst typeString = /*#__PURE__*/ (value: unknown): string => {\n\tif (value === null) return 'null'\n\tif (typeof value !== 'object') return typeof value\n\tif (Array.isArray(value)) return 'Array'\n\n\t// Check for Symbol.toStringTag\n\tif (Symbol.toStringTag in Object(value)) {\n\t\treturn (value as any)[Symbol.toStringTag]\n\t}\n\n\t// For other objects, return the constructor name if available\n\treturn value.constructor?.name || 'Object'\n}\n\n/**\n * Log a message to the console with the specified level\n *\n * @since 0.7.0\n * @param {T} value - value to inspect\n * @param {string} msg - message to log\n * @param {LogLevel} level - log level\n * @returns {T} - value passed through\n */\nconst log = <T>(value: T, msg: string, level: LogLevel = LOG_DEBUG): T => {\n\tif (DEV_MODE || ([LOG_ERROR, LOG_WARN] as LogLevel[]).includes(level))\n\t\tconsole[level](msg, value)\n\treturn value\n}\n\nexport {\n\ttype LogLevel,\n\thasMethod,\n\tisElement,\n\tisCustomElement,\n\tisUpgradedComponent,\n\tlog,\n\telementName,\n\tvalueString,\n\ttypeString,\n\tDEV_MODE,\n\tLOG_DEBUG,\n\tLOG_INFO,\n\tLOG_WARN,\n\tLOG_ERROR,\n}\n",
    "import { elementName, valueString } from './util'\n\n/* === Error Classes === */\n\n/**\n * Error thrown when a circular dependency is detected in a selection signal\n *\n * @since 0.14.0\n */\nclass CircularMutationError extends Error {\n\t/**\n\t * @param {HTMLElement} host - Host component\n\t * @param {string} selector - Selector used to find the elements\n\t */\n\tconstructor(host: HTMLElement, selector: string) {\n\t\tsuper(\n\t\t\t`Circular dependency detected in selection signal for component ${elementName(host)} with selector \"${selector}\"`,\n\t\t)\n\t\tthis.name = 'CircularMutationError'\n\t}\n}\n\n/**\n * Error thrown when component name violates rules for custom element names\n *\n * @since 0.14.0\n */\nclass InvalidComponentNameError extends TypeError {\n\t/**\n\t * @param {string} component - Component name\n\t */\n\tconstructor(component: string) {\n\t\tsuper(\n\t\t\t`Invalid component name \"${component}\". Custom element names must contain a hyphen, start with a lowercase letter, and contain only lowercase letters, numbers, and hyphens.`,\n\t\t)\n\t\tthis.name = 'InvalidComponentNameError'\n\t}\n}\n\n/**\n * Error thrown when trying to assign a property name that conflicts with reserved words or inherited HTMLElement properties\n *\n * @since 0.14.0\n */\nclass InvalidPropertyNameError extends TypeError {\n\t/**\n\t * @param {string} component - Component name\n\t * @param {string} prop - Property name\n\t * @param {string} reason - Explanation why the property is invalid\n\t */\n\tconstructor(component: string, prop: string, reason: string) {\n\t\tsuper(\n\t\t\t`Invalid property name \"${prop}\" for component <${component}>. ${reason}`,\n\t\t)\n\t\tthis.name = 'InvalidPropertyNameError'\n\t}\n}\n\n/**\n * Error thrown when setup function does not return effects\n *\n * @since 0.14.0\n */\nclass InvalidEffectsError extends TypeError {\n\t/**\n\t * @param {HTMLElement} host - Host component\n\t * @param {Error} cause - Error that caused the invalid effects\n\t */\n\tconstructor(host: HTMLElement, cause?: Error) {\n\t\tsuper(\n\t\t\t`Invalid effects in component ${elementName(host)}. Effects must be an array of effects, a single effect function, or a Promise that resolves to effects.`,\n\t\t)\n\t\tthis.name = 'InvalidEffectsError'\n\t\tif (cause) this.cause = cause\n\t}\n}\n\n/**\n * Error thrown when a required desacendent element does not exist in a component's DOM subtree\n *\n * @since 0.14.0\n */\nclass MissingElementError extends Error {\n\t/**\n\t * @param {HTMLElement} host - Host component\n\t * @param {string} selector - Selector used to find the elements\n\t * @param {string} required - Explanation why the element is required\n\t */\n\tconstructor(host: HTMLElement, selector: string, required: string) {\n\t\tsuper(\n\t\t\t`Missing required element <${selector}> in component ${elementName(host)}. ${required}`,\n\t\t)\n\t\tthis.name = 'MissingElementError'\n\t}\n}\n\n/**\n * Error when a component's dependencies are not met within a specified timeout\n *\n * @since 0.14.0\n */\nclass DependencyTimeoutError extends Error {\n\t/**\n\t * @param {HTMLElement} host - Host component\n\t * @param {string[]} missing - List of missing dependencies\n\t */\n\tconstructor(host: HTMLElement, missing: string[]) {\n\t\tsuper(\n\t\t\t`Timeout waiting for: [${missing.join(', ')}] in component ${elementName(host)}.`,\n\t\t)\n\t\tthis.name = 'DependencyTimeoutError'\n\t}\n}\n\n/**\n * Error thrown when reactives passed to a component are invalid\n *\n * @since 0.15.0\n */\nclass InvalidReactivesError extends TypeError {\n\t/**\n\t * @param {HTMLElement} host - Host component\n\t * @param {HTMLElement} target - Target component\n\t * @param {unknown} reactives - Reactives passed to the component\n\t */\n\tconstructor(host: HTMLElement, target: HTMLElement, reactives: unknown) {\n\t\tsuper(\n\t\t\t`Expected reactives passed from ${elementName(host)} to ${elementName(target)} to be a record of signals, reactive property names or functions. Got ${valueString(reactives)}.`,\n\t\t)\n\t\tthis.name = 'InvalidReactivesError'\n\t}\n}\n\n/**\n * Error thrown when target element is not a custom element as expected\n *\n * @since 0.15.0\n */\nclass InvalidCustomElementError extends TypeError {\n\t/**\n\t * @param {HTMLElement} target - Target component\n\t * @param {string} where - Location where the error occurred\n\t */\n\tconstructor(target: HTMLElement, where: string) {\n\t\tsuper(\n\t\t\t`Target ${elementName(target)} is not a custom element in ${where}.`,\n\t\t)\n\t\tthis.name = 'InvalidCustomElementError'\n\t}\n}\n\nexport {\n\tCircularMutationError,\n\tDependencyTimeoutError,\n\tInvalidComponentNameError,\n\tInvalidCustomElementError,\n\tInvalidPropertyNameError,\n\tInvalidEffectsError,\n\tInvalidReactivesError,\n\tMissingElementError,\n}\n",
    "import {\n\ttype Cleanup,\n\tcomputed,\n\tisComputedCallback,\n\tisFunction,\n\tisRecord,\n\tisSignal,\n\tisString,\n\ttype MaybeCleanup,\n\ttype Signal,\n\tUNSET,\n} from '@zeix/cause-effect'\n\nimport type { Component, ComponentProps } from '../component'\nimport type { LooseExtractor } from './dom'\nimport {\n\tInvalidCustomElementError,\n\tInvalidEffectsError,\n\tInvalidReactivesError,\n} from './errors'\nimport {\n\telementName,\n\tisCustomElement,\n\tLOG_ERROR,\n\tlog,\n\tvalueString,\n} from './util'\n\n/* === Types === */\n\ntype Effect<P extends ComponentProps, E extends Element> = (\n\thost: Component<P>,\n\telement: E,\n) => MaybeCleanup\n\ntype Effects<P extends ComponentProps, E extends Element> =\n\t| Effect<P, E>\n\t| Effect<P, E>[]\n\t| Promise<Effect<P, E>>\n\t| Promise<Effect<P, E>[]>\n\ntype Reactive<T, P extends ComponentProps, E extends Element = HTMLElement> =\n\t| keyof P\n\t| Signal<T & {}>\n\t| LooseExtractor<T, E>\n\ntype PassedProp<\n\tT,\n\tP extends ComponentProps,\n\tE extends HTMLElement = HTMLElement,\n> = Reactive<T, P, E> | [Reactive<T, P, E>, (value: T) => void]\n\ntype PassedProps<P extends ComponentProps, Q extends ComponentProps> = {\n\t[K in keyof Q & string]?: PassedProp<Q[K], P, Component<Q>>\n}\n\n/* === Constants === */\n\n// Special value explicitly marked as any so it can be used as signal value of any type\nconst RESET: any = Symbol('RESET')\n\n/* === Exported Functions === */\n\n/**\n * Run one or more effect functions on a component's element\n *\n * @since 0.14.0\n * @param {Effects<P, E>} effects - Effect functions to run\n * @param {Component<P>} host - Component host element\n * @param {E} target - Target element\n * @returns {Cleanup} - Cleanup function that runs collected cleanup functions\n * @throws {InvalidEffectsError} - If the effects are invalid\n */\nconst runEffects = <P extends ComponentProps, E extends Element = Component<P>>(\n\teffects: Effects<P, E>,\n\thost: Component<P>,\n\ttarget: E = host as unknown as E,\n): void | Cleanup => {\n\ttry {\n\t\tif (effects instanceof Promise) throw effects\n\t\tif (!Array.isArray(effects)) return effects(host, target)\n\t\tconst cleanups = effects\n\t\t\t.filter(isFunction)\n\t\t\t.map(effect => effect(host, target))\n\t\treturn () => {\n\t\t\tcleanups.filter(isFunction).forEach(cleanup => cleanup())\n\t\t\tcleanups.length = 0\n\t\t}\n\t} catch (error) {\n\t\tif (error instanceof Promise) {\n\t\t\terror.then(() => runEffects(effects, host, target))\n\t\t} else {\n\t\t\tthrow new InvalidEffectsError(\n\t\t\t\thost,\n\t\t\t\terror instanceof Error ? error : new Error(String(error)),\n\t\t\t)\n\t\t}\n\t}\n}\n\nconst resolveReactive = <\n\tT extends {},\n\tP extends ComponentProps,\n\tE extends Element = Component<P>,\n>(\n\treactive: Reactive<T, P, E>,\n\thost: Component<P>,\n\ttarget: E,\n\tcontext?: string,\n): T => {\n\ttry {\n\t\treturn isString(reactive)\n\t\t\t? (host[reactive] as unknown as T)\n\t\t\t: isSignal(reactive)\n\t\t\t\t? reactive.get()\n\t\t\t\t: isFunction(reactive)\n\t\t\t\t\t? (reactive(target) as unknown as T)\n\t\t\t\t\t: RESET\n\t} catch (error) {\n\t\tif (context) {\n\t\t\tlog(\n\t\t\t\terror,\n\t\t\t\t`Failed to resolve value of ${valueString(reactive)}${\n\t\t\t\t\tcontext ? ` for ${context}` : ''\n\t\t\t\t} in ${elementName(target)}${\n\t\t\t\t\t(host as unknown as E) !== target\n\t\t\t\t\t\t? ` in ${elementName(host)}`\n\t\t\t\t\t\t: ''\n\t\t\t\t}`,\n\t\t\t\tLOG_ERROR,\n\t\t\t)\n\t\t}\n\t\treturn RESET\n\t}\n}\n\n/**\n * Effect for passing reactive values to a descendant El Truco component.\n *\n * @since 0.15.0\n * @param {MutableReactives<Component<Q>, P>} props - Reactive values to pass\n * @returns {Effect<P, Component<Q>>} Effect function that passes reactive values to the descendant component\n * @throws {InvalidCustomElementError} When the target element is not a valid custom element\n * @throws {InvalidReactivesError} When the provided reactives is not a record of signals, reactive property names or functions\n * @throws {Error} When passing signals failed for some other reason\n */\nconst pass =\n\t<P extends ComponentProps, Q extends ComponentProps>(\n\t\tprops:\n\t\t\t| PassedProps<P, Q>\n\t\t\t| ((target: Component<Q>) => PassedProps<P, Q>),\n\t): Effect<P, Component<Q>> =>\n\t(host, target): MaybeCleanup => {\n\t\tif (!isCustomElement(target))\n\t\t\tthrow new InvalidCustomElementError(\n\t\t\t\ttarget,\n\t\t\t\t`pass from ${elementName(host)}`,\n\t\t\t)\n\t\tconst reactives = isFunction(props) ? props(target) : props\n\t\tif (!isRecord(reactives))\n\t\t\tthrow new InvalidReactivesError(host, target, reactives)\n\n\t\tconst resetProperties: PropertyDescriptorMap = {}\n\n\t\t// Return getter from signal, reactive property name or function\n\t\tconst getGetter = (value: unknown) => {\n\t\t\tif (isSignal(value)) return value.get\n\t\t\tconst fn =\n\t\t\t\tisString(value) && value in host\n\t\t\t\t\t? () => host[value as keyof typeof host]\n\t\t\t\t\t: isComputedCallback(value)\n\t\t\t\t\t\t? value\n\t\t\t\t\t\t: undefined\n\t\t\treturn fn ? computed(fn).get : undefined\n\t\t}\n\n\t\t// Iterate through reactives\n\t\tfor (const [prop, reactive] of Object.entries(reactives)) {\n\t\t\tif (reactive == null) continue\n\n\t\t\t// Ensure target has configurable property\n\t\t\tconst descriptor = Object.getOwnPropertyDescriptor(target, prop)\n\t\t\tif (!(prop in target) || !descriptor?.configurable) continue\n\n\t\t\t// Determine getter\tand setter\n\t\t\tconst applied =\n\t\t\t\tisFunction(reactive) && reactive.length === 1\n\t\t\t\t\t? reactive(target)\n\t\t\t\t\t: reactive\n\t\t\tconst isArray = Array.isArray(applied) && applied.length === 2\n\t\t\tconst getter = getGetter(isArray ? applied[0] : applied)\n\t\t\tconst setter =\n\t\t\t\tisArray && isFunction(applied[1]) ? applied[1] : undefined\n\t\t\tif (!getter) continue\n\n\t\t\t// Store original descriptor for reset and assign new descriptor\n\t\t\tresetProperties[prop] = descriptor\n\t\t\tObject.defineProperty(target, prop, {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tget: getter,\n\t\t\t\tset: setter,\n\t\t\t})\n\n\t\t\t// Unset previous value so subscribers are notified\n\t\t\tdescriptor.set?.call(target, UNSET)\n\t\t}\n\n\t\t// Reset to original descriptors on cleanup\n\t\treturn () => {\n\t\t\tObject.defineProperties(target, resetProperties)\n\t\t}\n\t}\n\n/* === Exports === */\n\nexport {\n\ttype Effect,\n\ttype Effects,\n\ttype Reactive,\n\ttype PassedProp,\n\ttype PassedProps,\n\tpass,\n\tRESET,\n\tresolveReactive,\n\trunEffects,\n}\n",
    "import {\n\ttype Cleanup,\n\ttype Computed,\n\tisFunction,\n\tisString,\n\ttype MaybeCleanup,\n\tnotify,\n\tsubscribe,\n\tTYPE_COMPUTED,\n\tUNSET,\n\ttype Watcher,\n} from '@zeix/cause-effect'\n\nimport type { Component, ComponentProps } from '../component'\nimport { CircularMutationError, MissingElementError } from './errors'\nimport { type Effects, runEffects } from './reactive'\nimport { isCustomElement, isElement } from './util'\n\n/* === Types === */\n\n// Pull the part before the first \".\", \"#\", \":\", or \"[\".\ntype ExtractTag<S extends string> = S extends `${infer T}.${string}`\n\t? T\n\t: S extends `${infer T}#${string}`\n\t\t? T\n\t\t: S extends `${infer T}:${string}`\n\t\t\t? T\n\t\t\t: S extends `${infer T}[${string}`\n\t\t\t\t? T\n\t\t\t\t: S\n\n// Normalize to lowercase and ensure it's a known HTML tag.\ntype KnownTag<S extends string> = Lowercase<ExtractTag<S>> extends\n\t| keyof HTMLElementTagNameMap\n\t| keyof SVGElementTagNameMap\n\t| keyof MathMLElementTagNameMap\n\t? Lowercase<ExtractTag<S>>\n\t: never\n\n// Map the selector string to the concrete element type.\n// If we can't statically prove the tag is known, fall back to HTMLElement.\ntype ElementFromSelector<S extends string> = KnownTag<S> extends never\n\t? HTMLElement\n\t: KnownTag<S> extends keyof HTMLElementTagNameMap\n\t\t? HTMLElementTagNameMap[KnownTag<S>]\n\t\t: KnownTag<S> extends keyof SVGElementTagNameMap\n\t\t\t? SVGElementTagNameMap[KnownTag<S>]\n\t\t\t: KnownTag<S> extends keyof MathMLElementTagNameMap\n\t\t\t\t? MathMLElementTagNameMap[KnownTag<S>]\n\t\t\t\t: HTMLElement\n\ntype Extractor<T extends {}, E extends Element = HTMLElement> = (\n\telement: E,\n) => T\n\ntype LooseExtractor<T, E extends Element = HTMLElement> = (\n\telement: E,\n) => T | null | undefined\n\ntype Parser<T extends {}, E extends Element = HTMLElement> = (\n\telement: E,\n\tvalue: string | null | undefined,\n\told?: string | null,\n) => T\n\ntype Fallback<T extends {}, E extends Element = HTMLElement> =\n\t| T\n\t| Extractor<T, E>\n\ntype ParserOrFallback<T extends {}, E extends Element = HTMLElement> =\n\t| Parser<T, E>\n\t| Fallback<T, E>\n\ntype ElementUsage = {\n\t<S extends string>(selector: S, required: string): ElementFromSelector<S>\n\t<S extends string>(selector: S): ElementFromSelector<S> | null\n\t<E extends Element>(selector: string, required: string): E\n\t<E extends Element>(selector: string): E | null\n}\n\ntype ElementsUsage = {\n\t<S extends string>(selector: S, required?: string): ElementFromSelector<S>[]\n\t<E extends Element>(selector: string, required?: string): E[]\n}\n\ntype ElementEffects<P extends ComponentProps> = {\n\t<S extends string>(\n\t\tselector: S,\n\t\teffects: Effects<P, ElementFromSelector<S>>,\n\t\trequired?: string,\n\t): () => MaybeCleanup\n\t<E extends Element>(\n\t\tselector: string,\n\t\teffects: Effects<P, E>,\n\t\trequired?: string,\n\t): () => MaybeCleanup\n}\n\ntype Helpers<P extends ComponentProps> = {\n\tuseElement: ElementUsage\n\tuseElements: ElementsUsage\n\tfirst: ElementEffects<P>\n\tall: ElementEffects<P>\n}\n\n/* === Internal Functions === */\n\n/**\n * Extract attribute names from a CSS selector\n * Handles various attribute selector formats: .class, #id, [attr], [attr=value], [attr^=value], etc.\n *\n * @param {string} selector - CSS selector to parse\n * @returns {string[]} - Array of attribute names found in the selector\n */\nconst extractAttributes = (selector: string): string[] => {\n\tconst attributes = new Set<string>()\n\tif (selector.includes('.')) attributes.add('class')\n\tif (selector.includes('#')) attributes.add('id')\n\tif (selector.includes('[')) {\n\t\tconst parts = selector.split('[')\n\t\tfor (let i = 1; i < parts.length; i++) {\n\t\t\tconst part = parts[i]\n\t\t\tif (!part.includes(']')) continue\n\t\t\tconst attrName = part\n\t\t\t\t.split('=')[0]\n\t\t\t\t.trim()\n\t\t\t\t.replace(/[^a-zA-Z0-9_-]/g, '')\n\t\t\tif (attrName) attributes.add(attrName)\n\t\t}\n\t}\n\treturn [...attributes]\n}\n\n/**\n * Compare two arrays of elements to determine if they contain the same elements\n *\n * @param {E[]} arr1 - First array of elements to compare\n * @param {E[]} arr2 - Second array of elements to compare\n * @returns {boolean} - True if arrays contain the same elements, false otherwise\n */\nconst areElementArraysEqual = <E extends Element>(\n\tarr1: E[],\n\tarr2: E[],\n): boolean => {\n\tif (arr1.length !== arr2.length) return false\n\tconst set1 = new Set(arr1)\n\tfor (const el of arr2) {\n\t\tif (!set1.has(el)) return false\n\t}\n\treturn true\n}\n\n/* === Exported Functions === */\n\n/**\n * Check if a value is a string parser\n *\n * @since 0.14.0\n * @param {unknown} value - Value to check if it is a string parser\n * @returns {boolean} True if the value is a string parser, false otherwise\n */\nconst isParser = <T extends {}, E extends Element = HTMLElement>(\n\tvalue: unknown,\n): value is Parser<T, E> => isFunction(value) && value.length >= 2\n\n/**\n * Get a fallback value for an element\n *\n * @since 0.14.0\n * @param {E} element - Element to get fallback value for\n * @param {ParserOrFallback<T, E>} fallback - Fallback value or parser function\n * @returns {T} Fallback value or parsed value\n */\nconst getFallback = <T extends {}, E extends Element = HTMLElement>(\n\telement: E,\n\tfallback: ParserOrFallback<T, E>,\n): T => (isFunction(fallback) ? fallback(element) : fallback) as T\n\n/**\n * Get a value from elements in the DOM\n *\n * @since 0.14.0\n * @param {S} extractors - An object of extractor functions for selectors as keys to get a value from\n * @param {ParserOrFallback<T, E>} fallback - Fallback value or parser function\n * @returns {LooseExtractor<T | string | null | undefined, C>} Loose extractor function to apply to the host element\n */\nconst fromDOM =\n\t<\n\t\tT extends {},\n\t\tC extends HTMLElement = HTMLElement,\n\t\tS extends {\n\t\t\t[K in keyof S & string]: LooseExtractor<\n\t\t\t\tT | string,\n\t\t\t\tElementFromSelector<K>\n\t\t\t>\n\t\t} = {},\n\t>(\n\t\textractors: S,\n\t\tfallback: ParserOrFallback<T, C>,\n\t): Extractor<T, C> =>\n\t(host: C): T => {\n\t\tconst root = host.shadowRoot ?? host\n\n\t\tconst fromFirst = <K extends keyof S & string>(\n\t\t\tselector: K,\n\t\t\textractor: LooseExtractor<T | string, ElementFromSelector<K>>,\n\t\t) => {\n\t\t\tconst target = root.querySelector<ElementFromSelector<K>>(selector)\n\t\t\tif (!target) return\n\t\t\tconst value = extractor(target)\n\t\t\tif (value != null) return value\n\t\t}\n\n\t\tlet value: T | string | null | undefined = undefined\n\t\tfor (const [selector, extractor] of Object.entries(extractors)) {\n\t\t\tvalue = fromFirst(\n\t\t\t\tselector as keyof S & string,\n\t\t\t\textractor as LooseExtractor<\n\t\t\t\t\tT,\n\t\t\t\t\tElementFromSelector<keyof S & string>\n\t\t\t\t>,\n\t\t\t)\n\t\t\tif (value != null) break\n\t\t}\n\t\treturn isString(value) && isParser<T, C>(fallback)\n\t\t\t? fallback(host, value)\n\t\t\t: ((value as T) ?? getFallback(host, fallback))\n\t}\n\n/**\n * Observe a DOM subtree with a mutation observer\n *\n * @since 0.12.2\n * @param {ParentNode} parent - parent node\n * @param {string} selector - selector for matching elements to observe\n * @param {MutationCallback} callback - mutation callback\n * @returns {MutationObserver} - the created mutation observer\n */\nconst observeSubtree = (\n\tparent: ParentNode,\n\tselector: string,\n\tcallback: MutationCallback,\n): MutationObserver => {\n\tconst observer = new MutationObserver(callback)\n\tconst observerConfig: MutationObserverInit = {\n\t\tchildList: true,\n\t\tsubtree: true,\n\t}\n\tconst observedAttributes = extractAttributes(selector)\n\tif (observedAttributes.length) {\n\t\tobserverConfig.attributes = true\n\t\tobserverConfig.attributeFilter = observedAttributes\n\t}\n\tobserver.observe(parent, observerConfig)\n\treturn observer\n}\n\n/**\n * Create partially applied helper functions to get descendants and run effects on them\n *\n * @since 0.14.0\n * @param {Component<P>} host - Host component\n * @returns {ElementSelectors<P>} - Helper functions for selecting descendants\n */\nconst getHelpers = <P extends ComponentProps>(\n\thost: Component<P>,\n): [Helpers<P>, () => string[]] => {\n\tconst root = host.shadowRoot ?? host\n\tconst dependencies: Set<string> = new Set()\n\n\t/**\n\t * Get the first descendant element matching a selector\n\t * If the element is a custom elements it will be added to dependencies\n\t *\n\t * @since 0.14.0\n\t * @param {S} selector - Selector for element to check for\n\t * @param {string} [required] - Optional reason for the assertion; if provided, throws on missing element\n\t * @returns {ElementFromSelector<S> | null} First matching descendant element, or null if not found and not required\n\t * @throws {MissingElementError} - Thrown when the element is required but not found\n\t */\n\tfunction useElement<S extends string>(\n\t\tselector: S,\n\t\trequired: string,\n\t): ElementFromSelector<S>\n\tfunction useElement<S extends string>(\n\t\tselector: S,\n\t): ElementFromSelector<S> | null\n\tfunction useElement<E extends Element>(\n\t\tselector: string,\n\t\trequired: string,\n\t): E\n\tfunction useElement<E extends Element>(selector: string): E | null\n\tfunction useElement<S extends string>(\n\t\tselector: S,\n\t\trequired?: string,\n\t): ElementFromSelector<S> | null {\n\t\tconst target = root.querySelector<ElementFromSelector<S>>(selector)\n\t\tif (required != null && !target)\n\t\t\tthrow new MissingElementError(host, selector, required)\n\t\t// Only add to dependencies if element is a custom element that's not yet defined\n\t\tif (\n\t\t\ttarget &&\n\t\t\tisCustomElement(target) &&\n\t\t\ttarget.matches(':not(:defined)')\n\t\t)\n\t\t\tdependencies.add(target.localName)\n\t\treturn target\n\t} /**\n\t * Get all descendant elements matching a selector\n\t * If any element is a custom element it will be added to dependencies\n\t *\n\t * @since 0.14.0\n\t * @param {S} selector - Selector for elements to check for\n\t * @param {string} [required] - Optional reason for the assertion; if provided, throws on missing elements\n\t * @returns {ElementFromSelector<S>[]} All matching descendant elements\n\t * @throws {MissingElementError} - Thrown when elements are required but not found\n\t */\n\tfunction useElements<S extends string>(\n\t\tselector: S,\n\t\trequired?: string,\n\t): ElementFromSelector<S>[]\n\tfunction useElements<E extends Element>(\n\t\tselector: string,\n\t\trequired?: string,\n\t): E[]\n\tfunction useElements<S extends string>(\n\t\tselector: S,\n\t\trequired?: string,\n\t): ElementFromSelector<S>[] {\n\t\tconst targets = root.querySelectorAll<ElementFromSelector<S>>(selector)\n\t\tif (required != null && !targets.length)\n\t\t\tthrow new MissingElementError(host, selector, required)\n\t\tif (targets.length)\n\t\t\ttargets.forEach(target => {\n\t\t\t\t// Only add to dependencies if element is a custom element that's not yet defined\n\t\t\t\tif (isCustomElement(target) && target.matches(':not(:defined)'))\n\t\t\t\t\tdependencies.add(target.localName)\n\t\t\t})\n\t\treturn Array.from(targets)\n\t}\n\n\t/**\n\t * Apply effect functions to a first matching descendant within the custom element\n\t * If the target element is a custom element, waits for it to be defined before running effects\n\t *\n\t * @since 0.14.0\n\t * @param {S} selector - Selector to match descendant\n\t * @param {Effects<P, E>} effects - Effect functions to apply\n\t * @param {string} [required] - Optional reason for the assertion; if provided, throws on missing element\n\t * @throws {MissingElementError} - Thrown when the element is required but not found\n\t */\n\tconst first = <\n\t\tS extends string,\n\t\tE extends Element = ElementFromSelector<S>,\n\t>(\n\t\tselector: S,\n\t\teffects: Effects<P, E>,\n\t\trequired?: string,\n\t) => {\n\t\tconst target =\n\t\t\trequired != null\n\t\t\t\t? useElement(selector, required)\n\t\t\t\t: useElement(selector)\n\t\treturn () => {\n\t\t\tif (target) return runEffects(effects, host, target as unknown as E)\n\t\t}\n\t}\n\n\t/**\n\t * Apply effect functions to all matching descendant elements within the custom element\n\t * If any target element is a custom element, waits for it to be defined before running effects\n\t *\n\t * @since 0.14.0\n\t * @param {S} selector - Selector to match descendants\n\t * @param {Effects<P, ElementFromSelector<S>>} effects - Effect functions to apply\n\t * @param {string} [required] - Optional reason for the assertion; if provided, throws on missing element\n\t * @throws {MissingElementError} - Thrown when the element is required but not found\n\t */\n\tconst all = <S extends string, E extends Element = ElementFromSelector<S>>(\n\t\tselector: S,\n\t\teffects: Effects<P, E>,\n\t\trequired?: string,\n\t) => {\n\t\tconst targets =\n\t\t\trequired != null\n\t\t\t\t? useElements(selector, required)\n\t\t\t\t: useElements(selector)\n\n\t\treturn () => {\n\t\t\tconst cleanups = new Map<E, Cleanup>()\n\n\t\t\tconst attach = (target: E) => {\n\t\t\t\tconst cleanup = runEffects(effects, host, target)\n\t\t\t\tif (cleanup && !cleanups.has(target))\n\t\t\t\t\tcleanups.set(target, cleanup)\n\t\t\t}\n\n\t\t\tconst detach = (target: E) => {\n\t\t\t\tconst cleanup = cleanups.get(target)\n\t\t\t\tif (cleanup) cleanup()\n\t\t\t\tcleanups.delete(target)\n\t\t\t}\n\n\t\t\tconst applyToMatching =\n\t\t\t\t(fn: (target: E) => void) => (node: Node) => {\n\t\t\t\t\tif (isElement(node)) {\n\t\t\t\t\t\tif (node.matches(selector)) fn(node as E)\n\t\t\t\t\t\tnode.querySelectorAll<E>(selector).forEach(fn)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tconst observer = observeSubtree(root, selector, mutations => {\n\t\t\t\tfor (const mutation of mutations) {\n\t\t\t\t\tmutation.addedNodes.forEach(applyToMatching(attach))\n\t\t\t\t\tmutation.removedNodes.forEach(applyToMatching(detach))\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tif (targets.length)\n\t\t\t\t(targets as unknown as NodeListOf<E>).forEach(attach)\n\n\t\t\treturn () => {\n\t\t\t\tobserver.disconnect()\n\t\t\t\tcleanups.forEach(cleanup => cleanup())\n\t\t\t\tcleanups.clear()\n\t\t\t}\n\t\t}\n\t}\n\n\treturn [\n\t\t{ useElement, useElements, first, all },\n\t\t() => Array.from(dependencies),\n\t]\n}\n\n/**\n * Produce a computed signal of an array of elements matching a selector\n *\n * @since 0.13.1\n * @param {S} selector - CSS selector for descendant elements\n * @returns {Extractor<Computed<ElementFromSelector<S>[]>, C>} Signal producer for descendant element collection from a selector\n * @throws {CircularMutationError} If observed mutations would trigger infinite mutation cycles\n */\nfunction fromSelector<S extends string, C extends HTMLElement = HTMLElement>(\n\tselector: S,\n): Extractor<Computed<ElementFromSelector<S>[]>, C>\nfunction fromSelector<E extends Element, C extends HTMLElement = HTMLElement>(\n\tselector: string,\n): Extractor<Computed<E[]>, C>\nfunction fromSelector<C extends HTMLElement = HTMLElement>(\n\tselector: string,\n): Extractor<Computed<any[]>, C> {\n\treturn (host: C): Computed<any[]> => {\n\t\tconst watchers: Set<Watcher> = new Set()\n\t\tconst select = () =>\n\t\t\tArray.from((host.shadowRoot ?? host).querySelectorAll(selector))\n\t\tlet value: any[] = UNSET\n\t\tlet observer: MutationObserver | undefined\n\t\tlet mutationDepth = 0\n\t\tconst MAX_MUTATION_DEPTH = 2 // Consider a depth > 2 as circular\n\n\t\tconst observe = () => {\n\t\t\tvalue = select()\n\t\t\tobserver = observeSubtree(host, selector, () => {\n\t\t\t\t// If we have no watchers, just disconnect\n\t\t\t\tif (!watchers.size) {\n\t\t\t\t\tobserver?.disconnect()\n\t\t\t\t\tobserver = undefined\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tmutationDepth++\n\t\t\t\tif (mutationDepth > MAX_MUTATION_DEPTH) {\n\t\t\t\t\tobserver?.disconnect()\n\t\t\t\t\tobserver = undefined\n\t\t\t\t\tmutationDepth = 0\n\t\t\t\t\tthrow new CircularMutationError(host, selector)\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tconst newElements = select()\n\t\t\t\t\tif (!areElementArraysEqual(value, newElements)) {\n\t\t\t\t\t\tvalue = newElements\n\t\t\t\t\t\tnotify(watchers)\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tmutationDepth--\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\treturn {\n\t\t\t[Symbol.toStringTag]: TYPE_COMPUTED,\n\n\t\t\tget(): any[] {\n\t\t\t\tsubscribe(watchers)\n\t\t\t\tif (!watchers.size) value = select()\n\t\t\t\telse if (!observer) observe()\n\t\t\t\treturn value\n\t\t\t},\n\t\t}\n\t}\n}\n\nexport {\n\ttype ElementFromSelector,\n\ttype Extractor,\n\ttype Fallback,\n\ttype LooseExtractor,\n\ttype Parser,\n\ttype ParserOrFallback,\n\ttype ElementUsage,\n\ttype ElementsUsage,\n\ttype ElementEffects,\n\ttype ExtractTag,\n\ttype Helpers,\n\ttype KnownTag,\n\tfromDOM,\n\tfromSelector,\n\tgetFallback,\n\tgetHelpers,\n\tisParser,\n\tobserveSubtree,\n}\n",
    "import {\n\ttype Cleanup,\n\ttype ComputedCallback,\n\tcomputed,\n\tisComputed,\n\tisComputedCallback,\n\tisFunction,\n\tisMutableSignal,\n\tisSignal,\n\tisState,\n\tisStore,\n\ttype Signal,\n\tstate,\n\tUNSET,\n} from '@zeix/cause-effect'\n\nimport {\n\ttype Extractor,\n\tgetHelpers,\n\ttype Helpers,\n\tisParser,\n\ttype Parser,\n} from './core/dom'\nimport {\n\tDependencyTimeoutError,\n\tInvalidComponentNameError,\n\tInvalidPropertyNameError,\n} from './core/errors'\nimport { type Effects, runEffects } from './core/reactive'\nimport {\n\tDEV_MODE,\n\telementName,\n\tLOG_WARN,\n\tlog,\n\ttypeString,\n\tvalueString,\n} from './core/util'\n\n/* === Types === */\n\ntype ReservedWords =\n\t| 'constructor'\n\t| 'prototype'\n\t| '__proto__'\n\t| 'toString'\n\t| 'valueOf'\n\t| 'hasOwnProperty'\n\t| 'isPrototypeOf'\n\t| 'propertyIsEnumerable'\n\t| 'toLocaleString'\n\ntype ValidPropertyKey<T> = T extends keyof HTMLElement | ReservedWords\n\t? never\n\t: T\n\ntype ValidateComponentProps<P> = {\n\t[K in keyof P]: ValidPropertyKey<K> extends never ? never : P[K]\n}\n\ntype ComponentProps = { [K in string as ValidPropertyKey<K>]: unknown & {} }\n\ntype Component<P extends ComponentProps> = HTMLElement &\n\tP & {\n\t\t// Common Web Component lifecycle hooks\n\t\tattributeChangedCallback<K extends keyof P>(\n\t\t\tname: K,\n\t\t\toldValue: string | null,\n\t\t\tnewValue: string | null,\n\t\t): void\n\n\t\t// Custom element properties\n\t\tdebug?: boolean\n\t}\n\ntype MaybeSignal<T extends {}> = T | Signal<T> | ComputedCallback<T>\n\ntype Initializer<T extends {}, C extends HTMLElement> =\n\t| T\n\t| Parser<T, C>\n\t| Extractor<T, C>\n\t| ((host: C) => void)\n\ntype Setup<P extends ComponentProps> = (\n\thost: Component<P>,\n\thelpers: Helpers<P>,\n) => Effects<P, Component<P>>\n\n/* === Constants === */\n\nconst DEPENDENCY_TIMEOUT = 50\n\n// Reserved words that should never be used as property names\n// These are fundamental JavaScript/Object properties that cause serious issues\nconst RESERVED_WORDS = new Set([\n\t'constructor',\n\t'prototype',\n\t// Expand this list based on user feedback for other reserved words like:\n\t// '__proto__', 'toString', 'valueOf', 'hasOwnProperty', etc.\n])\n\n// HTMLElement properties that commonly cause conflicts\n// These are properties that exist on HTMLElement and cause confusion when overridden\n// in our reactive components because we use the same name for both attributes and properties\nconst HTML_ELEMENT_PROPS = new Set([\n\t'id', // DOM selector conflicts\n\t'class', // CSS class management conflicts (note: property is 'className')\n\t'className', // CSS class management conflicts (note: HTML attribute is 'class')\n\t'title', // Conflicts with tooltip behavior\n\t'role', // ARIA/accessibility conflicts\n\t'style', // Conflicts with style object\n\t'dataset', // Conflicts with data-* attribute access\n\t'lang', // Language/i18n conflicts\n\t'dir', // Text direction conflicts\n\t'hidden', // Visibility control conflicts\n\t'children', // DOM manipulation conflicts\n\t'innerHTML', // DOM manipulation conflicts\n\t'outerHTML', // Full element HTML conflicts\n\t'textContent', // Text manipulation conflicts\n\t'innerText', // Text manipulation conflicts\n\t// TO EXPAND: Add properties based on user feedback and common mistakes\n\t// 'tabindex', 'tabIndex', 'slot', 'part', etc.\n])\n\n/* === Internal Functions === */\n\n/**\n * Simple fail-fast validation that checks for specific problematic cases\n *\n * This validation prevents common mistakes where developers accidentally\n * use property names that conflict with native HTMLElement functionality.\n *\n * @param {string} prop - Property name to validate\n * @returns {string | null} - Error message or null if valid\n */\nconst validatePropertyName = (prop: string): string | null => {\n\tif (RESERVED_WORDS.has(prop))\n\t\treturn `Property name \"${prop}\" is a reserved word`\n\tif (HTML_ELEMENT_PROPS.has(prop))\n\t\treturn `Property name \"${prop}\" conflicts with inherited HTMLElement property`\n\treturn null\n}\n\n/* === Exported Functions === */\n\n/**\n * Define a component with dependency resolution and setup function (connectedCallback)\n *\n * @since 0.14.0\n * @param {string} name - Name of the custom element\n * @param {{ [K in keyof P]: Initializer<P[K] & {}, Component<P>> }} init - Signals of the component\n * @param {Setup<P>} setup - Setup function to be called after dependencies are resolved\n * @throws {InvalidComponentNameError} If component name is invalid\n * @throws {InvalidPropertyNameError} If property name is invalid\n */\nfunction component<P extends ComponentProps & ValidateComponentProps<P>>(\n\tname: string,\n\tinit: {\n\t\t[K in keyof P]: Initializer<P[K] & {}, Component<P>>\n\t} = {} as {\n\t\t[K in keyof P]: Initializer<P[K] & {}, Component<P>>\n\t},\n\tsetup: Setup<P>,\n): Component<P> {\n\tif (!name.includes('-') || !name.match(/^[a-z][a-z0-9-]*$/))\n\t\tthrow new InvalidComponentNameError(name)\n\tfor (const prop of Object.keys(init)) {\n\t\tconst error = validatePropertyName(prop)\n\t\tif (error) throw new InvalidPropertyNameError(name, prop, error)\n\t}\n\n\tclass CustomElement extends HTMLElement {\n\t\tdebug?: boolean\n\t\t#signals: {\n\t\t\t[K in keyof P]: Signal<P[K]>\n\t\t} = {} as {\n\t\t\t[K in keyof P]: Signal<P[K]>\n\t\t}\n\t\t#cleanup: Cleanup | undefined\n\n\t\tstatic observedAttributes =\n\t\t\tObject.entries(init)\n\t\t\t\t?.filter(([, initializer]) => isParser(initializer))\n\t\t\t\t.map(([prop]) => prop) ?? []\n\n\t\t/**\n\t\t * Native callback function when the custom element is first connected to the document\n\t\t */\n\t\tconnectedCallback() {\n\t\t\tif (DEV_MODE) {\n\t\t\t\tthis.debug = this.hasAttribute('debug')\n\t\t\t\tif (this.debug) log(this, 'Connected')\n\t\t\t}\n\n\t\t\t// Initialize signals\n\t\t\tfor (const [prop, initializer] of Object.entries(init)) {\n\t\t\t\tif (initializer == null || prop in this) continue\n\t\t\t\tconst result = isFunction(initializer)\n\t\t\t\t\t? initializer(this)\n\t\t\t\t\t: initializer\n\t\t\t\tif (result != null) this.#setAccessor(prop, result)\n\t\t\t}\n\n\t\t\t// Getting effects collects dependencies as a side-effect\n\t\t\tconst [helpers, getDependencies] = getHelpers(\n\t\t\t\tthis as unknown as Component<P>,\n\t\t\t)\n\t\t\tconst effects = setup(this as unknown as Component<P>, helpers)\n\n\t\t\t// Resolve dependencies and run setup function\n\t\t\tconst deps = getDependencies()\n\t\t\tconst runSetup = () => {\n\t\t\t\tconst cleanup = runEffects(\n\t\t\t\t\teffects,\n\t\t\t\t\tthis as unknown as Component<P>,\n\t\t\t\t)\n\t\t\t\tif (cleanup) this.#cleanup = cleanup\n\t\t\t}\n\n\t\t\tif (deps.length) {\n\t\t\t\tPromise.race([\n\t\t\t\t\tPromise.all(\n\t\t\t\t\t\tdeps.map(dep => customElements.whenDefined(dep)),\n\t\t\t\t\t),\n\t\t\t\t\tnew Promise<never>((_, reject) => {\n\t\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\t\treject(\n\t\t\t\t\t\t\t\tnew DependencyTimeoutError(\n\t\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\t\tdeps.filter(\n\t\t\t\t\t\t\t\t\t\tdep => !customElements.get(dep),\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}, DEPENDENCY_TIMEOUT)\n\t\t\t\t\t}),\n\t\t\t\t])\n\t\t\t\t\t.then(runSetup)\n\t\t\t\t\t.catch(error => {\n\t\t\t\t\t\tif (DEV_MODE)\n\t\t\t\t\t\t\tlog(\n\t\t\t\t\t\t\t\terror,\n\t\t\t\t\t\t\t\t`Error during setup of <${name}>. Trying to run effects anyway.`,\n\t\t\t\t\t\t\t\tLOG_WARN,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\trunSetup()\n\t\t\t\t\t})\n\t\t\t} else {\n\t\t\t\trunSetup()\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Native callback function when the custom element is disconnected from the document\n\t\t */\n\t\tdisconnectedCallback() {\n\t\t\tif (isFunction(this.#cleanup)) this.#cleanup()\n\t\t\tif (DEV_MODE && this.debug) log(this, 'Disconnected')\n\t\t}\n\n\t\t/**\n\t\t * Native callback function when an observed attribute of the custom element changes\n\t\t *\n\t\t * @param {K} attr - Name of the modified attribute\n\t\t * @param {string | null} old - Old value of the modified attribute\n\t\t * @param {string | null} value - New value of the modified attribute\n\t\t */\n\t\tattributeChangedCallback<K extends keyof P>(\n\t\t\tattr: K,\n\t\t\told: string | null,\n\t\t\tvalue: string | null,\n\t\t) {\n\t\t\tif (value === old || isComputed(this.#signals[attr])) return // unchanged or controlled by computed\n\t\t\tconst parser = init[attr]\n\t\t\tif (!isParser<P[K]>(parser)) return\n\t\t\tconst parsed = parser(this, value, old)\n\t\t\tif (DEV_MODE && this.debug)\n\t\t\t\tlog(\n\t\t\t\t\tvalue,\n\t\t\t\t\t`Attribute \"${String(attr)}\" of ${elementName(this)} changed from ${valueString(old)} to ${valueString(value)}, parsed as <${typeString(parsed)}> ${valueString(parsed)}`,\n\t\t\t\t)\n\t\t\tif (attr in this) (this as unknown as P)[attr] = parsed\n\t\t\telse this.#setAccessor(attr, parsed)\n\t\t}\n\n\t\t/**\n\t\t * Set the signal for a given key\n\t\t *\n\t\t * @since 0.15.0\n\t\t * @param {K} key - Key to set accessor for\n\t\t * @param {MaybeSignal<P[K]>} value - Initial value, signal or computed callback to create signal\n\t\t */\n\t\t#setAccessor<K extends keyof P>(\n\t\t\tkey: K,\n\t\t\tvalue: MaybeSignal<P[K]>,\n\t\t): void {\n\t\t\tconst signal = isSignal(value)\n\t\t\t\t? value\n\t\t\t\t: isComputedCallback(value)\n\t\t\t\t\t? computed(value)\n\t\t\t\t\t: state(value)\n\t\t\tconst prev = this.#signals[key]\n\t\t\tconst mutable = isMutableSignal(signal)\n\t\t\tthis.#signals[key] = signal\n\t\t\tObject.defineProperty(this, key, {\n\t\t\t\tget: signal.get,\n\t\t\t\tset: mutable ? signal.set : undefined,\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: mutable,\n\t\t\t})\n\t\t\tif ((prev && isState(prev)) || isStore(prev)) prev.set(UNSET)\n\t\t\tif (DEV_MODE && this.debug)\n\t\t\t\tlog(\n\t\t\t\t\tsignal,\n\t\t\t\t\t`Set ${typeString(signal)} \"${String(key)}\" in ${elementName(this)}`,\n\t\t\t\t)\n\t\t}\n\t}\n\n\tcustomElements.define(name, CustomElement)\n\treturn customElements.get(name) as unknown as Component<P>\n}\n\nexport {\n\ttype Component,\n\ttype ComponentProps,\n\ttype MaybeSignal,\n\ttype ReservedWords,\n\ttype ValidPropertyKey,\n\ttype ValidateComponentProps,\n\ttype Initializer,\n\ttype Setup,\n\tcomponent,\n}\n",
    "import { type Cleanup, isFunction } from '@zeix/cause-effect'\n\nimport type { Component, ComponentProps } from '../component'\nimport { type Extractor, type Fallback, getFallback } from './dom'\n\n/** @see https://github.com/webcomponents-cg/community-protocols/blob/main/proposals/context.md */\n\n/* === Types === */\n\n/**\n * A context key.\n *\n * A context key can be any type of object, including strings and symbols. The\n *  Context type brands the key type with the `__context__` property that\n * carries the type of the value the context references.\n */\ntype Context<K, V> = K & { __context__: V }\n\n/**\n * An unknown context type\n */\ntype UnknownContext = Context<unknown, unknown>\n\n/**\n * A helper type which can extract a Context value type from a Context type\n */\ntype ContextType<T extends UnknownContext> = T extends Context<infer _, infer V>\n\t? V\n\t: never\n\n/**\n * A callback which is provided by a context requester and is called with the value satisfying the request.\n * This callback can be called multiple times by context providers as the requested value is changed.\n */\ntype ContextCallback<V> = (value: V, unsubscribe?: () => void) => void\n\ndeclare global {\n\tinterface HTMLElementEventMap {\n\t\t/**\n\t\t * A 'context-request' event can be emitted by any element which desires\n\t\t * a context value to be injected by an external provider.\n\t\t */\n\t\t'context-request': ContextRequestEvent<UnknownContext>\n\t}\n}\n\n/* === Constants === */\n\nconst CONTEXT_REQUEST = 'context-request'\n\n/* === Exported class === */\n\n/**\n * Class for context-request events\n *\n * An event fired by a context requester to signal it desires a named context.\n *\n * A provider should inspect the `context` property of the event to determine if it has a value that can\n * satisfy the request, calling the `callback` with the requested value if so.\n *\n * If the requested context event contains a truthy `subscribe` value, then a provider can call the callback\n * multiple times if the value is changed, if this is the case the provider should pass an `unsubscribe`\n * function to the callback which requesters can invoke to indicate they no longer wish to receive these updates.\n *\n * @class ContextRequestEvent\n * @extends {Event}\n *\n * @property {T} context - context key\n * @property {ContextCallback<ContextType<T>>} callback - callback function for value getter and unsubscribe function\n * @property {boolean} [subscribe=false] - whether to subscribe to context changes\n */\nclass ContextRequestEvent<T extends UnknownContext> extends Event {\n\treadonly context: T\n\treadonly callback: ContextCallback<ContextType<T>>\n\treadonly subscribe: boolean\n\n\tconstructor(\n\t\tcontext: T,\n\t\tcallback: ContextCallback<ContextType<T>>,\n\t\tsubscribe: boolean = false,\n\t) {\n\t\tsuper(CONTEXT_REQUEST, {\n\t\t\tbubbles: true,\n\t\t\tcomposed: true,\n\t\t})\n\t\tthis.context = context\n\t\tthis.callback = callback\n\t\tthis.subscribe = subscribe\n\t}\n}\n\n/**\n * Provide a context for descendant component consumers\n *\n * @since 0.13.3\n * @param {Context<K, () => P[K]>[]} contexts - Array of contexts to provide\n * @returns {(host: Component<P>) => Cleanup} Function to add an event listener for ContextRequestEvent returning a cleanup function to remove the event listener\n */\nconst provideContexts =\n\t<P extends ComponentProps, K extends keyof P>(\n\t\tcontexts: Context<K, () => P[K]>[],\n\t): ((host: Component<P>) => Cleanup) =>\n\t(host: Component<P>) => {\n\t\tconst listener = (e: ContextRequestEvent<UnknownContext>) => {\n\t\t\tconst { context, callback } = e\n\t\t\tif (\n\t\t\t\tcontexts.includes(context as Context<K, () => P[K]>) &&\n\t\t\t\tisFunction(callback)\n\t\t\t) {\n\t\t\t\te.stopImmediatePropagation()\n\t\t\t\tcallback(() => host[String(context)])\n\t\t\t}\n\t\t}\n\t\thost.addEventListener(CONTEXT_REQUEST, listener)\n\t\treturn () => host.removeEventListener(CONTEXT_REQUEST, listener)\n\t}\n\n/**\n * Consume a context value for a component.\n *\n * @since 0.13.1\n * @param {Context<K, () => T>} context - Context key to consume\n * @param {Fallback<P[K]>} fallback - Fallback value or extractor function\n * @returns {Extractor<() => T, C>} Function that returns the consumed context getter or a signal of the fallback value\n */\nconst fromContext =\n\t<T extends {}, C extends HTMLElement = HTMLElement>(\n\t\tcontext: Context<string, () => T>,\n\t\tfallback: Fallback<T, C>,\n\t): Extractor<() => T, C> =>\n\t(host: C) => {\n\t\tlet consumed = () => getFallback(host, fallback)\n\t\thost.dispatchEvent(\n\t\t\tnew ContextRequestEvent(context, (getter: () => T) => {\n\t\t\t\tconsumed = getter\n\t\t\t}),\n\t\t)\n\t\treturn consumed\n\t}\n\nexport {\n\ttype Context,\n\ttype UnknownContext,\n\ttype ContextType,\n\tCONTEXT_REQUEST,\n\tContextRequestEvent,\n\tprovideContexts,\n\tfromContext,\n}\n",
    "import {\n\tbatch,\n\ttype Cleanup,\n\ttype Computed,\n\teffect,\n\tisRecord,\n\tnotify,\n\tsubscribe,\n\tTYPE_COMPUTED,\n\tUNSET,\n\ttype Watcher,\n} from '@zeix/cause-effect'\nimport type { Component, ComponentProps } from '../component'\nimport {\n\ttype ElementFromSelector,\n\ttype Extractor,\n\tgetFallback,\n\ttype ParserOrFallback,\n} from './dom'\nimport { type Effect, RESET, type Reactive, resolveReactive } from './reactive'\nimport { elementName, LOG_ERROR, log } from './util'\n\n/* === Types === */\n\ntype EventType<K extends string> = K extends keyof HTMLElementEventMap\n\t? HTMLElementEventMap[K]\n\t: Event\n\ntype EventTransformer<\n\tT extends {},\n\tE extends Element,\n\tC extends HTMLElement,\n\tEvt extends Event,\n> = (context: {\n\tevent: Evt\n\thost: C\n\ttarget: E\n\tvalue: T\n}) => T | void | Promise<void>\n\ntype EventTransformers<\n\tT extends {},\n\tE extends Element,\n\tC extends HTMLElement,\n> = {\n\t[K in keyof HTMLElementEventMap]?: EventTransformer<T, E, C, EventType<K>>\n}\n\ntype EventHandler<\n\tP extends ComponentProps,\n\tE extends Element,\n\tEvt extends Event,\n> = (context: {\n\tevent: Evt\n\thost: Component<P>\n\ttarget: E\n}) => { [K in keyof P]?: P[K] } | void | Promise<void>\n\n/* === Exported Functions === */\n\n/**\n * Produce a computed signal from transformed event data\n *\n * @since 0.14.0\n * @param {S} selector - CSS selector for the source element\n * @param {EventTransformers<T, ElementFromSelector<S>, C>} events - Transformation functions for events\n * @param {ParserOrFallback<T>} initialize - Initial value or extractor function\n * @returns {Extractor<Computed<T>, C>} Extractor function for value from event\n */\nconst fromEvents =\n\t<\n\t\tT extends {},\n\t\tC extends HTMLElement = HTMLElement,\n\t\tS extends string = string,\n\t>(\n\t\tselector: S,\n\t\tevents: EventTransformers<T, ElementFromSelector<S>, C>,\n\t\tinitialize: ParserOrFallback<T, C>,\n\t): Extractor<Computed<T>, C> =>\n\t(host: C) => {\n\t\tconst watchers: Set<Watcher> = new Set()\n\t\tlet value: T = getFallback(host, initialize)\n\t\tconst eventMap = new Map<string, EventListener>()\n\t\tlet cleanup: Cleanup | undefined\n\n\t\tconst listen = () => {\n\t\t\tfor (const [type, transform] of Object.entries(events)) {\n\t\t\t\tconst listener = (e: Event) => {\n\t\t\t\t\tconst target = e.target as Element\n\t\t\t\t\tif (!target) return\n\n\t\t\t\t\tconst source = target.closest(\n\t\t\t\t\t\tselector,\n\t\t\t\t\t) as ElementFromSelector<S> | null\n\t\t\t\t\tif (!source || !host.contains(source)) return\n\t\t\t\t\te.stopPropagation()\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst newValue = transform({\n\t\t\t\t\t\t\tevent: e as any,\n\t\t\t\t\t\t\thost,\n\t\t\t\t\t\t\ttarget: source,\n\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t})\n\t\t\t\t\t\tif (newValue == null || newValue instanceof Promise)\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\tif (!Object.is(newValue, value)) {\n\t\t\t\t\t\t\tvalue = newValue\n\t\t\t\t\t\t\tif (watchers.size > 0) notify(watchers)\n\t\t\t\t\t\t\telse if (cleanup) cleanup()\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\te.stopImmediatePropagation()\n\t\t\t\t\t\tthrow error\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\teventMap.set(type, listener)\n\t\t\t\thost.addEventListener(type, listener)\n\t\t\t}\n\t\t\tcleanup = () => {\n\t\t\t\tif (eventMap.size) {\n\t\t\t\t\tfor (const [type, listener] of eventMap) {\n\t\t\t\t\t\thost.removeEventListener(type, listener)\n\t\t\t\t\t}\n\t\t\t\t\teventMap.clear()\n\t\t\t\t}\n\t\t\t\tcleanup = undefined\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\t[Symbol.toStringTag]: TYPE_COMPUTED,\n\n\t\t\tget(): T {\n\t\t\t\tsubscribe(watchers)\n\t\t\t\tif (watchers.size && !eventMap.size) listen()\n\t\t\t\treturn value\n\t\t\t},\n\t\t}\n\t}\n\n/**\n * Effect for attaching an event listener to an element.\n * Provides proper cleanup when the effect is disposed.\n *\n * @since 0.14.0\n * @param {K} type - Event type\n * @param {EventHandler<P, E, EventType<K>>} handler - Event handler function\n * @param {AddEventListenerOptions | boolean} options - Event listener options\n * @returns {Effect<ComponentProps, E>} Effect function that manages the event listener\n */\nconst on =\n\t<\n\t\tK extends keyof HTMLElementEventMap | string,\n\t\tP extends ComponentProps,\n\t\tE extends Element = HTMLElement,\n\t>(\n\t\ttype: K,\n\t\thandler: EventHandler<P, E, EventType<K>>,\n\t\toptions: AddEventListenerOptions | boolean = false,\n\t): Effect<P, E> =>\n\t(host, target): Cleanup => {\n\t\tconst listener = (e: Event) => {\n\t\t\tconst result = handler({ host, target, event: e as EventType<K> })\n\t\t\tif (!isRecord(result)) return\n\t\t\tbatch(() => {\n\t\t\t\tfor (const [key, value] of Object.entries(result)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\thost[key as keyof P] = value\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tlog(\n\t\t\t\t\t\t\terror,\n\t\t\t\t\t\t\t`Reactive property \"${key}\" on ${elementName(host)} from event ${type} on ${elementName(target)} could not be set, because it is read-only.`,\n\t\t\t\t\t\t\tLOG_ERROR,\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t\ttarget.addEventListener(type, listener, options)\n\t\treturn () => target.removeEventListener(type, listener)\n\t}\n\n/**\n * Effect for emitting custom events with reactive detail values.\n * Creates and dispatches CustomEvent instances with bubbling enabled by default.\n *\n * @since 0.13.3\n * @param {string} type - Event type to emit\n * @param {Reactive<T, P, E>} reactive - Reactive value bound to the event detail\n * @returns {Effect<P, E>} Effect function that emits custom events\n */\nconst emitEvent =\n\t<T extends {}, P extends ComponentProps, E extends Element = HTMLElement>(\n\t\ttype: string,\n\t\treactive: Reactive<T, P, E>,\n\t): Effect<P, E> =>\n\t(host, target): Cleanup =>\n\t\teffect((): undefined => {\n\t\t\tconst value = resolveReactive(\n\t\t\t\treactive,\n\t\t\t\thost,\n\t\t\t\ttarget,\n\t\t\t\t`custom event \"${type}\" detail`,\n\t\t\t)\n\t\t\tif (value === RESET || value === UNSET) return\n\t\t\ttarget.dispatchEvent(\n\t\t\t\tnew CustomEvent(type, {\n\t\t\t\t\tdetail: value,\n\t\t\t\t\tbubbles: true,\n\t\t\t\t}),\n\t\t\t)\n\t\t})\n\n/* === Exports === */\n\nexport {\n\ttype EventType,\n\ttype EventTransformer,\n\ttype EventTransformers,\n\ttype EventHandler,\n\temitEvent,\n\tfromEvents,\n\ton,\n}\n",
    "import {\n\ttype Cleanup,\n\teffect,\n\tisFunction,\n\tisSignal,\n\tisState,\n\tUNSET,\n} from '@zeix/cause-effect'\n\nimport type { ComponentProps } from '../component'\nimport {\n\ttype Effect,\n\tRESET,\n\ttype Reactive,\n\tresolveReactive,\n} from '../core/reactive'\nimport { DEV_MODE, elementName, hasMethod, LOG_ERROR, log } from '../core/util'\n\n/* === Types === */\n\ntype UpdateOperation = 'a' | 'c' | 'd' | 'h' | 'm' | 'p' | 's' | 't'\n\ntype ElementUpdater<E extends Element, T> = {\n\top: UpdateOperation\n\tname?: string\n\tread: (element: E) => T | null\n\tupdate: (element: E, value: T) => void\n\tdelete?: (element: E) => void\n\tresolve?: (element: E) => void\n\treject?: (error: unknown) => void\n}\n\ntype ElementInserter<E extends Element> = {\n\tposition?: InsertPosition\n\tcreate: (parent: E) => Element | null\n\tresolve?: (parent: E) => void\n\treject?: (error: unknown) => void\n}\n\ntype DangerouslySetInnerHTMLOptions = {\n\tshadowRootMode?: ShadowRootMode\n\tallowScripts?: boolean\n}\n\n/* === Internal Functions === */\n\nconst getOperationDescription = (\n\top: UpdateOperation,\n\tname: string = '',\n): string => {\n\tconst ops: Record<UpdateOperation, string> = {\n\t\ta: 'attribute ',\n\t\tc: 'class ',\n\t\td: 'dataset ',\n\t\th: 'inner HTML',\n\t\tm: 'method call ',\n\t\tp: 'property ',\n\t\ts: 'style property ',\n\t\tt: 'text content',\n\t}\n\treturn ops[op] + name\n}\n\nconst isSafeURL = (value: string): boolean => {\n\tif (/^(mailto|tel):/i.test(value)) return true\n\tif (value.includes('://')) {\n\t\ttry {\n\t\t\tconst url = new URL(value, window.location.origin)\n\t\t\treturn ['http:', 'https:', 'ftp:'].includes(url.protocol)\n\t\t} catch {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nconst safeSetAttribute = (\n\telement: Element,\n\tattr: string,\n\tvalue: string,\n): void => {\n\tif (/^on/i.test(attr)) throw new Error(`Unsafe attribute: ${attr}`)\n\tvalue = String(value).trim()\n\tif (!isSafeURL(value)) throw new Error(`Unsafe URL for ${attr}: ${value}`)\n\telement.setAttribute(attr, value)\n}\n\n/* === Exported Functions === */\n\n/**\n * Core effect function for updating element properties based on reactive values.\n * This function handles the lifecycle of reading, updating, and deleting element properties\n * while providing proper error handling and debugging support.\n *\n * @since 0.9.0\n * @param {Reactive<T, P, E>} reactive - The reactive value that drives the element updates\n * @param {ElementUpdater<E, T>} updater - Configuration object defining how to read, update, and delete the element property\n * @returns {Effect<P, E>} Effect function that manages the element property updates\n */\nconst updateElement =\n\t<P extends ComponentProps, T extends {}, E extends Element = HTMLElement>(\n\t\treactive: Reactive<T, P, E>,\n\t\tupdater: ElementUpdater<E, T>,\n\t): Effect<P, E> =>\n\t(host, target): Cleanup => {\n\t\tconst { op, name = '', read, update } = updater\n\t\tconst fallback = read(target)\n\t\tconst operationDesc = getOperationDescription(op, name)\n\n\t\tconst ok = (verb: string) => () => {\n\t\t\tif (DEV_MODE && host.debug) {\n\t\t\t\tlog(\n\t\t\t\t\ttarget,\n\t\t\t\t\t`${verb} ${operationDesc} of ${elementName(target)} in ${elementName(host)}`,\n\t\t\t\t)\n\t\t\t}\n\t\t\tupdater.resolve?.(target)\n\t\t}\n\n\t\tconst err = (verb: string) => (error: unknown) => {\n\t\t\tlog(\n\t\t\t\terror,\n\t\t\t\t`Failed to ${verb} ${operationDesc} of ${elementName(target)} in ${elementName(host)}`,\n\t\t\t\tLOG_ERROR,\n\t\t\t)\n\t\t\tupdater.reject?.(error)\n\t\t}\n\n\t\treturn effect((): undefined => {\n\t\t\tconst value = resolveReactive(reactive, host, target, operationDesc)\n\t\t\tconst resolvedValue =\n\t\t\t\tvalue === RESET\n\t\t\t\t\t? fallback\n\t\t\t\t\t: value === UNSET\n\t\t\t\t\t\t? updater.delete\n\t\t\t\t\t\t\t? null\n\t\t\t\t\t\t\t: fallback\n\t\t\t\t\t\t: value\n\n\t\t\tif (updater.delete && resolvedValue === null) {\n\t\t\t\ttry {\n\t\t\t\t\tupdater.delete!(target)\n\t\t\t\t\tok('delete')()\n\t\t\t\t} catch (error) {\n\t\t\t\t\terr('delete')(error)\n\t\t\t\t}\n\t\t\t} else if (resolvedValue != null) {\n\t\t\t\tconst current = read(target)\n\t\t\t\tif (Object.is(resolvedValue, current)) return\n\t\t\t\ttry {\n\t\t\t\t\tupdate(target, resolvedValue)\n\t\t\t\t\tok('update')()\n\t\t\t\t} catch (error) {\n\t\t\t\t\terr('update')(error)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n/**\n * Effect for dynamically inserting or removing elements based on a reactive numeric value.\n * Positive values insert elements, negative values remove them.\n *\n * @since 0.12.1\n * @param {Reactive<number, P, E>} reactive - Reactive value determining number of elements to insert (positive) or remove (negative)\n * @param {ElementInserter<E>} inserter - Configuration object defining how to create and position elements\n * @returns {Effect<P, E>} Effect function that manages element insertion and removal\n */\nconst insertOrRemoveElement =\n\t<P extends ComponentProps, E extends Element = HTMLElement>(\n\t\treactive: Reactive<number, P, E>,\n\t\tinserter?: ElementInserter<E>,\n\t): Effect<P, E> =>\n\t(host, target) => {\n\t\tconst ok = (verb: string) => () => {\n\t\t\tif (DEV_MODE && host.debug) {\n\t\t\t\tlog(\n\t\t\t\t\ttarget,\n\t\t\t\t\t`${verb} element in ${elementName(target)} in ${elementName(host)}`,\n\t\t\t\t)\n\t\t\t}\n\t\t\tif (isFunction(inserter?.resolve)) {\n\t\t\t\tinserter.resolve(target)\n\t\t\t} else {\n\t\t\t\tconst signal = isSignal<number>(reactive) ? reactive : undefined\n\t\t\t\tif (isState(signal)) signal.set(0)\n\t\t\t}\n\t\t}\n\n\t\tconst err = (verb: string) => (error: unknown) => {\n\t\t\tlog(\n\t\t\t\terror,\n\t\t\t\t`Failed to ${verb} element in ${elementName(target)} in ${elementName(host)}`,\n\t\t\t\tLOG_ERROR,\n\t\t\t)\n\t\t\tinserter?.reject?.(error)\n\t\t}\n\n\t\treturn effect((): undefined => {\n\t\t\tconst diff = resolveReactive(\n\t\t\t\treactive,\n\t\t\t\thost,\n\t\t\t\ttarget,\n\t\t\t\t'insertion or deletion',\n\t\t\t)\n\t\t\tconst resolvedDiff = diff === RESET ? 0 : diff\n\n\t\t\tif (resolvedDiff > 0) {\n\t\t\t\t// Positive diff => insert element\n\t\t\t\tif (!inserter) throw new TypeError(`No inserter provided`)\n\t\t\t\ttry {\n\t\t\t\t\tfor (let i = 0; i < resolvedDiff; i++) {\n\t\t\t\t\t\tconst element = inserter.create(target)\n\t\t\t\t\t\tif (!element) continue\n\t\t\t\t\t\ttarget.insertAdjacentElement(\n\t\t\t\t\t\t\tinserter.position ?? 'beforeend',\n\t\t\t\t\t\t\telement,\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\tok('insert')()\n\t\t\t\t} catch (error) {\n\t\t\t\t\terr('insert')(error)\n\t\t\t\t}\n\t\t\t} else if (resolvedDiff < 0) {\n\t\t\t\ttry {\n\t\t\t\t\tif (\n\t\t\t\t\t\tinserter &&\n\t\t\t\t\t\t(inserter.position === 'afterbegin' ||\n\t\t\t\t\t\t\tinserter.position === 'beforeend')\n\t\t\t\t\t) {\n\t\t\t\t\t\tfor (let i = 0; i > resolvedDiff; i--) {\n\t\t\t\t\t\t\tif (inserter.position === 'afterbegin')\n\t\t\t\t\t\t\t\ttarget.firstElementChild?.remove()\n\t\t\t\t\t\t\telse target.lastElementChild?.remove()\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget.remove()\n\t\t\t\t\t}\n\t\t\t\t\tok('remove')()\n\t\t\t\t} catch (error) {\n\t\t\t\t\terr('remove')(error)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n/**\n * Effect for setting the text content of an element.\n * Replaces all child nodes (except comments) with a single text node.\n *\n * @since 0.8.0\n * @param {Reactive<string, P, E>} reactive - Reactive value bound to the text content\n * @returns {Effect<P, E>} Effect function that sets the text content of the element\n */\nconst setText = <P extends ComponentProps, E extends Element = HTMLElement>(\n\treactive: Reactive<string, P, E>,\n): Effect<P, E> =>\n\tupdateElement(reactive, {\n\t\top: 't',\n\t\tread: el => el.textContent,\n\t\tupdate: (el, value) => {\n\t\t\tArray.from(el.childNodes)\n\t\t\t\t.filter(node => node.nodeType !== Node.COMMENT_NODE)\n\t\t\t\t.forEach(node => node.remove())\n\t\t\tel.append(document.createTextNode(value))\n\t\t},\n\t})\n\n/**\n * Effect for setting a property on an element.\n * Sets the specified property directly on the element object.\n *\n * @since 0.8.0\n * @param {K} key - Name of the property to set\n * @param {Reactive<E[K], P, E>} reactive - Reactive value bound to the property value (defaults to property name)\n * @returns {Effect<P, E>} Effect function that sets the property on the element\n */\nconst setProperty = <\n\tP extends ComponentProps,\n\tK extends keyof E & string,\n\tE extends Element = HTMLElement,\n>(\n\tkey: K,\n\treactive: Reactive<E[K] & {}, P, E> = key as unknown as Reactive<\n\t\tE[K] & {},\n\t\tP,\n\t\tE\n\t>,\n): Effect<P, E> =>\n\tupdateElement(reactive, {\n\t\top: 'p',\n\t\tname: key,\n\t\tread: el => (key in el ? el[key] : UNSET),\n\t\tupdate: (el, value) => {\n\t\t\tel[key] = value\n\t\t},\n\t})\n\n/**\n * Effect for controlling element visibility by setting the 'hidden' property.\n * When the reactive value is true, the element is shown; when false, it's hidden.\n *\n * @since 0.13.1\n * @param {Reactive<boolean, P, E>} reactive - Reactive value bound to the visibility state\n * @returns {Effect<P, E>} Effect function that controls element visibility\n */\nconst show = <P extends ComponentProps, E extends HTMLElement = HTMLElement>(\n\treactive: Reactive<boolean, P, E>,\n): Effect<P, E> =>\n\tupdateElement(reactive, {\n\t\top: 'p',\n\t\tname: 'hidden',\n\t\tread: el => !el.hidden,\n\t\tupdate: (el, value) => {\n\t\t\tel.hidden = !value\n\t\t},\n\t})\n\n/**\n * Effect for calling a method on an element.\n *\n * @since 0.13.3\n * @param {K} methodName - Name of the method to call\n * @param {Reactive<boolean, P, E>} reactive - Reactive value bound to the method call\n * @param {unknown[]} args - Arguments to pass to the method\n * @returns Effect function that calls the method on the element\n */\nconst callMethod = <\n\tP extends ComponentProps,\n\tK extends keyof E,\n\tE extends HTMLElement = HTMLElement,\n>(\n\tmethodName: K,\n\treactive: Reactive<boolean, P, E>,\n\targs?: unknown[],\n): Effect<P, E> =>\n\tupdateElement(reactive, {\n\t\top: 'm',\n\t\tname: String(methodName),\n\t\tread: () => null,\n\t\tupdate: (el, value) => {\n\t\t\tif (value && hasMethod(el, methodName)) {\n\t\t\t\tif (args) el[methodName](...args)\n\t\t\t\telse el[methodName]()\n\t\t\t}\n\t\t},\n\t})\n\n/**\n * Effect for controlling element focus by calling the 'focus()' method.\n * If the reactive value is true, element will be focussed; when false, nothing happens.\n *\n * @since 0.13.3\n * @param {Reactive<boolean, P, E>} reactive - Reactive value bound to the focus state\n * @returns {Effect<P, E>} Effect function that sets element focus\n */\nconst focus = <P extends ComponentProps, E extends HTMLElement = HTMLElement>(\n\treactive: Reactive<boolean, P, E>,\n): Effect<P, E> =>\n\tupdateElement(reactive, {\n\t\top: 'm',\n\t\tname: 'focus',\n\t\tread: el => el === document.activeElement,\n\t\tupdate: (el, value) => {\n\t\t\tif (value && hasMethod(el, 'focus')) el.focus()\n\t\t},\n\t})\n\n/**\n * Effect for setting an attribute on an element.\n * Sets the specified attribute with security validation for unsafe values.\n *\n * @since 0.8.0\n * @param {string} name - Name of the attribute to set\n * @param {Reactive<string, P, E>} reactive - Reactive value bound to the attribute value (defaults to attribute name)\n * @returns {Effect<P, E>} Effect function that sets the attribute on the element\n */\nconst setAttribute = <\n\tP extends ComponentProps,\n\tE extends Element = HTMLElement,\n>(\n\tname: string,\n\treactive: Reactive<string, P, E> = name as Reactive<string, P, E>,\n): Effect<P, E> =>\n\tupdateElement(reactive, {\n\t\top: 'a',\n\t\tname,\n\t\tread: el => el.getAttribute(name),\n\t\tupdate: (el, value) => {\n\t\t\tsafeSetAttribute(el, name, value)\n\t\t},\n\t\tdelete: el => {\n\t\t\tel.removeAttribute(name)\n\t\t},\n\t})\n\n/**\n * Effect for toggling a boolean attribute on an element.\n * When the reactive value is true, the attribute is present; when false, it's absent.\n *\n * @since 0.8.0\n * @param {string} name - Name of the attribute to toggle\n * @param {Reactive<boolean, P, E>} reactive - Reactive value bound to the attribute presence (defaults to attribute name)\n * @returns {Effect<P, E>} Effect function that toggles the attribute on the element\n */\nconst toggleAttribute = <\n\tP extends ComponentProps,\n\tE extends Element = HTMLElement,\n>(\n\tname: string,\n\treactive: Reactive<boolean, P, E> = name as Reactive<boolean, P, E>,\n): Effect<P, E> =>\n\tupdateElement(reactive, {\n\t\top: 'a',\n\t\tname,\n\t\tread: el => el.hasAttribute(name),\n\t\tupdate: (el, value) => {\n\t\t\tel.toggleAttribute(name, value)\n\t\t},\n\t})\n\n/**\n * Effect for toggling a CSS class token on an element.\n * When the reactive value is true, the class is added; when false, it's removed.\n *\n * @since 0.8.0\n * @param {string} token - CSS class token to toggle\n * @param {Reactive<boolean, P, E>} reactive - Reactive value bound to the class presence (defaults to class name)\n * @returns {Effect<P, E>} Effect function that toggles the class on the element\n */\nconst toggleClass = <P extends ComponentProps, E extends Element = HTMLElement>(\n\ttoken: string,\n\treactive: Reactive<boolean, P, E> = token as Reactive<boolean, P, E>,\n): Effect<P, E> =>\n\tupdateElement(reactive, {\n\t\top: 'c',\n\t\tname: token,\n\t\tread: el => el.classList.contains(token),\n\t\tupdate: (el, value) => {\n\t\t\tel.classList.toggle(token, value)\n\t\t},\n\t})\n\n/**\n * Effect for setting a CSS style property on an element.\n * Sets the specified style property with support for deletion via UNSET.\n *\n * @since 0.8.0\n * @param {string} prop - Name of the CSS style property to set\n * @param {Reactive<string, P, E>} reactive - Reactive value bound to the style property value (defaults to property name)\n * @returns {Effect<P, E>} Effect function that sets the style property on the element\n */\nconst setStyle = <\n\tP extends ComponentProps,\n\tE extends HTMLElement | SVGElement | MathMLElement = HTMLElement,\n>(\n\tprop: string,\n\treactive: Reactive<string, P, E> = prop as Reactive<string, P, E>,\n): Effect<P, E> =>\n\tupdateElement(reactive, {\n\t\top: 's',\n\t\tname: prop,\n\t\tread: el => el.style.getPropertyValue(prop),\n\t\tupdate: (el, value) => {\n\t\t\tel.style.setProperty(prop, value)\n\t\t},\n\t\tdelete: el => {\n\t\t\tel.style.removeProperty(prop)\n\t\t},\n\t})\n\n/**\n * Effect for setting the inner HTML of an element with optional Shadow DOM support.\n * Provides security options for script execution and shadow root creation.\n *\n * @since 0.11.0\n * @param {Reactive<string, P, E>} reactive - Reactive value bound to the inner HTML content\n * @param {DangerouslySetInnerHTMLOptions} options - Configuration options: shadowRootMode, allowScripts\n * @returns {Effect<P, E>} Effect function that sets the inner HTML of the element\n */\nconst dangerouslySetInnerHTML = <\n\tP extends ComponentProps,\n\tE extends Element = HTMLElement,\n>(\n\treactive: Reactive<string, P, E>,\n\toptions: DangerouslySetInnerHTMLOptions = {},\n): Effect<P, E> =>\n\tupdateElement(reactive, {\n\t\top: 'h',\n\t\tread: el =>\n\t\t\t(el.shadowRoot || !options.shadowRootMode ? el : null)?.innerHTML ??\n\t\t\t'',\n\t\tupdate: (el, html) => {\n\t\t\tconst { shadowRootMode, allowScripts } = options\n\t\t\tif (!html) {\n\t\t\t\tif (el.shadowRoot) el.shadowRoot.innerHTML = '<slot></slot>'\n\t\t\t\treturn ''\n\t\t\t}\n\t\t\tif (shadowRootMode && !el.shadowRoot)\n\t\t\t\tel.attachShadow({ mode: shadowRootMode })\n\t\t\tconst target = el.shadowRoot || el\n\t\t\ttarget.innerHTML = html\n\t\t\tif (!allowScripts) return ''\n\t\t\ttarget.querySelectorAll('script').forEach(script => {\n\t\t\t\tconst newScript = document.createElement('script')\n\t\t\t\tnewScript.appendChild(\n\t\t\t\t\tdocument.createTextNode(script.textContent ?? ''),\n\t\t\t\t)\n\t\t\t\ttarget.appendChild(newScript)\n\t\t\t\tscript.remove()\n\t\t\t})\n\t\t\treturn ' with scripts'\n\t\t},\n\t})\n\n/* === Exports === */\n\nexport {\n\ttype UpdateOperation,\n\ttype ElementUpdater,\n\ttype ElementInserter,\n\ttype DangerouslySetInnerHTMLOptions,\n\tupdateElement,\n\tinsertOrRemoveElement,\n\tsetText,\n\tsetProperty,\n\tshow,\n\tcallMethod,\n\tfocus,\n\tsetAttribute,\n\ttoggleAttribute,\n\ttoggleClass,\n\tsetStyle,\n\tdangerouslySetInnerHTML,\n}\n",
    "import { type Extractor, fromDOM, type LooseExtractor } from '../core/dom'\n\nconst getText =\n\t<E extends Element = Element>(): LooseExtractor<string, E> =>\n\t(element: E) =>\n\t\telement.textContent?.trim()\n\nconst getIdrefText =\n\t<E extends Element = Element>(attr: string): LooseExtractor<string, E> =>\n\t(element: E) => {\n\t\tconst id = element.getAttribute(attr)\n\t\treturn id ? document.getElementById(id)?.textContent?.trim() : undefined\n\t}\n\nconst getProperty =\n\t<E extends Element, K extends keyof E & string>(\n\t\tprop: K,\n\t): LooseExtractor<E[K], E> =>\n\t(element: E) =>\n\t\telement[prop]\n\nconst hasAttribute =\n\t(attr: string): Extractor<boolean, Element> =>\n\t(element: Element) =>\n\t\telement.hasAttribute(attr)\n\nconst getAttribute =\n\t<E extends Element = Element>(attr: string): LooseExtractor<string, E> =>\n\t(element: E) =>\n\t\telement.getAttribute(attr)\n\nconst hasClass =\n\t(token: string): Extractor<boolean, Element> =>\n\t(element: Element) =>\n\t\telement.classList.contains(token)\n\nconst getStyle =\n\t<E extends HTMLElement | SVGElement | MathMLElement = HTMLElement>(\n\t\tprop: string,\n\t): Extractor<string, E> =>\n\t(element: E) =>\n\t\twindow.getComputedStyle(element).getPropertyValue(prop)\n\nconst getLabel = <E extends HTMLElement>(\n\tselector: string,\n): Extractor<string, E> =>\n\tfromDOM({ '.label': getText(), [selector]: getAttribute('aria-label') }, '')\n\nconst getDescription = <E extends HTMLElement>(\n\tselector: string,\n): Extractor<string, E> =>\n\tfromDOM(\n\t\t{\n\t\t\t'.description': getText(),\n\t\t\t[selector]: getIdrefText('aria-describedby'),\n\t\t},\n\t\t'',\n\t)\n\nexport {\n\tgetText,\n\tgetProperty,\n\thasAttribute,\n\tgetAttribute,\n\thasClass,\n\tgetStyle,\n\tgetLabel,\n\tgetDescription,\n}\n",
    "import { type Fallback, getFallback, type Parser } from '../core/dom'\n\n/* === Internal Function === */\n\nconst parseNumber = (\n\tparseFn: (v: string) => number,\n\tvalue: string | null | undefined,\n) => {\n\tif (value == null) return\n\tconst parsed = parseFn(value)\n\treturn Number.isFinite(parsed) ? parsed : undefined\n}\n\n/* === Exported Functions === */\n\n/**\n * Parse a boolean attribute as an actual boolean value\n *\n * @since 0.13.1\n * @returns {Parser<boolean>}\n */\nconst asBoolean =\n\t(): Parser<boolean> => (_: HTMLElement, value: string | null | undefined) =>\n\t\tvalue != null && value !== 'false'\n\n/**\n * Parse a string as a number forced to integer with a fallback\n *\n * Supports hexadecimal and scientific notation\n *\n * @since 0.11.0\n * @param {Fallback<number, E>} [fallback=0] - Fallback value or extractor function\n * @returns {Parser<number, E>} Parser function\n */\nconst asInteger =\n\t<E extends Element = HTMLElement>(\n\t\tfallback: Fallback<number, E> = 0,\n\t): Parser<number, E> =>\n\t(element: E, value: string | null | undefined) => {\n\t\tif (value == null) return getFallback(element, fallback)\n\n\t\t// Handle hexadecimal notation\n\t\tconst trimmed = value.trim()\n\t\tif (trimmed.toLowerCase().startsWith('0x'))\n\t\t\treturn (\n\t\t\t\tparseNumber(v => parseInt(v, 16), trimmed) ??\n\t\t\t\tgetFallback(element, fallback)\n\t\t\t)\n\n\t\t// Handle other formats (including scientific notation)\n\t\tconst parsed = parseNumber(parseFloat, value)\n\t\treturn parsed != null\n\t\t\t? Math.trunc(parsed)\n\t\t\t: getFallback(element, fallback)\n\t}\n\n/**\n * Parse a string as a number with a fallback\n *\n * @since 0.11.0\n * @param {Fallback<number, E>} [fallback=0] - Fallback value or extractor function\n * @returns {Parser<number, E>} Parser function\n */\nconst asNumber =\n\t<E extends Element = HTMLElement>(\n\t\tfallback: Fallback<number, E> = 0,\n\t): Parser<number, E> =>\n\t(element: E, value: string | null | undefined) =>\n\t\tparseNumber(parseFloat, value) ?? getFallback(element, fallback)\n\n/**\n * Parse a string as a string with a fallback\n *\n * @since 0.11.0\n * @param {Fallback<string, E>} [fallback=''] - Fallback value or extractor function\n * @returns {Parser<string, E>} Parser function\n */\nconst asString =\n\t<E extends Element = HTMLElement>(\n\t\tfallback: Fallback<string, E> = '',\n\t): Parser<string, E> =>\n\t(element: E, value: string | null | undefined) =>\n\t\tvalue ?? getFallback(element, fallback)\n\n/**\n * Parse a string as a multi-state value (for examnple: true, false, mixed), defaulting to the first valid option\n *\n * @since 0.9.0\n * @param {[string, ...string[]]} valid - Array of valid values\n * @returns {Parser<string>} Parser function\n */\nconst asEnum =\n\t(valid: [string, ...string[]]): Parser<string> =>\n\t(_: Element, value: string | null | undefined) => {\n\t\tif (value == null) return valid[0]\n\t\tconst lowerValue = value.toLowerCase()\n\t\tconst matchingValid = valid.find(v => v.toLowerCase() === lowerValue)\n\t\treturn matchingValid ? value : valid[0]\n\t}\n\n/**\n * Parse a string as a JSON serialized object with a fallback\n *\n * @since 0.11.0\n * @param {Fallback<T, E>} fallback - Fallback value or extractor function\n * @returns {Parser<T, E>} Parser function\n * @throws {TypeError} If the value and fallback are both null or undefined\n * @throws {SyntaxError} If value is not a valid JSON string\n */\nconst asJSON =\n\t<T extends {}, E extends Element = HTMLElement>(\n\t\tfallback: Fallback<T, E>,\n\t): Parser<T, E> =>\n\t(element: E, value: string | null | undefined) => {\n\t\tif ((value ?? fallback) == null)\n\t\t\tthrow new TypeError(\n\t\t\t\t'asJSON: Value and fallback are both null or undefined',\n\t\t\t)\n\t\tif (value == null) return getFallback(element, fallback)\n\t\tif (value === '') throw new TypeError('Empty string is not valid JSON')\n\t\tlet result: T | undefined\n\t\ttry {\n\t\t\tresult = JSON.parse(value)\n\t\t} catch (error) {\n\t\t\tthrow new SyntaxError(`Failed to parse JSON: ${String(error)}`, {\n\t\t\t\tcause: error,\n\t\t\t})\n\t\t}\n\t\treturn result ?? getFallback(element, fallback)\n\t}\n\nexport { asBoolean, asInteger, asNumber, asString, asEnum, asJSON }\n"
  ],
  "mappings": "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",
  "debugId": "47B36BE01E782C5664756E2164756E21",
  "names": []
}