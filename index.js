var c=($)=>typeof $==="function";var o=($,K)=>Object.prototype.toString.call($)===`[object ${K}]`,B$=($)=>(K)=>K instanceof $,O=B$(Error),Q$=B$(Promise),k=($)=>O($)?$:new Error(String($));var R,v=new Set,l=0,X$=new Map,f$,S$=()=>{f$=void 0;let $=Array.from(X$.values());X$.clear();for(let K of $)K()};queueMicrotask(S$);var i=($)=>{if(R&&!$.includes(R))$.push(R)},E=($)=>{for(let K of $)if(l)v.add(K);else K()},a=()=>{while(v.size){let $=Array.from(v);v.clear();for(let K of $)K()}},H$=($)=>{l++;try{$()}finally{a(),l--}},h=($,K)=>{let Z=R;R=K;try{$()}finally{R=Z}};function U($,...K){let Z=!1,B=()=>h(()=>{if(Z)throw new Error("Circular dependency in effect detected");Z=!0;let Q=n(K,$);if(O(Q))console.error("Unhandled error in effect:",Q);Z=!1},B);B()}var J$="Computed",O$=($,K)=>{if(!K)return!1;return $.name===K.name&&$.message===K.message},q=($,...K)=>{let Z=[],B=z,Q,X=!0,H=!1,j=!1,Y=(A)=>{if(!Object.is(A,B))B=A,X=!1,Q=void 0,H=!1},M=()=>{H=z===B,B=z,Q=void 0},g=(A)=>{let d=k(A);H=O$(d,Q),B=z,Q=d},D=()=>{if(X=!0,!H)E(Z)},y$=()=>h(()=>{if(j)throw new Error("Circular dependency in computed detected");H=!0,j=!0;let A=n(K,$);if(Q$(A))M(),A.then((d)=>{Y(d),E(Z)}).catch(g);else if(A==null||z===A)M();else if(O(A))g(A);else Y(A);j=!1},D),m={[Symbol.toStringTag]:J$,get:()=>{if(i(Z),a(),X)y$();if(Q)throw Q;return B},map:(A)=>q(A,m),match:(A)=>{return U(A,m),m}};return m},_=($)=>o($,J$);var Y$="State",u=($)=>{let K=[],Z=$,B={[Symbol.toStringTag]:Y$,get:()=>{return i(K),Z},set:(Q)=>{if(Object.is(Z,Q))return;if(Z=Q,E(K),z===Z)K.length=0},update:(Q)=>{B.set(Q(Z))},map:(Q)=>q(Q,B),match:(Q)=>{return U(Q,B),B}};return B},P=($)=>o($,Y$);var z=Symbol(),I=($)=>P($)||_($),z$=($)=>c($)&&!$.length||typeof $==="object"&&$!==null&&("ok"in $)&&c($.ok),y=($)=>I($)?$:z$($)?q($):u($),n=($,K)=>{let{ok:Z,nil:B,err:Q}=c(K)?{ok:K}:K,X=[],H=[],j=!1;for(let M=0;M<$.length;M++){let g=$[M];try{let D=g.get();if(D===z)j=!0;X[M]=D}catch(D){H.push(k(D))}}let Y=void 0;try{if(j&&B)Y=B();else if(H.length)Y=Q?Q(...H):H[0];else if(!j)Y=Z(...X)}catch(M){if(Y=k(M),Q)Y=Q(Y)}return Y};if(!("requestAnimationFrame"in globalThis))globalThis.requestAnimationFrame=($)=>setTimeout($,16);var s=new Map,b=[],r,j$=()=>{r=null,b.forEach(($)=>$()),b=[],s.clear()},k$=()=>{if(r)cancelAnimationFrame(r);r=requestAnimationFrame(j$)};queueMicrotask(j$);var W=($,K)=>new Promise((Z,B)=>{let Q=()=>{try{Z($())}catch(X){B(X)}};if(K){let[X,H]=K;if(!s.has(X))s.set(X,new Map);let j=s.get(X);if(j.has(H)){let Y=b.indexOf($);if(Y>-1)b.splice(Y,1)}j.set(H,Q)}b.push(Q),k$()}),A$=async()=>new Promise(requestAnimationFrame);var w$=($)=>$.nodeType===Node.COMMENT_NODE,E$=($)=>!/^on/i.test($),h$=($)=>{if(/^(mailto|tel):/i.test($))return!0;if($.includes("://"))try{let K=new URL($,window.location.origin);return!["http:","https:","ftp:"].includes(K.protocol)}catch(K){return!0}return!0},e=($,K,Z)=>{if(!E$(K))throw new Error(`Unsafe attribute: ${K}`);if(Z=String(Z).trim(),!h$(Z))throw new Error(`Unsafe URL for ${K}: ${Z}`);$.setAttribute(K,Z)};var V$=($,K,Z={},B)=>W(()=>{let Q=document.createElement(K);for(let[X,H]of Object.entries(Z))e(Q,X,H);if(B)Q.textContent=B;return $.append(Q),Q},[$,"e"]),W$=($)=>W(()=>{return $.remove(),null},[$,"r"]),C$=($,K)=>W(()=>{return Array.from($.childNodes).filter((Z)=>!w$(Z)).forEach((Z)=>Z.remove()),$.append(document.createTextNode(K)),$},[$,"t"]),F$=($,K,Z)=>W(()=>{return e($,K,Z),$},[$,`a:${K}`]),I$=($,K)=>W(()=>{return $.removeAttribute(K),$},[$,`a:${K}`]),G$=($,K,Z)=>W(()=>{return $.toggleAttribute(K,Z),$},[$,`a:${K}`]),M$=($,K,Z)=>W(()=>{return $.classList.toggle(K,Z),$},[$,`c:${K}`]),q$=($,K,Z)=>W(()=>{return $.style.setProperty(K,Z),$},[$,`s:${K}`]),x$=($,K)=>W(()=>{return $.style.removeProperty(K),$},[$,`s:${K}`]);var w=($)=>typeof $==="function",p=($)=>!!$&&typeof $==="object",L=($)=>typeof $==="string";var V=!1,$$="debug",b$="info",T="warn",F="error",p$=($)=>$?`#${$}`:"",g$=($)=>$.length?`.${Array.from($).join(".")}`:"",G=($)=>`<${$.localName}${p$($.id)}${g$($.classList)}>`,C=($)=>L($)?`"${$}"`:p($)?JSON.stringify($):String($),J=($,K,Z=$$)=>{if(V||[F,T].includes(Z))console[Z](K,$);return $};class S{$;K;constructor($,K=[$]){this.host=$;this.targets=K}on($,K){return this.targets.forEach((Z,B)=>{let Q;if(w(K))Q=K.length===2?K(Z,B):K;else if(p(K)&&w(K.handleEvent))Q=K;else{J(K,`Invalid listener provided for ${$} event on element ${G(Z)}`,F);return}Z.addEventListener($,Q),this.host.cleanup.push(()=>Z.removeEventListener($,Q))}),this}emit($,K){return this.targets.forEach((Z)=>{Z.dispatchEvent(new CustomEvent($,{detail:K,bubbles:!0}))}),this}pass($){return this.targets.forEach(async(K,Z)=>{if(await f.registry.whenDefined(K.localName),K instanceof f){let B;if(w($)&&$.length===2)B=$(K,Z);else if(p($))B=$;else{J($,"Invalid passed signals provided",F);return}Object.entries(B).forEach(([Q,X])=>{if(L(X))if(X in this.host.signals)K.set(Q,this.host.signals[X]);else J(X,`Invalid string key "${X}" for state ${C(Q)}`,T);else if(w(X)||I(X))K.set(Q,y(X));else J(X,`Invalid source for state ${C(Q)}`,T)})}else J(K,"Target is not a UIElement",F)}),this}sync(...$){return this.targets.forEach((K,Z)=>$.forEach((B)=>B(this.host,K,Z))),this}}var U$="context-request";class L$ extends Event{$;K;Z;constructor($,K,Z=!1){super(U$,{bubbles:!0,composed:!0});this.context=$;this.callback=K;this.subscribe=Z}}var K$=($)=>{let K=$.constructor,Z=K.consumedContexts||[];queueMicrotask(()=>{for(let Q of Z)$.dispatchEvent(new L$(Q,(X)=>$.set(String(Q),X??N)))});let B=K.providedContexts||[];if(!B.length)return!1;return $.addEventListener(U$,(Q)=>{let{context:X,callback:H}=Q;if(!B.includes(X)||!w(H))return;Q.stopPropagation(),H($.signals[String(X)])}),!0};var N=Symbol(),N$=($)=>w($)&&!!$.length,m$=($)=>w($)&&!$.length,Z$=($)=>w($)?Z$($()):I($)?Z$($.get()):$,t=($,K,Z,B)=>{let Q=$.states[K];return N$(Q)?Q(Z,$,B):Z};class f extends HTMLElement{static registry=customElements;static localName;static observedAttributes;static consumedContexts;static providedContexts;static define($=this.localName){try{if(this.registry.define($,this),V)J($,"Registered custom element")}catch(K){J(K,`Failed to register custom element ${$}`,F)}return this}states={};signals={};cleanup=[];self=new S(this);get root(){return this.shadowRoot||this}debug=!1;attributeChangedCallback($,K,Z){if(Z===K||_(this.signals[$]))return;let B=t(this,$,Z,K);if(V&&this.debug)J(Z,`Attribute "${$}" of ${G(this)} changed from ${C(K)} to ${C(Z)}, parsed as <${typeof B}> ${C(B)}`);this.set($,B??N)}connectedCallback(){if(V){if(this.debug=this.hasAttribute("debug"),this.debug)J(this,"Connected")}for(let[$,K]of Object.entries(this.states)){let Z=N$(K)?K(this.getAttribute($),this):m$(K)?q(K):K;this.set($,Z??N)}K$(this)}disconnectedCallback(){if(this.cleanup.forEach(($)=>$()),this.cleanup=[],V&&this.debug)J(this,"Disconnected")}adoptedCallback(){if(V&&this.debug)J(this,"Adopted")}has($){return $ in this.signals}get($){let K=Z$(this.signals[$]);if(V&&this.debug)J(K,`Get current value of state <${typeof K}> ${C($)} in ${G(this)}`);return K}set($,K,Z=!0){if(K==null){J(K,`Attempt to set state ${C($)} to null or undefined in ${G(this)}`,F);return}let B,Q=this.signals[$],X=Q?.get();if(!($ in this.signals)){if(V&&this.debug)B="Create";this.signals[$]=y(K)}else if(Z||X===z||X===N)if(I(K)){if(V&&this.debug)B="Replace";if(this.signals[$]=K,P(Q))Q.set(z)}else if(P(Q)){if(V&&this.debug)B="Update";if(w(K))Q.update(K);else Q.set(K)}else{J(K,`Computed state ${C($)} in ${G(this)} cannot be set`,T);return}else return;if(V&&this.debug)J(K,`${B} state <${typeof K}> ${C($)} in ${G(this)}`)}delete($){if(V&&this.debug)J($,`Delete state ${C($)} from ${G(this)}`);return delete this.signals[$]}first($){let K=this.root.querySelector($);return new S(this,K?[K]:[])}all($){return new S(this,Array.from(this.root.querySelectorAll($)))}}var P$=($,K)=>{if(K==null)return;let Z=$(K);return Number.isFinite(Z)?Z:void 0},d$=($)=>Array.isArray($)&&$[0]?$[0]:$,c$=($)=>$!=="false"&&$!=null,T$=($=0)=>(K)=>P$(parseInt,K)??$,o$=T$(),D$=($=0)=>(K)=>P$(parseFloat,K)??$,v$=D$(),R$=($="")=>(K)=>K??$,i$=R$(),n$=($)=>(K)=>K!=null&&$.includes(K.toLowerCase())?K:d$($),_$=($)=>(K)=>{if(K==null)return $;let Z;try{Z=JSON.parse(K)}catch(B){J(B,"Failed to parse JSON",F)}return Z??$},u$=_$({});var x=($,K)=>(Z,B)=>{let{read:Q,update:X}=K,H=Q(B);if(L($)){let j=L(H)?t(Z,$,H):H;if(j!=null)Z.set($,j,!1)}U(()=>{let j=Q(B),Y=L($)?Z.get($):I($)?$.get():w($)?$(j):void 0;if(!Object.is(Y,j))if((Y===null||Y===z)&&K.delete)K.delete(B);else if(Y==null||Y===N){if(H)X(B,H)}else X(B,Y)})},s$=($,K)=>x(K,{read:()=>null,update:(Z,B)=>V$(Z,$,B)}),r$=($)=>x($,{read:(K)=>K!=null,update:(K,Z)=>Z?W$(K):Promise.resolve(null)}),t$=($)=>x($,{read:(K)=>K.textContent,update:(K,Z)=>C$(K,Z)}),l$=($,K=$)=>x(K,{read:(Z)=>($ in Z)?Z[$]:z,update:(Z,B)=>{Z[$]=B}}),a$=($,K=$)=>x(K,{read:(Z)=>Z.getAttribute($),update:(Z,B)=>F$(Z,$,B),delete:(Z)=>I$(Z,$)}),e$=($,K=$)=>x(K,{read:(Z)=>Z.hasAttribute($),update:(Z,B)=>G$(Z,$,B)}),$4=($,K=$)=>x(K,{read:(Z)=>Z.classList.contains($),update:(Z,B)=>M$(Z,$,B)}),K4=($,K=$)=>x(K,{read:(Z)=>Z.style.getPropertyValue($),update:(Z,B)=>q$(Z,$,B),delete:(Z)=>x$(Z,$)});export{K$ as useContext,x as updateElement,$4 as toggleClass,e$ as toggleAttribute,y as toSignal,u as state,t$ as setText,K4 as setStyle,l$ as setProperty,a$ as setAttribute,r$ as removeElement,t as parse,J as log,P as isState,I as isSignal,_ as isComputed,W as enqueue,U as effect,s$ as createElement,q as computed,H$ as batch,R$ as asStringWithDefault,i$ as asString,D$ as asNumberWithDefault,v$ as asNumber,_$ as asJSONWithDefault,u$ as asJSON,T$ as asIntegerWithDefault,o$ as asInteger,n$ as asEnum,c$ as asBoolean,A$ as animationFrame,z as UNSET,f as UIElement,S as UI,N as RESET,T as LOG_WARN,b$ as LOG_INFO,F as LOG_ERROR,$$ as LOG_DEBUG};
