class b extends Error{constructor($){super(`Circular dependency detected in ${$}`);this.name="CircularDependencyError"}}class J$ extends TypeError{constructor($,B){super(`Invalid signal value ${B} in ${$}`);this.name="InvalidSignalValueError"}}class n extends TypeError{constructor($){super(`Nullish signal values are not allowed in ${$}`);this.name="NullishSignalValueError"}}class K$ extends Error{constructor($,B){super(`Could not add store key "${$}" with value ${B} because it already exists`);this.name="StoreKeyExistsError"}}class W$ extends RangeError{constructor($){super(`Could not remove store index ${String($)} because it is out of range`);this.name="StoreKeyRangeError"}}class x$ extends Error{constructor($,B){super(`Could not set store key "${$}" to ${B} because it is readonly`);this.name="StoreKeyReadonlyError"}}var q=Symbol(),_=($)=>typeof $==="string",T$=($)=>typeof $==="number",l=($)=>typeof $==="symbol",C=($)=>typeof $==="function",r=($)=>C($)&&$.constructor.name==="AsyncFunction",xB=($)=>!!$&&typeof $==="object",u=($,B)=>Object.prototype.toString.call($)===`[object ${B}]`,S=($)=>u($,"Object"),H$=($)=>S($)||Array.isArray($),HB=($)=>{if(!$.length)return null;let B=$.map((Z)=>_(Z)?parseInt(Z,10):T$(Z)?Z:NaN);return B.every((Z)=>Number.isFinite(Z)&&Z>=0)?B.sort((Z,J)=>Z-J):null};var o=($)=>$ instanceof DOMException&&$.name==="AbortError",f=($)=>$ instanceof Error?$:Error(String($));var U$=($)=>{let B=HB(Object.keys($));if(B===null)return $;let Z=[];for(let J of B)Z.push($[String(J)]);return Z},C$=($)=>_($)?`"${$}"`:xB($)?JSON.stringify($):String($);var m=($,B,Z)=>{if(Object.is($,B))return!0;if(typeof $!==typeof B)return!1;if(typeof $!=="object"||$===null||B===null)return!1;if(!Z)Z=new WeakSet;if(Z.has($)||Z.has(B))throw new b("isEqual");Z.add($),Z.add(B);try{if(Array.isArray($)&&Array.isArray(B)){if($.length!==B.length)return!1;for(let J=0;J<$.length;J++)if(!m($[J],B[J],Z))return!1;return!0}if(Array.isArray($)!==Array.isArray(B))return!1;if(S($)&&S(B)){let J=Object.keys($),K=Object.keys(B);if(J.length!==K.length)return!1;for(let W of J){if(!(W in B))return!1;if(!m($[W],B[W],Z))return!1}return!0}return!1}finally{Z.delete($),Z.delete(B)}},M$=($,B)=>{let Z=H$($),J=H$(B);if(!Z||!J){let z=!Object.is($,B);return{changed:z,add:z&&J?B:{},change:{},remove:z&&Z?$:{}}}let K=new WeakSet,W={},X={},x={},Y=Object.keys($),G=Object.keys(B),A=new Set([...Y,...G]);for(let z of A){let P=z in $,j=z in B;if(!P&&j){W[z]=B[z];continue}else if(P&&!j){x[z]=q;continue}let Q=$[z],H=B[z];if(!m(Q,H,K))X[z]=H}return{changed:Object.keys(W).length>0||Object.keys(X).length>0||Object.keys(x).length>0,add:W,change:X,remove:x}};var i,I$=new Set,O$=0,N$=new Map,q$,n$=()=>{q$=void 0;let $=Array.from(N$.values());N$.clear();for(let B of $)B()},QB=()=>{if(q$)cancelAnimationFrame(q$);q$=requestAnimationFrame(n$)};queueMicrotask(n$);var Q$=($)=>{let B=new Set,Z=$;return Z.off=(J)=>{B.add(J)},Z.cleanup=()=>{for(let J of B)J();B.clear()},Z},T=($)=>{if(i&&!$.has(i)){let B=i;$.add(B),i.off(()=>{$.delete(B)})}},V=($)=>{for(let B of $)if(O$)I$.add(B);else B()},F$=()=>{while(I$.size){let $=Array.from(I$);I$.clear();for(let B of $)B()}},t=($)=>{O$++;try{$()}finally{F$(),O$--}},X$=($,B)=>{let Z=i;i=B;try{$()}finally{i=Z}},u$=($,B)=>new Promise((Z,J)=>{N$.set(B||Symbol(),()=>{try{Z($())}catch(K){J(K)}}),QB()});var s="Computed",a=($)=>{let B=new Set,Z=q,J,K,W=!0,X=!1,x=!1,Y=(Q)=>{if(!m(Q,Z))Z=Q,X=!0;J=void 0,W=!1},G=()=>{X=q!==Z,Z=q,J=void 0},A=(Q)=>{let H=f(Q);X=!J||H.name!==J.name||H.message!==J.message,Z=q,J=H},F=(Q)=>(H)=>{if(x=!1,K=void 0,Q(H),X)V(B)},z=Q$(()=>{if(W=!0,K?.abort(),B.size)V(B);else z.cleanup()});z.off(()=>{K?.abort()});let P=()=>X$(()=>{if(x)throw new b("computed");if(X=!1,r($)){if(K)return Z;K=new AbortController,K.signal.addEventListener("abort",()=>{x=!1,K=void 0,P()},{once:!0})}let Q;x=!0;try{Q=K?$(K.signal):$()}catch(H){if(o(H))G();else A(H);x=!1;return}if(Q instanceof Promise)Q.then(F(Y),F(A));else if(Q==null||q===Q)G();else Y(Q);x=!1},z);return{[Symbol.toStringTag]:s,get:()=>{if(T(B),F$(),W)P();if(J)throw J;return Z}}},d=($)=>u($,s),w$=($)=>C($)&&$.length<2;var g=($)=>{let B=r($),Z=!1,J,K=Q$(()=>X$(()=>{if(Z)throw new b("effect");Z=!0,J?.abort(),J=void 0;let W;try{if(B){J=new AbortController;let X=J;$(J.signal).then((x)=>{if(C(x)&&J===X)K.off(x)}).catch((x)=>{if(!o(x))console.error("Async effect error:",x)})}else if(W=$(),C(W))K.off(W)}catch(X){if(!o(X))console.error("Effect callback error:",X)}Z=!1},K));return K(),()=>{J?.abort(),K.cleanup()}};function o$($,B){try{if($.pending)B.nil?.();else if($.errors)B.err?.($.errors);else if($.ok)B.ok($.values)}catch(Z){if(B.err&&(!$.errors||!$.errors.includes(f(Z))))B.err($.errors?[...$.errors,f(Z)]:[f(Z)]);else throw Z}}function i$($){let B=[],Z=!1,J={};for(let[K,W]of Object.entries($))try{let X=W.get();if(X===q)Z=!0;else J[K]=X}catch(X){B.push(f(X))}if(Z)return{ok:!1,pending:!0};if(B.length>0)return{ok:!1,errors:B};return{ok:!0,values:J}}var E$="State",O=($)=>{let B=new Set,Z=$,J={[Symbol.toStringTag]:E$,get:()=>{return T(B),Z},set:(K)=>{if(K==null)throw new n("state");if(m(Z,K))return;if(Z=K,V(B),q===Z)B.clear()},update:(K)=>{J.set(K(Z))}};return J},N=($)=>u($,E$);var P$="Store",k$="store-add",s$="store-change",l$="store-remove",XB="store-sort",e=($)=>{let B=new Set,Z=new EventTarget,J=new Map,K=new Map,W=Array.isArray($),X=O(0),x=()=>{let Q={};for(let[H,L]of J)Q[H]=L.get();return Q},Y=(Q,H)=>Z.dispatchEvent(new CustomEvent(Q,{detail:H})),G=()=>Array.from(J.keys()).map((Q)=>Number(Q)).filter((Q)=>Number.isInteger(Q)).sort((Q,H)=>Q-H),A=(Q,H)=>{if(H==null)throw new n(`store for key "${Q}"`);if(H===q)return!0;if(l(H)||C(H)||d(H))throw new J$(`store for key "${Q}"`,C$(H));return!0},F=(Q,H,L=!1)=>{if(!A(Q,H))return!1;let U=N(H)||p(H)?H:S(H)?e(H):Array.isArray(H)?e(H):O(H);J.set(Q,U);let I=g(()=>{let R=U.get();if(R!=null)Y(s$,{[Q]:R})});if(K.set(Q,I),L)X.set(J.size),V(B),Y(k$,{[Q]:H});return!0},z=(Q,H=!1)=>{let L=J.delete(Q);if(L){let U=K.get(Q);if(U)U();K.delete(Q)}if(H)X.set(J.size),V(B),Y(l$,{[Q]:q});return L},P=(Q,H,L)=>{let U=M$(Q,H);return t(()=>{if(Object.keys(U.add).length){for(let I in U.add){let R=U.add[I]??q;F(I,R)}if(L)setTimeout(()=>{Y(k$,U.add)},0);else Y(k$,U.add)}if(Object.keys(U.change).length){for(let I in U.change){let R=U.change[I];if(!A(I,R))continue;let z$=J.get(I);if($$(z$))z$.set(R);else throw new x$(I,C$(R))}Y(s$,U.change)}if(Object.keys(U.remove).length){for(let I in U.remove)z(I);Y(l$,U.remove)}X.set(J.size)}),U.changed};P({},$,!0);let j={add:W?(Q)=>{let H=J.size,L=String(H);F(L,Q,!0)}:(Q,H)=>{if(!J.has(Q))F(Q,H,!0);else throw new K$(Q,C$(H))},get:()=>{return T(B),U$(x())},remove:W?(Q)=>{let H=U$(x()),L=J.size;if(!Array.isArray(H)||Q<=-L||Q>=L)throw new W$(Q);let U=[...H];if(U.splice(Q,1),P(H,U))V(B)}:(Q)=>{if(J.has(Q))z(Q,!0)},set:(Q)=>{if(P(x(),Q)){if(V(B),q===Q)B.clear()}},update:(Q)=>{let H=x(),L=Q(U$(H));if(P(H,L)){if(V(B),q===L)B.clear()}},sort:(Q)=>{let H=Array.from(J.entries()).map(([I,R])=>[I,R.get()]).sort(Q?(I,R)=>Q(I[1],R[1]):(I,R)=>String(I[1]).localeCompare(String(R[1]))),L=H.map(([I])=>String(I)),U=new Map;H.forEach(([I],R)=>{let z$=String(I),WB=W?String(R):String(I),c$=J.get(z$);if(c$)U.set(WB,c$)}),J.clear(),U.forEach((I,R)=>J.set(R,I)),V(B),Y(XB,L)},addEventListener:Z.addEventListener.bind(Z),removeEventListener:Z.removeEventListener.bind(Z),dispatchEvent:Z.dispatchEvent.bind(Z),size:X};return new Proxy({},{get(Q,H){if(H===Symbol.toStringTag)return P$;if(H===Symbol.isConcatSpreadable)return W;if(H===Symbol.iterator)return W?function*(){let L=G();for(let U of L){let I=J.get(String(U));if(I)yield I}}:function*(){for(let[L,U]of J)yield[L,U]};if(l(H))return;if(H in j)return j[H];if(H==="length"&&W)return T(B),X.get();return J.get(H)},has(Q,H){let L=String(H);return L&&J.has(L)||Object.keys(j).includes(L)||H===Symbol.toStringTag||H===Symbol.iterator||H===Symbol.isConcatSpreadable||H==="length"&&W},ownKeys(){return W?G().map((Q)=>String(Q)).concat(["length"]):Array.from(J.keys()).map((Q)=>String(Q))},getOwnPropertyDescriptor(Q,H){let L=(I)=>({enumerable:!1,configurable:!0,writable:!1,value:I});if(H==="length"&&W)return{enumerable:!0,configurable:!0,writable:!1,value:X.get()};if(H===Symbol.isConcatSpreadable)return L(W);if(H===Symbol.toStringTag)return L(P$);if(l(H))return;if(Object.keys(j).includes(H))return L(j[H]);let U=J.get(H);return U?{enumerable:!0,configurable:!0,writable:!0,value:U}:void 0}})},p=($)=>u($,P$);var w=($)=>N($)||d($)||p($),$$=($)=>N($)||p($);function r$($){if(w($))return $;if(w$($))return a($);if(Array.isArray($)||S($))return e($);return O($)}var E=!1,t$="debug",YB="info",j$="warn",k="error",GB=($)=>$?`#${$}`:"",LB=($)=>$?.length?`.${Array.from($).join(".")}`:"",f$=($)=>!!$&&typeof $==="object",a$=($,B)=>_(B)&&(B in $)&&C($[B]),e$=($)=>$.nodeType===Node.ELEMENT_NODE,Y$=($)=>$.localName.includes("-");var M=($)=>$?`<${$.localName}${GB($.id)}${LB($.classList)}>`:"<unknown>",v=($)=>_($)?`"${$}"`:f$($)?JSON.stringify($):String($),b$=($)=>{if($===null)return"null";if(typeof $!=="object")return typeof $;if(Array.isArray($))return"Array";if(Symbol.toStringTag in Object($))return $[Symbol.toStringTag];return $.constructor?.name||"Object"},D=($,B,Z=t$)=>{if(E||[k,j$].includes(Z))console[Z](B,$);return $};class R$ extends Error{constructor($,B){super(`Circular dependency detected in selection signal for component ${M($)} with selector "${B}"`);this.name="CircularMutationError"}}class V$ extends TypeError{constructor($){super(`Invalid component name "${$}". Custom element names must contain a hyphen, start with a lowercase letter, and contain only lowercase letters, numbers, and hyphens.`);this.name="InvalidComponentNameError"}}class G$ extends TypeError{constructor($,B,Z){super(`Invalid property name "${B}" for component <${$}>. ${Z}`);this.name="InvalidPropertyNameError"}}class D$ extends TypeError{constructor($,B){super(`Invalid effects in component ${M($)}. Effects must be an array of effects, a single effect function, or a Promise that resolves to effects.`);if(this.name="InvalidEffectsError",B)this.cause=B}}class y$ extends TypeError{constructor($,B){super(`Expected signal as value for property "${String(B)}" in component ${M($)}.`);this.name="InvalidSignalError"}}class L$ extends Error{constructor($,B,Z){super(`Missing required element <${B}> in component ${M($)}. ${Z}`);this.name="MissingElementError"}}class _$ extends Error{constructor($,B){super(`Timeout waiting for: [${B.join(", ")}] in component ${M($)}.`);this.name="DependencyTimeoutError"}}class m$ extends TypeError{constructor($,B,Z){super(`Expected reactives passed from ${M($)} to ${M(B)} to be a record of signals, reactive property names or functions. Got ${v(Z)}.`);this.name="InvalidReactivesError"}}class g$ extends TypeError{constructor($,B){super(`Target ${M($)} is not a custom element in ${B}.`);this.name="InvalidCustomElementError"}}class h$ extends TypeError{constructor($,B){super(`Target ${M($)} is not a El Truco component in ${B}.`);this.name="InvalidComponentError"}}var c=Symbol("RESET"),B$=($,B,Z=B)=>{try{if($ instanceof Promise)throw $;if(!Array.isArray($))return $(B,Z);let J=$.filter(C).map((K)=>K(B,Z));return()=>{J.filter(C).forEach((K)=>K()),J.length=0}}catch(J){if(J instanceof Promise)J.then(()=>B$($,B,Z));else throw new D$(B,J instanceof Error?J:Error(String(J)))}},Z$=($,B,Z,J)=>{try{return _($)?B[$]:w($)?$.get():C($)?$(Z):c}catch(K){if(J)D(K,`Failed to resolve value of ${v($)}${J?` for ${J}`:""} in ${M(Z)}${B!==Z?` in ${M(B)}`:""}`,k);return c}};var AB=($)=>{let B=new Set;if($.includes("."))B.add("class");if($.includes("#"))B.add("id");if($.includes("[")){let Z=$.split("[");for(let J=1;J<Z.length;J++){let K=Z[J];if(!K.includes("]"))continue;let W=K.split("=")[0].trim().replace(/[^a-zA-Z0-9_-]/g,"");if(W)B.add(W)}}return[...B]},zB=($,B)=>{if($.length!==B.length)return!1;let Z=new Set($);for(let J of B)if(!Z.has(J))return!1;return!0},A$=($)=>C($)&&$.length>=2,y=($,B)=>C(B)?B($):B,S$=($,B)=>(Z)=>{let J=Z.shadowRoot??Z,K=(X,x)=>{let Y=J.querySelector(X);if(!Y)return;let G=x(Y);if(G!=null)return G},W=void 0;for(let[X,x]of Object.entries($))if(W=K(X,x),W!=null)break;return _(W)&&A$(B)?B(Z,W):W??y(Z,B)},$B=($,B,Z)=>{let J=new MutationObserver(Z),K={childList:!0,subtree:!0},W=AB(B);if(W.length)K.attributes=!0,K.attributeFilter=W;return J.observe($,K),J},BB=($)=>{let B=$.shadowRoot??$,Z=new Set;function J(x,Y){let G=B.querySelector(x);if(Y!=null&&!G)throw new L$($,x,Y);if(G&&Y$(G)&&G.matches(":not(:defined)"))Z.add(G.localName);return G}function K(x,Y){let G=B.querySelectorAll(x);if(Y!=null&&!G.length)throw new L$($,x,Y);if(G.length)G.forEach((A)=>{if(Y$(A)&&A.matches(":not(:defined)"))Z.add(A.localName)});return Array.from(G)}return[{useElement:J,useElements:K,first:(x,Y,G)=>{let A=G!=null?J(x,G):J(x);return()=>{if(A)return B$(Y,$,A)}},all:(x,Y,G)=>{let A=G!=null?K(x,G):K(x);return()=>{let F=new Map,z=(H)=>{let L=B$(Y,$,H);if(L&&!F.has(H))F.set(H,L)},P=(H)=>{let L=F.get(H);if(L)L();F.delete(H)},j=(H)=>(L)=>{if(e$(L)){if(L.matches(x))H(L);L.querySelectorAll(x).forEach(H)}},Q=$B(B,x,(H)=>{for(let L of H)L.addedNodes.forEach(j(z)),L.removedNodes.forEach(j(P))});if(A.length)A.forEach(z);return()=>{Q.disconnect(),F.forEach((H)=>H()),F.clear()}}}},()=>Array.from(Z)]};function UB($){return(B)=>{let Z=new Set,J=()=>Array.from((B.shadowRoot??B).querySelectorAll($)),K=q,W,X=0,x=2,Y=()=>{K=J(),W=$B(B,$,()=>{if(!Z.size){W?.disconnect(),W=void 0;return}if(X++,X>x)throw W?.disconnect(),W=void 0,X=0,new R$(B,$);try{let G=J();if(!zB(K,G))K=G,V(Z)}finally{X--}})};return{[Symbol.toStringTag]:s,get(){if(T(Z),!Z.size)K=J();else if(!W)Y();return K}}}}var CB=50,MB=new Set(["constructor","prototype"]),IB=new Set(["id","class","className","title","role","style","dataset","lang","dir","hidden","children","innerHTML","outerHTML","textContent","innerText"]),ZB=($)=>{if(MB.has($))return`Property name "${$}" is a reserved word`;if(IB.has($))return`Property name "${$}" conflicts with inherited HTMLElement property`;return null};function qB($,B={},Z){if(!$.includes("-")||!$.match(/^[a-z][a-z0-9-]*$/))throw new V$($);for(let K of Object.keys(B)){let W=ZB(K);if(W)throw new G$($,K,W)}class J extends HTMLElement{debug;#$={};#B;static observedAttributes=Object.entries(B)?.filter(([,K])=>A$(K)).map(([K])=>K)??[];connectedCallback(){if(E){if(this.debug=this.hasAttribute("debug"),this.debug)D(this,"Connected")}for(let[G,A]of Object.entries(B)){if(A==null||G in this)continue;let F=C(A)?A(this,null):A;if(F!=null)this.#Z(G,F)}let[K,W]=BB(this),X=Z(this,K),x=W(),Y=()=>{let G=B$(X,this);if(G)this.#B=G};if(x.length)Promise.race([Promise.all(x.map((G)=>customElements.whenDefined(G))),new Promise((G,A)=>{setTimeout(()=>{A(new _$(this,x.filter((F)=>!customElements.get(F))))},CB)})]).then(Y).catch((G)=>{if(E)D(G,`Error during setup of <${$}>. Trying to run effects anyway.`,j$);Y()});else Y()}disconnectedCallback(){if(C(this.#B))this.#B();if(E&&this.debug)D(this,"Disconnected")}attributeChangedCallback(K,W,X){if(X===W||d(this.#$[K]))return;let x=B[K];if(!A$(x))return;let Y=x(this,X,W);if(E&&this.debug)D(X,`Attribute "${String(K)}" of ${M(this)} changed from ${v(W)} to ${v(X)}, parsed as <${b$(Y)}> ${v(Y)}`);if(K in this)this[K]=Y;else this.#Z(K,Y,!0)}#Z(K,W,X=!1){let x=ZB(String(K));if(x)throw new G$(this.localName,String(K),x);let Y=w(W)?W:C(W)?a(W):O(W);if(!w(Y))throw new y$(this,String(K));let G=this.#$[K],A=C(X)?X:!!X&&$$(Y)?Y.set:void 0;this.#$[K]=Y;try{Object.defineProperty(this,K,{get:Y.get,set:A,enumerable:!0,configurable:!!A})}catch(F){D(F,`Failed to define property "${String(K)}" in ${M(this)}`,k)}if(G&&N(G)||p(G))G.set(q);if(E&&this.debug)D(Y,`Set ${b$(Y)} "${String(K)}" in ${M(this)}`)}}return customElements.define($,J),customElements.get($)}var d$="context-request";class JB extends Event{context;callback;subscribe;constructor($,B,Z=!1){super(d$,{bubbles:!0,composed:!0});this.context=$,this.callback=B,this.subscribe=Z}}var FB=($)=>(B)=>{let Z=(J)=>{let{context:K,callback:W}=J;if($.includes(K)&&C(W))J.stopImmediatePropagation(),W(()=>B[String(K)])};return B.addEventListener(d$,Z),()=>B.removeEventListener(d$,Z)},PB=($,B)=>(Z)=>{let J=()=>y(Z,B);return Z.dispatchEvent(new JB($,(K)=>{J=K})),J};var jB=($,B,Z)=>(J)=>{let K=new Set,W=y(J,Z),X=new Map,x,Y=()=>{for(let[G,A]of Object.entries(B)){let F=(z)=>{let P=z.target;if(!P)return;let j=P.closest($);if(!j||!J.contains(j))return;z.stopPropagation();try{let Q=A({event:z,host:J,target:j,value:W});if(Q==null)return;if(!Object.is(Q,W)){if(W=Q,K.size>0)V(K);else if(x)x()}}catch(Q){throw z.stopImmediatePropagation(),Q}};X.set(G,F),J.addEventListener(G,F)}x=()=>{if(X.size){for(let[G,A]of X)J.removeEventListener(G,A);X.clear()}x=void 0}};return{[Symbol.toStringTag]:s,get(){if(T(K),K.size&&!X.size)Y();return W}}},RB=($,B,Z=!1)=>(J,K)=>{let W=(X)=>{let x=B({host:J,target:K,event:X});if(!f$(x))return;t(()=>{for(let[Y,G]of Object.entries(x))try{J[Y]=G}catch(A){D(A,`Reactive property "${Y}" on ${M(J)} from event ${$} on ${M(K)} could not be set, because it is read-only.`,k)}})};return K.addEventListener($,W,Z),()=>K.removeEventListener($,W)},VB=($,B)=>(Z,J)=>g(()=>{let K=Z$(B,Z,J,`custom event "${$}" detail`);if(K===c||K===q)return;J.dispatchEvent(new CustomEvent($,{detail:K,bubbles:!0}))});var DB=($,B="")=>{return{a:"attribute ",c:"class ",d:"dataset ",h:"inner HTML",m:"method call ",p:"property ",s:"style property ",t:"text content"}[$]+B},yB=($)=>{if(/^(mailto|tel):/i.test($))return!0;if($.includes("://"))try{let B=new URL($,window.location.origin);return["http:","https:","ftp:"].includes(B.protocol)}catch{return!1}return!0},_B=($,B,Z)=>{if(/^on/i.test(B))throw Error(`Unsafe attribute: ${B}`);if(Z=String(Z).trim(),!yB(Z))throw Error(`Unsafe URL for ${B}: ${Z}`);$.setAttribute(B,Z)},h=($,B)=>(Z,J)=>{let{op:K,name:W="",read:X,update:x}=B,Y=X(J),G=DB(K,W),A=(z)=>()=>{if(E&&Z.debug)D(J,`${z} ${G} of ${M(J)} in ${M(Z)}`);B.resolve?.(J)},F=(z)=>(P)=>{D(P,`Failed to ${z} ${G} of ${M(J)} in ${M(Z)}`,k),B.reject?.(P)};return g(()=>{let z=Z$($,Z,J,G),P=z===c?Y:z===q?B.delete?null:Y:z;if(B.delete&&P===null)try{B.delete(J),A("delete")()}catch(j){F("delete")(j)}else if(P!=null){let j=X(J);if(Object.is(P,j))return;try{x(J,P),A("update")()}catch(Q){F("update")(Q)}}})},SB=($,B)=>(Z,J)=>{let K=(X)=>()=>{if(E&&Z.debug)D(J,`${X} element in ${M(J)} in ${M(Z)}`);if(C(B?.resolve))B.resolve(J);else{let x=w($)?$:void 0;if(N(x))x.set(0)}},W=(X)=>(x)=>{D(x,`Failed to ${X} element in ${M(J)} in ${M(Z)}`,k),B?.reject?.(x)};return g(()=>{let X=Z$($,Z,J,"insertion or deletion"),x=X===c?0:X;if(x>0){if(!B)throw TypeError("No inserter provided");try{for(let Y=0;Y<x;Y++){let G=B.create(J);if(!G)continue;J.insertAdjacentElement(B.position??"beforeend",G)}K("insert")()}catch(Y){W("insert")(Y)}}else if(x<0)try{if(B&&(B.position==="afterbegin"||B.position==="beforeend"))for(let Y=0;Y>x;Y--)if(B.position==="afterbegin")J.firstElementChild?.remove();else J.lastElementChild?.remove();else J.remove();K("remove")()}catch(Y){W("remove")(Y)}})},TB=($)=>h($,{op:"t",read:(B)=>B.textContent,update:(B,Z)=>{Array.from(B.childNodes).filter((J)=>J.nodeType!==Node.COMMENT_NODE).forEach((J)=>J.remove()),B.append(document.createTextNode(Z))}}),OB=($,B=$)=>h(B,{op:"p",name:$,read:(Z)=>($ in Z)?Z[$]:q,update:(Z,J)=>{Z[$]=J}}),NB=($)=>h($,{op:"p",name:"hidden",read:(B)=>!B.hidden,update:(B,Z)=>{B.hidden=!Z}});var wB=($,B=$)=>h(B,{op:"a",name:$,read:(Z)=>Z.getAttribute($),update:(Z,J)=>{_B(Z,$,J)},delete:(Z)=>{Z.removeAttribute($)}}),EB=($,B=$)=>h(B,{op:"a",name:$,read:(Z)=>Z.hasAttribute($),update:(Z,J)=>{Z.toggleAttribute($,J)}}),kB=($,B=$)=>h(B,{op:"c",name:$,read:(Z)=>Z.classList.contains($),update:(Z,J)=>{Z.classList.toggle($,J)}}),fB=($,B=$)=>h(B,{op:"s",name:$,read:(Z)=>Z.style.getPropertyValue($),update:(Z,J)=>{Z.style.setProperty($,J)},delete:(Z)=>{Z.style.removeProperty($)}}),bB=($,B={})=>h($,{op:"h",read:(Z)=>(Z.shadowRoot||!B.shadowRootMode?Z:null)?.innerHTML??"",update:(Z,J)=>{let{shadowRootMode:K,allowScripts:W}=B;if(!J){if(Z.shadowRoot)Z.shadowRoot.innerHTML="<slot></slot>";return""}if(K&&!Z.shadowRoot)Z.attachShadow({mode:K});let X=Z.shadowRoot||Z;if(X.innerHTML=J,!W)return"";return X.querySelectorAll("script").forEach((x)=>{let Y=document.createElement("script");Y.appendChild(document.createTextNode(x.textContent??"")),X.appendChild(Y),x.remove()})," with scripts"}}),mB=($)=>(B,Z)=>{if(!Y$(Z))throw new g$(Z,`pass from ${M(B)}`);if(!a$(Z,"setSignal"))throw new h$(Z,`pass from ${M(B)}`);if(!S($))throw new m$(B,Z,$);let J=new Map,K=(W,X)=>{let x=C(X)&&X.length===1?X(Z):X;if(Array.isArray(x)&&x.length===2&&C(x[0])&&!x[1].length)return x;if(C(x))return[x,void 0];if(w(x))return[x.get,void 0];if(_(x))return[()=>B[x],void 0];let Y=O(x);return[Y.get,Y.set]};for(let[W,X]of Object.entries($)){if(X==null)continue;let x=Object.getOwnPropertyDescriptor(Z,W);if(!(W in Z)||!x?.configurable)continue;J.set(W,x);let[Y,G]=K(W,X);Object.defineProperty(Z,W,{configurable:!0,enumerable:!0,get:Y,set:G})}return()=>{for(let[W,X]of J)Object.defineProperty(Z,W,X)}};var p$=()=>($)=>$.textContent?.trim(),gB=($)=>(B)=>{let Z=B.getAttribute($);return Z?document.getElementById(Z)?.textContent?.trim():void 0},hB=($)=>(B)=>B[$],dB=($)=>(B)=>B.hasAttribute($),KB=($)=>(B)=>B.getAttribute($),pB=($)=>(B)=>B.classList.contains($),vB=($)=>(B)=>window.getComputedStyle(B).getPropertyValue($),cB=($)=>S$({".label":p$(),[$]:KB("aria-label")},""),nB=($)=>S$({".description":p$(),[$]:gB("aria-describedby")},"");var v$=($,B)=>{if(B==null)return;let Z=$(B);return Number.isFinite(Z)?Z:void 0},uB=()=>($,B)=>B!=null&&B!=="false",oB=($=0)=>(B,Z)=>{if(Z==null)return y(B,$);let J=Z.trim();if(J.toLowerCase().startsWith("0x"))return v$((W)=>parseInt(W,16),J)??y(B,$);let K=v$(parseFloat,Z);return K!=null?Math.trunc(K):y(B,$)},iB=($=0)=>(B,Z)=>v$(parseFloat,Z)??y(B,$),sB=($="")=>(B,Z)=>Z??y(B,$),lB=($)=>(B,Z)=>{if(Z==null)return $[0];let J=Z.toLowerCase();return $.find((W)=>W.toLowerCase()===J)?Z:$[0]},rB=($)=>(B,Z)=>{if((Z??$)==null)throw TypeError("asJSON: Value and fallback are both null or undefined");if(Z==null)return y(B,$);if(Z==="")throw TypeError("Empty string is not valid JSON");let J;try{J=JSON.parse(Z)}catch(K){throw SyntaxError(`Failed to parse JSON: ${String(K)}`,{cause:K})}return J??y(B,$)};export{h as updateElement,kB as toggleClass,EB as toggleAttribute,r$ as toSignal,f as toError,e as store,O as state,NB as show,TB as setText,fB as setStyle,OB as setProperty,wB as setAttribute,Z$ as resolveReactive,i$ as resolve,FB as provideContexts,mB as pass,RB as on,o$ as match,D as log,l as isSymbol,_ as isString,p as isStore,N as isState,w as isSignal,H$ as isRecordOrArray,S as isRecord,A$ as isParser,T$ as isNumber,$$ as isMutableSignal,C as isFunction,m as isEqual,d as isComputed,r as isAsyncFunction,o as isAbortError,SB as insertOrRemoveElement,pB as hasClass,dB as hasAttribute,p$ as getText,vB as getStyle,hB as getProperty,cB as getLabel,y as getFallback,nB as getDescription,KB as getAttribute,UB as fromSelector,jB as fromEvents,S$ as fromDOM,PB as fromContext,u$ as enqueue,VB as emitEvent,g as effect,M$ as diff,bB as dangerouslySetInnerHTML,a as computed,qB as component,t as batch,sB as asString,iB as asNumber,rB as asJSON,oB as asInteger,lB as asEnum,uB as asBoolean,q as UNSET,x$ as StoreKeyReadonlyError,W$ as StoreKeyRangeError,K$ as StoreKeyExistsError,c as RESET,n as NullishSignalValueError,L$ as MissingElementError,j$ as LOG_WARN,YB as LOG_INFO,k as LOG_ERROR,t$ as LOG_DEBUG,J$ as InvalidSignalValueError,y$ as InvalidSignalError,G$ as InvalidPropertyNameError,D$ as InvalidEffectsError,V$ as InvalidComponentNameError,_$ as DependencyTimeoutError,E as DEV_MODE,R$ as CircularMutationError,b as CircularDependencyError};

//# debugId=A7E9E56FAE8A5D9464756E2164756E21
