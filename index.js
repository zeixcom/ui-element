var H=(B)=>typeof B==="function",g=(B,K)=>Object.prototype.toString.call(B)===`[object ${K}]`,f=(B)=>B instanceof Error?B:Error(String(B));class S extends Error{constructor(B){super(`Circular dependency in ${B} detected`);return this}}var _,v=new Set,s=0,l=new Map,c,WB=()=>{c=void 0;let B=Array.from(l.values());l.clear();for(let K of B)K()},HB=()=>{if(c)cancelAnimationFrame(c);c=requestAnimationFrame(WB)};queueMicrotask(WB);var m=(B)=>{let K=new Set,$=B;return $.off=(W)=>{K.add(W)},$.cleanup=()=>{for(let W of K)W();K.clear()},$},D=(B)=>{if(_&&!B.has(_)){let K=_;B.add(K),_.off(()=>{B.delete(K)})}},M=(B)=>{for(let K of B)if(s)v.add(K);else K()},u=()=>{while(v.size){let B=Array.from(v);v.clear();for(let K of B)K()}},ZB=(B)=>{s++;try{B()}finally{u(),s--}},d=(B,K)=>{let $=_;_=K;try{B()}finally{_=$}},N=(B,K)=>new Promise(($,W)=>{l.set(K||Symbol(),()=>{try{$(B())}catch(Z){W(Z)}}),HB()});var r="State",o=(B)=>{let K=new Set,$=B,W={[Symbol.toStringTag]:r,get:()=>{return D(K),$},set:(Z)=>{if(Object.is($,Z))return;if($=Z,M(K),j===$)K.clear()},update:(Z)=>{W.set(Z($))}};return W},C=(B)=>g(B,r);var h="Computed",i=(B)=>{let K=new Set,$=j,W,Z,J=!0,z=!1,G=!1,I=(V)=>{if(!Object.is(V,$))$=V,z=!0;W=void 0,J=!1},X=()=>{z=j!==$,$=j,W=void 0},Y=(V)=>{let q=f(V);z=!W||q.name!==W.name||q.message!==W.message,$=j,W=q},x=(V)=>(q)=>{if(G=!1,Z=void 0,V(q),z)M(K)},A=m(()=>{if(J=!0,Z?.abort("Aborted because source signal changed"),K.size)M(K);else A.cleanup()}),R=()=>d(()=>{if(G)throw new S("computed");if(z=!1,H(B)&&B.constructor.name==="AsyncFunction"){if(Z)return $;Z=new AbortController,Z.signal.addEventListener("abort",()=>{G=!1,Z=void 0,R()},{once:!0})}let V;G=!0;try{V=Z?B(Z.signal):B()}catch(q){if(q instanceof DOMException&&q.name==="AbortError")X();else Y(q);G=!1;return}if(V instanceof Promise)V.then(x(I),x(Y));else if(V==null||j===V)X();else I(V);G=!1},A);return{[Symbol.toStringTag]:h,get:()=>{if(D(K),u(),J)R();if(W)throw W;return $}}},k=(B)=>g(B,h),a=(B)=>H(B)&&B.length<2;var j=Symbol(),P=(B)=>C(B)||k(B),E=(B)=>P(B)?B:a(B)?i(B):o(B);function p(B){let{signals:K,ok:$,err:W=console.error,nil:Z=()=>{}}=H(B)?{signals:[],ok:B}:B,J=!1,z=m(()=>d(()=>{if(J)throw new S("effect");J=!0;let G=[],I=!1,X=K.map((x)=>{try{let A=x.get();if(A===j)I=!0;return A}catch(A){return G.push(f(A)),j}}),Y=void 0;try{Y=I?Z():G.length?W(...G):$(...X)}catch(x){Y=W(f(x))}finally{if(H(Y))z.off(Y)}J=!1},z));return z(),()=>z.cleanup()}var U=!1,QB="debug",jB="info",VB="warn",b="error",FB=(B)=>B?`#${B}`:"",AB=(B)=>B.length?`.${Array.from(B).join(".")}`:"",t=(B)=>!!B&&typeof B==="object",O=(B)=>typeof B==="string",JB=(B)=>B.nodeType===Node.ELEMENT_NODE,Q=(B)=>`<${B.localName}${FB(B.id)}${AB(B.classList)}>`,w=(B)=>O(B)?`"${B}"`:t(B)?JSON.stringify(B):String(B),n=(B)=>{if(B===null)return"null";if(typeof B!=="object")return typeof B;if(Array.isArray(B))return"Array";if(Symbol.toStringTag in Object(B))return B[Symbol.toStringTag];return B.constructor?.name||"Object"},F=(B,K,$="debug")=>{if(["error","warn"].includes($))console[$](K,B);return B};class zB extends Error{constructor(B){super(B);this.name="CircularMutationError"}}var LB=(B)=>B instanceof HTMLElement&&B.localName.includes("-"),xB=(B)=>{let K=new Set;if(B.includes("."))K.add("class");if(B.includes("#"))K.add("id");if(B.includes("[")){let $=B.split("[");for(let W=1;W<$.length;W++){let Z=$[W];if(!Z.includes("]"))continue;let J=Z.split("=")[0].trim().replace(/[^a-zA-Z0-9_-]/g,"");if(J)K.add(J)}}return[...K]},qB=(B,K)=>{if(B.length!==K.length)return!1;let $=new Set(B);for(let W of K)if(!$.has(W))return!1;return!0},e=(B,K,$)=>{let W=new MutationObserver($),Z=xB(K),J={childList:!0,subtree:!0};if(Z.length)J.attributes=!0,J.attributeFilter=Z;return W.observe(B,J),W},CB=(B,K)=>{let $=new Set,W=()=>Array.from(B.querySelectorAll(K)),Z=j,J,z=0,G=2,I=()=>{Z=W(),J=e(B,K,()=>{if(!$.size){J?.disconnect(),J=void 0;return}if(z++,z>G)throw J?.disconnect(),J=void 0,z=0,new zB("Circular mutation in element selection detected");try{let Y=W();if(!qB(Z,Y))Z=Y,M($)}finally{z--}})};return{[Symbol.toStringTag]:h,get:()=>{if(D($),!$.size)Z=W();else if(!J)I();return Z}}},UB=(B,K)=>($,W=$)=>{if(!H(K))throw new TypeError(`Invalid event listener provided for "${B} event on element ${Q(W)}`);return W.addEventListener(B,K),()=>W.removeEventListener(B,K)},MB=(B,K)=>($,W=$)=>{W.dispatchEvent(new CustomEvent(B,{detail:H(K)?K(W):K,bubbles:!0}))},PB=(B)=>(K,$)=>{let W=$.localName;if(!LB($))throw new TypeError("Target element must be a custom element");let Z=H(B)?B($):B;if(!t(Z))throw new TypeError("Passed signals must be an object or a provider function");customElements.whenDefined(W).then(()=>{for(let[J,z]of Object.entries(Z)){let G=O(z)?K.getSignal(J):E(z);$.setSignal(J,G)}}).catch((J)=>{throw new Error(`Failed to pass signals to ${Q($)}}`,{cause:J})})};var T=Symbol(),OB=new Set(["constructor","prototype"]),yB=new Set(["id","class","className","title","role","style","dataset","lang","dir","hidden","children","innerHTML","outerHTML","textContent","innerText"]),BB=(B)=>H(B)&&B.length>=2,GB=(B)=>{if(OB.has(B))return`Property name "${B}" is a reserved word`;if(yB.has(B))return`Property name "${B}" conflicts with inherited HTMLElement property`;return null},$B=(B,K,$=K)=>{let W=B.filter(H).map((Z)=>Z(K,$));return()=>{W.filter(H).forEach((Z)=>Z()),W.length=0}},RB=()=>({first:(B,...K)=>($)=>{let W=($.shadowRoot||$).querySelector(B);if(W)$B(K,$,W)},all:(B,...K)=>($)=>{let W=new Map,Z=$.shadowRoot||$,J=(X)=>{if(!W.has(X))W.set(X,$B(K,$,X))},z=(X)=>{let Y=W.get(X);if(H(Y))Y();W.delete(X)},G=(X)=>(Y)=>{if(JB(Y)){if(Y.matches(B))X(Y);Y.querySelectorAll(B).forEach(X)}},I=e(Z,B,(X)=>{for(let Y of X)Y.addedNodes.forEach(G(J)),Y.removedNodes.forEach(G(z))});return Z.querySelectorAll(B).forEach(J),()=>{I.disconnect(),W.forEach((X)=>X()),W.clear()}}}),_B=(B,K={},$)=>{for(let Z of Object.keys(K)){let J=GB(Z);if(J)throw new TypeError(`${J} in component "${B}".`)}class W extends HTMLElement{debug;#B={};#$;static observedAttributes=Object.entries(K)?.filter(([,Z])=>BB(Z)).map(([Z])=>Z)??[];constructor(){super();for(let[Z,J]of Object.entries(K)){if(J==null)continue;let z=BB(J)?J(this,null):H(J)?J(this):J;if(z!=null)this.setSignal(Z,E(z))}}connectedCallback(){if(U){if(this.debug=this.hasAttribute("debug"),this.debug)F(this,"Connected")}let Z=$(this,RB());if(!Array.isArray(Z))throw new TypeError(`Expected array of functions as return value of setup function in ${Q(this)}`);this.#$=$B(Z,this)}disconnectedCallback(){if(H(this.#$))this.#$();if(U&&this.debug)F(this,"Disconnected")}attributeChangedCallback(Z,J,z){if(z===J||k(this.#B[Z]))return;let G=K[Z];if(!BB(G))return;let I=G(this,z,J);if(U&&this.debug)F(z,`Attribute "${Z}" of ${Q(this)} changed from ${w(J)} to ${w(z)}, parsed as <${n(I)}> ${w(I)}`);this[Z]=I}getSignal(Z){let J=this.#B[Z];if(U&&this.debug)F(J,`Get ${n(J)} "${String(Z)}" in ${Q(this)}`);return J}setSignal(Z,J){let z=GB(String(Z));if(z)throw new TypeError(`${z} on ${Q(this)}.`);if(!P(J))throw new TypeError(`Expected signal as value for property "${String(Z)}" on ${Q(this)}.`);let G=this.#B[Z],I=C(J);if(this.#B[Z]=J,Object.defineProperty(this,Z,{get:J.get,set:I?J.set:void 0,enumerable:!0,configurable:I}),G&&C(G))G.set(j);if(U&&this.debug)F(J,`Set ${n(J)} "${String(Z)} in ${Q(this)}`)}}return customElements.define(B,W),W};var KB="context-request";class IB extends Event{B;K;$;constructor(B,K,$=!1){super(KB,{bubbles:!0,composed:!0});this.context=B;this.callback=K;this.subscribe=$}}var DB=(B)=>(K)=>{let $=(W)=>{let{context:Z,callback:J}=W;if(B.includes(Z)&&H(J))W.stopPropagation(),J(K.getSignal(String(Z)))};return K.addEventListener(KB,$),()=>K.removeEventListener(KB,$)},NB=(B)=>(K)=>{let $;return K.dispatchEvent(new IB(B,(W)=>{$=W})),$};var XB=(B,K)=>{if(K==null)return;let $=B(K);return Number.isFinite($)?$:void 0},wB=(B,K)=>K!=="false"&&K!=null,TB=(B=0)=>(K,$)=>{if($==null)return B;let W=$.trim();if(W==="")return B;if(W.toLowerCase().startsWith("0x")){let J=parseInt(W,16);return Number.isFinite(J)?J:B}let Z=XB(parseFloat,$);return Z!=null?Math.trunc(Z):B},SB=(B=0)=>(K,$)=>XB(parseFloat,$)??B,kB=(B="")=>(K,$)=>$??B,EB=(B)=>(K,$)=>{if($==null)return B[0];let W=$.toLowerCase();return B.find((J)=>J.toLowerCase()===W)?$:B[0]},bB=(B)=>(K,$)=>{if(($??B)==null)throw new ReferenceError("Value and fallback are both null or undefined");if($==null)return B;if($==="")throw new SyntaxError("Empty string is not valid JSON");let W;try{W=JSON.parse($)}catch(Z){throw new SyntaxError(`Failed to parse JSON: ${String(Z)}`,{cause:Z})}return W??B};var YB=(B,K,$)=>O(B)?K.getSignal(B).get():P(B)?B.get():H(B)?B($):T,fB=(B)=>{if(/^(mailto|tel):/i.test(B))return!0;if(B.includes("://"))try{let K=new URL(B,window.location.origin);return["http:","https:","ftp:"].includes(K.protocol)}catch(K){return!1}return!0},mB=(B,K,$)=>{if(/^on/i.test(K))throw new Error(`Unsafe attribute: ${K}`);if($=String($).trim(),!fB($))throw new Error(`Unsafe URL for ${K}: ${$}`);B.setAttribute(K,$)},y=(B,K)=>($,W)=>{let{op:Z,name:J="",read:z,update:G}=K,I=z(W),X={a:"attribute ",c:"class ",h:"inner HTML",p:"property ",s:"style property ",t:"text content"};if(O(B)&&O(I)&&$[B]===T)$.attributeChangedCallback(B,null,I);let Y=(A)=>()=>{if(U&&$.debug)F(W,`${A} ${X[Z]+J} of ${Q(W)} in ${Q($)}`);K.resolve?.(W)},x=(A)=>(R)=>{F(R,`Failed to ${A} ${X[Z]+J} of ${Q(W)} in ${Q($)}`,b),K.reject?.(R)};return p(()=>{let A=Symbol(`${Z}:${J}`),R=Symbol(`${Z}-${J}`),L=T;try{L=YB(B,$,W)}catch(V){F(V,`Failed to resolve value of ${w(B)} for ${X[Z]+J} of ${Q(W)} in ${Q($)}`,b);return}if(L===T)L=I;else if(L===j)L=K.delete?null:I;if(K.delete&&L===null)N(()=>{return K.delete(W),!0},R).then(Y("Deleted")).catch(x("delete"));else if(L!=null){let V=z(W);if(Object.is(L,V))return;N(()=>{return G(W,L),!0},A).then(Y("Updated")).catch(x("update"))}})},dB=(B,K)=>($,W)=>{let Z=(z)=>()=>{if(U&&$.debug)F(W,`${z} element in ${Q(W)} in ${Q($)}`);if(H(K?.resolve))K.resolve(W);else{let G=P(B)?B:O(B)?$.getSignal(B):void 0;if(C(G))G.set(0)}},J=(z)=>(G)=>{F(G,`Failed to ${z} element in ${Q(W)} in ${Q($)}`,b),K?.reject?.(G)};return p(()=>{let z=Symbol("i"),G=Symbol("d"),I=0;try{I=YB(B,$,W)}catch(X){F(X,`Failed to resolve value of ${w(B)} for insertion or deletion in ${Q(W)} in ${Q($)}`,b);return}if(I===T)I=0;if(I>0){if(!K)throw new TypeError("No inserter provided");N(()=>{for(let X=0;X<I;X++){let Y=K.create(W);if(!Y)continue;W.insertAdjacentElement(K.position??"beforeend",Y)}return!0},z).then(Z("Inserted")).catch(J("insert"))}else if(I<0)N(()=>{if(K&&(K.position==="afterbegin"||K.position==="beforeend"))for(let X=0;X>I;X--)if(K.position==="afterbegin")W.firstElementChild?.remove();else W.lastElementChild?.remove();else W.remove();return!0},G).then(Z("Removed")).catch(J("remove"))})},hB=(B)=>y(B,{op:"t",read:(K)=>K.textContent,update:(K,$)=>{Array.from(K.childNodes).filter((W)=>W.nodeType!==Node.COMMENT_NODE).forEach((W)=>W.remove()),K.append(document.createTextNode($))}}),pB=(B,K=B)=>y(K,{op:"p",name:String(B),read:($)=>(B in $)?$[B]:j,update:($,W)=>{$[B]=W}}),gB=(B,K=B)=>y(K,{op:"a",name:B,read:($)=>$.getAttribute(B),update:($,W)=>{mB($,B,W)},delete:($)=>{$.removeAttribute(B)}}),vB=(B,K=B)=>y(K,{op:"a",name:B,read:($)=>$.hasAttribute(B),update:($,W)=>{$.toggleAttribute(B,W)}}),cB=(B,K=B)=>y(K,{op:"c",name:B,read:($)=>$.classList.contains(B),update:($,W)=>{$.classList.toggle(B,W)}}),uB=(B,K=B)=>y(K,{op:"s",name:B,read:($)=>$.style.getPropertyValue(B),update:($,W)=>{$.style.setProperty(B,W)},delete:($)=>{$.style.removeProperty(B)}}),oB=(B,K={})=>y(B,{op:"h",read:($)=>($.shadowRoot||!K.shadowRootMode?$:null)?.innerHTML??"",update:($,W)=>{let{shadowRootMode:Z,allowScripts:J}=K;if(!W){if($.shadowRoot)$.shadowRoot.innerHTML="<slot></slot>";return""}if(Z&&!$.shadowRoot)$.attachShadow({mode:Z});let z=$.shadowRoot||$;if(z.innerHTML=W,!J)return"";return z.querySelectorAll("script").forEach((G)=>{let I=document.createElement("script");I.appendChild(document.createTextNode(G.textContent??"")),z.appendChild(I),G.remove()})," with scripts"}});export{y as updateElement,cB as toggleClass,vB as toggleAttribute,E as toSignal,o as state,hB as setText,uB as setStyle,pB as setProperty,gB as setAttribute,CB as selection,DB as provide,PB as pass,UB as on,F as log,C as isState,P as isSignal,k as isComputed,dB as insertOrRemoveElement,N as enqueue,MB as emit,p as effect,oB as dangerouslySetInnerHTML,NB as consume,i as computed,_B as component,ZB as batch,kB as asString,SB as asNumber,bB as asJSON,TB as asInteger,EB as asEnum,wB as asBoolean,j as UNSET,T as RESET,VB as LOG_WARN,jB as LOG_INFO,b as LOG_ERROR,QB as LOG_DEBUG};
