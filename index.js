var H=(B)=>typeof B==="function",g=(B,W)=>Object.prototype.toString.call(B)===`[object ${W}]`,f=(B)=>B instanceof Error?B:Error(String(B));class S extends Error{constructor(B){super(`Circular dependency in ${B} detected`);return this}}var _,v=new Set,l=0,r=new Map,c,WB=()=>{c=void 0;let B=Array.from(r.values());r.clear();for(let W of B)W()},XB=()=>{if(c)cancelAnimationFrame(c);c=requestAnimationFrame(WB)};queueMicrotask(WB);var m=(B)=>{let W=new Set,$=B;return $.off=(K)=>{W.add(K)},$.cleanup=()=>{for(let K of W)K();W.clear()},$},D=(B)=>{if(_&&!B.has(_)){let W=_;B.add(W),_.off(()=>{B.delete(W)})}},M=(B)=>{for(let W of B)if(l)v.add(W);else W()},u=()=>{while(v.size){let B=Array.from(v);v.clear();for(let W of B)W()}},KB=(B)=>{l++;try{B()}finally{u(),l--}},d=(B,W)=>{let $=_;_=W;try{B()}finally{_=$}},N=(B,W)=>new Promise(($,K)=>{r.set(W||Symbol(),()=>{try{$(B())}catch(Z){K(Z)}}),XB()});var a="State",i=(B)=>{let W=new Set,$=B,K={[Symbol.toStringTag]:a,get:()=>{return D(W),$},set:(Z)=>{if(Object.is($,Z))return;if($=Z,M(W),j===$)W.clear()},update:(Z)=>{K.set(Z($))}};return K},C=(B)=>g(B,a);var p="Computed",o=(B)=>{let W=new Set,$=j,K,Z,J=!0,z=!1,G=!1,Y=(V)=>{if(!Object.is(V,$))$=V,z=!0;K=void 0,J=!1},I=()=>{z=j!==$,$=j,K=void 0},X=(V)=>{let x=f(V);z=!K||x.name!==K.name||x.message!==K.message,$=j,K=x},q=(V)=>(x)=>{if(G=!1,Z=void 0,V(x),z)M(W)},F=m(()=>{if(J=!0,Z?.abort("Aborted because source signal changed"),W.size)M(W);else F.cleanup()}),y=()=>d(()=>{if(G)throw new S("computed");if(z=!1,H(B)&&B.constructor.name==="AsyncFunction"){if(Z)return $;Z=new AbortController,Z.signal.addEventListener("abort",()=>{G=!1,Z=void 0,y()},{once:!0})}let V;G=!0;try{V=Z?B(Z.signal):B()}catch(x){if(x instanceof DOMException&&x.name==="AbortError")I();else X(x);G=!1;return}if(V instanceof Promise)V.then(q(Y),q(X));else if(V==null||j===V)I();else Y(V);G=!1},F);return{[Symbol.toStringTag]:p,get:()=>{if(D(W),u(),J)y();if(K)throw K;return $}}},k=(B)=>g(B,p),t=(B)=>H(B)&&B.length<2;var j=Symbol(),P=(B)=>C(B)||k(B),b=(B)=>P(B)?B:t(B)?o(B):i(B);function h(B){let{signals:W,ok:$,err:K=console.error,nil:Z=()=>{}}=H(B)?{signals:[],ok:B}:B,J=!1,z=m(()=>d(()=>{if(J)throw new S("effect");J=!0;let G=[],Y=!1,I=W.map((q)=>{try{let F=q.get();if(F===j)Y=!0;return F}catch(F){return G.push(f(F)),j}}),X=void 0;try{X=Y?Z():G.length?K(...G):$(...I)}catch(q){X=K(f(q))}finally{if(H(X))z.off(X)}J=!1},z));return z(),()=>z.cleanup()}var U=!1,YB="debug",HB="info",QB="warn",E="error",jB=(B)=>B?`#${B}`:"",VB=(B)=>B.length?`.${Array.from(B).join(".")}`:"",e=(B)=>!!B&&typeof B==="object",O=(B)=>typeof B==="string",Q=(B)=>`<${B.localName}${jB(B.id)}${VB(B.classList)}>`,T=(B)=>O(B)?`"${B}"`:e(B)?JSON.stringify(B):String(B),n=(B)=>{if(B===null)return"null";if(typeof B!=="object")return typeof B;if(Array.isArray(B))return"Array";if(Symbol.toStringTag in Object(B))return B[Symbol.toStringTag];return B.constructor?.name||"Object"},A=(B,W,$="debug")=>{if(["error","warn"].includes($))console[$](W,B);return B};class ZB extends Error{constructor(B){super(B);this.name="CircularMutationError"}}var AB=(B)=>B.nodeType===Node.ELEMENT_NODE,FB=(B)=>B instanceof HTMLElement&&B.localName.includes("-"),LB=(B)=>{let W=new Set;if(B.includes("."))W.add("class");if(B.includes("#"))W.add("id");if(B.includes("[")){let $=B.split("[");for(let K=1;K<$.length;K++){let Z=$[K];if(!Z.includes("]"))continue;let J=Z.split("=")[0].trim().replace(/[^a-zA-Z0-9_-]/g,"");if(J)W.add(J)}}return[...W]},qB=(B,W)=>{if(B.length!==W.length)return!1;let $=new Set(B);for(let K of W)if(!$.has(K))return!1;return!0},JB=(B,W,$)=>{let K=new MutationObserver($),Z=LB(W),J={childList:!0,subtree:!0};if(Z.length)J.attributes=!0,J.attributeFilter=Z;return K.observe(B,J),K},s=(B,W,$)=>{let K=B.filter(H).map((Z)=>Z(W,$));return()=>{K.filter(H).forEach((Z)=>Z()),K.length=0}},xB=(B,...W)=>($)=>{let K=($.shadowRoot||$).querySelector(B);if(K)s(W,$,K)},CB=(B,...W)=>($)=>{let K=new Map,Z=$.shadowRoot||$,J=(I)=>{if(!K.has(I))K.set(I,s(W,$,I))},z=(I)=>{let X=K.get(I);if(H(X))X();K.delete(I)},G=(I)=>(X)=>{if(AB(X)){if(X.matches(B))I(X);X.querySelectorAll(B).forEach(I)}},Y=JB(Z,B,(I)=>{for(let X of I)X.addedNodes.forEach(G(J)),X.removedNodes.forEach(G(z))});return Z.querySelectorAll(B).forEach(J),()=>{Y.disconnect(),K.forEach((I)=>I()),K.clear()}},UB=(B,W)=>{let $=new Set,K=()=>Array.from(B.querySelectorAll(W)),Z=j,J,z=0,G=2,Y=()=>{Z=K(),J=JB(B,W,()=>{if(!$.size){J?.disconnect(),J=void 0;return}if(z++,z>G)throw J?.disconnect(),J=void 0,z=0,new ZB("Circular mutation in element selection detected");try{let X=K();if(!qB(Z,X))Z=X,M($)}finally{z--}})};return{[Symbol.toStringTag]:p,get:()=>{if(D($),!$.size)Z=K();else if(!J)Y();return Z}}},MB=(B,W)=>($,K=$)=>{if(!H(W))throw new TypeError(`Invalid event listener provided for "${B} event on element ${Q(K)}`);return K.addEventListener(B,W),()=>K.removeEventListener(B,W)},PB=(B,W)=>($,K=$)=>{K.dispatchEvent(new CustomEvent(B,{detail:H(W)?W(K):W,bubbles:!0}))},OB=(B)=>(W,$)=>{let K=$.localName;if(!FB($))throw new TypeError("Target element must be a custom element");let Z=H(B)?B($):B;if(!e(Z))throw new TypeError("Passed signals must be an object or a provider function");customElements.whenDefined(K).then(()=>{for(let[J,z]of Object.entries(Z)){let G=O(z)?W.getSignal(J):b(z);$.setSignal(J,G)}}).catch((J)=>{throw new Error(`Failed to pass signals to ${Q($)}}`,{cause:J})})};var w=Symbol(),RB=new Set(Object.getOwnPropertyNames(HTMLElement.prototype)),yB=new Set(["constructor","prototype","__proto__","toString","valueOf","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString"]),BB=(B)=>H(B)&&B.length>=2,_B=(B)=>!(RB.has(B)||yB.has(B)),DB=(B,W={},$)=>{class K extends HTMLElement{debug;#B={};#$;static observedAttributes=Object.entries(W)?.filter(([,Z])=>BB(Z)).map(([Z])=>Z)??[];constructor(){super();for(let[Z,J]of Object.entries(W)){if(J==null)continue;let z=BB(J)?J(this,null):H(J)?J(this):J;if(z!=null)this.setSignal(Z,b(z))}}connectedCallback(){if(U){if(this.debug=this.hasAttribute("debug"),this.debug)A(this,"Connected")}let Z=$(this);if(!Array.isArray(Z))throw new TypeError(`Expected array of functions as return value of setup function in ${Q(this)}`);this.#$=s(Z,this,this)}disconnectedCallback(){if(H(this.#$))this.#$();if(U&&this.debug)A(this,"Disconnected")}attributeChangedCallback(Z,J,z){if(z===J||k(this.#B[Z]))return;let G=W[Z];if(!BB(G))return;let Y=G(this,z,J);if(U&&this.debug)A(z,`Attribute "${Z}" of ${Q(this)} changed from ${T(J)} to ${T(z)}, parsed as <${n(Y)}> ${T(Y)}`);this[Z]=Y}getSignal(Z){let J=this.#B[Z];if(U&&this.debug)A(J,`Get ${n(J)} "${String(Z)}" in ${Q(this)}`);return J}setSignal(Z,J){if(!_B(String(Z)))throw new TypeError(`Invalid property name "${String(Z)}". Property names must be valid JavaScript identifiers and not conflict with inherited HTMLElement properties.`);if(!P(J))throw new TypeError(`Expected signal as value for property "${String(Z)}" on ${Q(this)}.`);let z=this.#B[Z],G=C(J);if(this.#B[Z]=J,Object.defineProperty(this,Z,{get:J.get,set:G?J.set:void 0,enumerable:!0,configurable:G}),z&&C(z))z.set(j);if(U&&this.debug)A(J,`Set ${n(J)} "${String(Z)} in ${Q(this)}`)}}return customElements.define(B,K),K};var $B="context-request";class zB extends Event{B;W;$;constructor(B,W,$=!1){super($B,{bubbles:!0,composed:!0});this.context=B;this.callback=W;this.subscribe=$}}var NB=(B)=>(W)=>{let $=(K)=>{let{context:Z,callback:J}=K;if(B.includes(Z)&&H(J))K.stopPropagation(),J(W.getSignal(String(Z)))};return W.addEventListener($B,$),()=>W.removeEventListener($B,$)},TB=(B)=>(W)=>{let $;return W.dispatchEvent(new zB(B,(K)=>{$=K})),$};var GB=(B,W)=>{if(W==null)return;let $=B(W);return Number.isFinite($)?$:void 0},wB=(B,W)=>W!=="false"&&W!=null,SB=(B=0)=>(W,$)=>GB(parseInt,$)??B,kB=(B=0)=>(W,$)=>GB(parseFloat,$)??B,bB=(B="")=>(W,$)=>$??B,EB=(B)=>(W,$)=>$!=null&&B.includes($.toLowerCase())?$:B[0],fB=(B)=>(W,$)=>{if(($??B)==null)throw new ReferenceError("Value and fallback are both null or undefined");if($==null)return B;if($==="")throw new SyntaxError("Empty string is not valid JSON");let K;try{K=JSON.parse($)}catch(Z){throw new SyntaxError(`Failed to parse JSON: ${String(Z)}`,{cause:Z})}return K??B};var IB=(B,W,$)=>O(B)?W.getSignal(B).get():P(B)?B.get():H(B)?B($):w,mB=(B)=>{if(/^(mailto|tel):/i.test(B))return!0;if(B.includes("://"))try{let W=new URL(B,window.location.origin);return["http:","https:","ftp:"].includes(W.protocol)}catch(W){return!1}return!0},dB=(B,W,$)=>{if(/^on/i.test(W))throw new Error(`Unsafe attribute: ${W}`);if($=String($).trim(),!mB($))throw new Error(`Unsafe URL for ${W}: ${$}`);B.setAttribute(W,$)},R=(B,W)=>($,K)=>{let{op:Z,name:J="",read:z,update:G}=W,Y=z(K),I={a:"attribute ",c:"class ",h:"inner HTML",p:"property ",s:"style property ",t:"text content"};if(O(B)&&O(Y)&&$[B]===w)$.attributeChangedCallback(B,null,Y);let X=(F)=>()=>{if(U&&$.debug)A(K,`${F} ${I[Z]+J} of ${Q(K)} in ${Q($)}`);W.resolve?.(K)},q=(F)=>(y)=>{A(y,`Failed to ${F} ${I[Z]+J} of ${Q(K)} in ${Q($)}`,E),W.reject?.(y)};return h(()=>{let F=Symbol(`${Z}:${J}`),y=Symbol(`${Z}-${J}`),L=w;try{L=IB(B,$,K)}catch(V){A(V,`Failed to resolve value of ${T(B)} for ${I[Z]+J} of ${Q(K)} in ${Q($)}`,E);return}if(L===w)L=Y;else if(L===j)L=W.delete?null:Y;if(W.delete&&L===null)N(()=>{return W.delete(K),!0},y).then(X("Deleted")).catch(q("delete"));else if(L!=null){let V=z(K);if(Object.is(L,V))return;N(()=>{return G(K,L),!0},F).then(X("Updated")).catch(q("update"))}})},pB=(B,W)=>($,K)=>{let Z=(z)=>()=>{if(U&&$.debug)A(K,`${z} element in ${Q(K)} in ${Q($)}`);if(H(W?.resolve))W.resolve(K);else{let G=P(B)?B:O(B)?$.getSignal(B):void 0;if(C(G))G.set(0)}},J=(z)=>(G)=>{A(G,`Failed to ${z} element in ${Q(K)} in ${Q($)}`,E),W?.reject?.(G)};return h(()=>{let z=Symbol("i"),G=Symbol("d"),Y=0;try{Y=IB(B,$,K)}catch(I){A(I,`Failed to resolve value of ${T(B)} for insertion or deletion in ${Q(K)} in ${Q($)}`,E);return}if(Y===w)Y=0;if(Y>0){if(!W)throw new TypeError("No inserter provided");N(()=>{for(let I=0;I<Y;I++){let X=W.create(K);if(!X)continue;K.insertAdjacentElement(W.position??"beforeend",X)}return!0},z).then(Z("Inserted")).catch(J("insert"))}else if(Y<0)N(()=>{if(W&&(W.position==="afterbegin"||W.position==="beforeend"))for(let I=0;I>Y;I--)if(W.position==="afterbegin")K.firstElementChild?.remove();else K.lastElementChild?.remove();else K.remove();return!0},G).then(Z("Removed")).catch(J("remove"))})},hB=(B)=>R(B,{op:"t",read:(W)=>W.textContent,update:(W,$)=>{Array.from(W.childNodes).filter((K)=>K.nodeType!==Node.COMMENT_NODE).forEach((K)=>K.remove()),W.append(document.createTextNode($))}}),gB=(B,W=B)=>R(W,{op:"p",name:String(B),read:($)=>(B in $)?$[B]:j,update:($,K)=>{$[B]=K}}),vB=(B,W=B)=>R(W,{op:"a",name:B,read:($)=>$.getAttribute(B),update:($,K)=>{dB($,B,K)},delete:($)=>{$.removeAttribute(B)}}),cB=(B,W=B)=>R(W,{op:"a",name:B,read:($)=>$.hasAttribute(B),update:($,K)=>{$.toggleAttribute(B,K)}}),uB=(B,W=B)=>R(W,{op:"c",name:B,read:($)=>$.classList.contains(B),update:($,K)=>{$.classList.toggle(B,K)}}),iB=(B,W=B)=>R(W,{op:"s",name:B,read:($)=>$.style.getPropertyValue(B),update:($,K)=>{$.style.setProperty(B,K)},delete:($)=>{$.style.removeProperty(B)}}),oB=(B,W,$)=>R(B,{op:"h",read:(K)=>(K.shadowRoot||!W?K:null)?.innerHTML??"",update:(K,Z)=>{if(!Z){if(K.shadowRoot)K.shadowRoot.innerHTML="<slot></slot>";return""}if(W&&!K.shadowRoot)K.attachShadow({mode:W});let J=K.shadowRoot||K;if(J.innerHTML=Z,!$)return"";return J.querySelectorAll("script").forEach((z)=>{let G=document.createElement("script");G.appendChild(document.createTextNode(z.textContent??"")),J.appendChild(G),z.remove()})," with scripts"}});export{R as updateElement,uB as toggleClass,cB as toggleAttribute,b as toSignal,i as state,hB as setText,iB as setStyle,gB as setProperty,vB as setAttribute,UB as selection,NB as provide,OB as pass,MB as on,A as log,C as isState,P as isSignal,k as isComputed,pB as insertOrRemoveElement,xB as first,N as enqueue,PB as emit,h as effect,oB as dangerouslySetInnerHTML,TB as consume,o as computed,DB as component,KB as batch,bB as asString,kB as asNumber,fB as asJSON,SB as asInteger,EB as asEnum,wB as asBoolean,CB as all,j as UNSET,w as RESET,QB as LOG_WARN,HB as LOG_INFO,E as LOG_ERROR,YB as LOG_DEBUG};
