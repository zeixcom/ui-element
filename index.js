var c=($)=>typeof $==="function";var o=($,K)=>Object.prototype.toString.call($)===`[object ${K}]`,Z4=($)=>(K)=>K instanceof $,S=Z4(Error),H4=Z4(Promise),b=($)=>S($)?$:new Error(String($));var R,v=new Set,l=0,a=new Map,n,B4=()=>{n=void 0;let $=Array.from(a.values());a.clear();for(let K of $)K()},G4=()=>{if(n)cancelAnimationFrame(n);n=requestAnimationFrame(B4)};queueMicrotask(B4);var i=($)=>{if(R&&!$.includes(R))$.push(R)},h=($)=>{for(let K of $)if(l)v.add(K);else K()},e=()=>{while(v.size){let $=Array.from(v);v.clear();for(let K of $)K()}},Q4=($)=>{l++;try{$()}finally{e(),l--}},y=($,K)=>{let Z=R;R=K;try{$()}finally{R=Z}},O=($,K)=>new Promise((Z,H)=>{let B=()=>{try{Z($())}catch(Q){H(Q)}};if(K)a.set(K,B);G4()});function L($,...K){let Z=!1,H=()=>y(()=>{if(Z)throw new Error("Circular dependency in effect detected");Z=!0;let B=u(K,$);if(S(B))console.error("Unhandled error in effect:",B);Z=!1},H);H()}var X4="Computed",L4=($,K)=>{if(!K)return!1;return $.name===K.name&&$.message===K.message},G=($,...K)=>{let Z=[],H=j,B,Q=!0,Y=!1,z=!1,J=(F)=>{if(!Object.is(F,H))H=F,Q=!1,B=void 0,Y=!1},w=()=>{Y=j===H,H=j,B=void 0},D=(F)=>{let d=b(F);Y=L4(d,B),H=j,B=d},_=()=>{if(Q=!0,!Y)h(Z)},C4=()=>y(()=>{if(z)throw new Error("Circular dependency in computed detected");Y=!0,z=!0;let F=u(K,$);if(H4(F))w(),F.then((d)=>{J(d),h(Z)}).catch(D);else if(F==null||j===F)w();else if(S(F))D(F);else J(F);z=!1},_),g={[Symbol.toStringTag]:X4,get:()=>{if(i(Z),e(),Q)C4();if(B)throw B;return H},map:(F)=>G(F,g),match:(F)=>{return L(F,g),g}};return g},x=($)=>o($,X4);var J4="State",s=($)=>{let K=[],Z=$,H={[Symbol.toStringTag]:J4,get:()=>{return i(K),Z},set:(B)=>{if(Object.is(Z,B))return;if(Z=B,h(K),j===Z)K.length=0},update:(B)=>{H.set(B(Z))},map:(B)=>G(B,H),match:(B)=>{return L(B,H),H}};return H},U=($)=>o($,J4);var j=Symbol(),P=($)=>U($)||x($),E=($)=>c($)&&!$.length||typeof $==="object"&&$!==null&&("ok"in $)&&c($.ok),f=($)=>P($)?$:E($)?G($):s($),u=($,K)=>{let{ok:Z,nil:H,err:B}=c(K)?{ok:K}:K,Q=[],Y=[],z=!1;for(let w=0;w<$.length;w++){let D=$[w];try{let _=D.get();if(_===j)z=!0;Q[w]=_}catch(_){Y.push(b(_))}}let J=void 0;try{if(z&&H)J=H();else if(Y.length)J=B?B(...Y):Y[0];else if(!z)J=Z(...Q)}catch(w){if(J=b(w),B)J=B(J)}return J};var I=($)=>typeof $==="function",m=($)=>!!$&&typeof $==="object",T=($)=>typeof $==="string";var W=!1,Y4="debug",x4="info",N="warn",A="error",P4=($)=>$?`#${$}`:"",T4=($)=>$.length?`.${Array.from($).join(".")}`:"",q=($)=>`<${$.localName}${P4($.id)}${T4($.classList)}>`,V=($)=>T($)?`"${$}"`:m($)?JSON.stringify($):String($),r=($)=>{if($===null)return"null";if(typeof $!=="object")return typeof $;if(Array.isArray($))return"Array";if(Symbol.toStringTag in Object($))return $[Symbol.toStringTag];return $.constructor?.name||"Object"},X=($,K,Z=Y4)=>{if(W||[A,N].includes(Z))console[Z](K,$);return $};class k{$;K;constructor($,K=[$]){this.host=$;this.targets=K}on($,K){return this.targets.forEach((Z,H)=>{let B;if(I(K))B=K.length===2?K(Z,H):K;else if(m(K)&&I(K.handleEvent))B=K;else{X(K,`Invalid listener provided for ${$} event on element ${q(Z)}`,A);return}Z.addEventListener($,B),this.host.cleanup.push(()=>Z.removeEventListener($,B))}),this}emit($,K){return this.targets.forEach((Z)=>{Z.dispatchEvent(new CustomEvent($,{detail:K,bubbles:!0}))}),this}pass($){return this.targets.forEach(async(K,Z)=>{if(await p.registry.whenDefined(K.localName),K instanceof p){let H;if(I($)&&$.length===2)H=$(K,Z);else if(m($))H=$;else{X($,"Invalid passed signals provided",A);return}Object.entries(H).forEach(([B,Q])=>{if(T(Q))if(Q in this.host.signals)K.set(B,this.host.signals[Q]);else X(Q,`Invalid string key "${Q}" for state ${V(B)}`,N);else try{K.set(B,f(Q))}catch(Y){X(Y,`Invalid source for state ${V(B)}`,N)}})}else X(K,"Target is not a UIElement",A)}),this}sync(...$){return this.targets.forEach((K,Z)=>$.forEach((H)=>H(this.host,K,Z))),this}}var z4="context-request";class j4 extends Event{$;K;Z;constructor($,K,Z=!1){super(z4,{bubbles:!0,composed:!0});this.context=$;this.callback=K;this.subscribe=Z}}var $4=($)=>{let K=$.constructor,Z=K.consumedContexts||[];queueMicrotask(()=>{for(let B of Z)$.dispatchEvent(new j4(B,(Q)=>$.set(String(B),Q??M)))});let H=K.providedContexts||[];if(!H.length)return!1;return $.addEventListener(z4,(B)=>{let{context:Q,callback:Y}=B;if(!H.includes(Q)||!I(Y))return;B.stopPropagation(),Y($.signals[String(Q)])}),!0};var M=Symbol(),A4=($)=>I($)&&!!$.length,F4=($)=>I($)&&!!$.length,K4=($)=>I($)?K4($()):P($)?K4($.get()):$,t=($,K,Z,H)=>{let B=$.states[K];return A4(B)?B(Z,$,H):Z??void 0};class p extends HTMLElement{static registry=customElements;static localName;static observedAttributes;static consumedContexts;static providedContexts;static define($=this.localName){try{if(this.registry.define($,this),W)X($,"Registered custom element")}catch(K){X(K,`Failed to register custom element ${$}`,A)}return this}states={};signals={};cleanup=[];self=new k(this);get root(){return this.shadowRoot||this}debug=!1;attributeChangedCallback($,K,Z){if(Z===K||x(this.signals[$]))return;let H=t(this,$,Z,K);if(W&&this.debug)X(Z,`Attribute "${$}" of ${q(this)} changed from ${V(K)} to ${V(Z)}, parsed as <${r(H)}> ${V(H)}`);this.set($,H??M)}connectedCallback(){if(W){if(this.debug=this.hasAttribute("debug"),this.debug)X(this,"Connected")}for(let[$,K]of Object.entries(this.states)){let Z=A4(K)?K(this.getAttribute($),this):E(K)?G(K):K;this.set($,Z??M)}$4(this)}disconnectedCallback(){if(this.cleanup.forEach(($)=>$()),this.cleanup=[],W&&this.debug)X(this,"Disconnected")}adoptedCallback(){if(W&&this.debug)X(this,"Adopted")}has($){return $ in this.signals}get($){let K=K4(this.signals[$]);if(W&&this.debug)X(K,`Get current value of signal <${r(K)}> ${V($)} in ${q(this)}`);return K}set($,K,Z=!0){if(K==null){X(K,`Attempt to set state ${V($)} to null or undefined in ${q(this)}`,A);return}let H,B=this.signals[$],Q=B?.get();if(!($ in this.signals)){if(F4(K)){X(K,`Cannot use updater function to create a computed signal in ${q(this)}`,A);return}if(W&&this.debug)H="Create";this.signals[$]=f(K)}else if(Z||Q===j||Q===M){if(E(K)){X(K,`Cannot use computed callbacks to update signal ${V($)} in ${q(this)}`,A);return}if(P(K)){if(W&&this.debug)H="Replace";if(this.signals[$]=K,U(B))B.set(j)}else if(U(B)){if(W&&this.debug)H="Update";if(F4(K))B.update(K);else B.set(K)}else{X(K,`Computed signal ${V($)} in ${q(this)} cannot be set`,N);return}}else return;if(W&&this.debug)X(K,`${H} signal <${r(K)}> ${V($)} in ${q(this)}`)}delete($){if(W&&this.debug)X($,`Delete signal ${V($)} from ${q(this)}`);return delete this.signals[$]}first($){let K=this.root.querySelector($);return new k(this,K?[K]:[])}all($){return new k(this,Array.from(this.root.querySelectorAll($)))}}var q4=($,K)=>{if(K==null)return;let Z=$(K);return Number.isFinite(Z)?Z:void 0},U4=($)=>Array.isArray($)&&$[0]?$[0]:$,N4=($)=>$!=="false"&&$!=null,W4=($=0)=>(K)=>q4(parseInt,K)??$,D4=W4(),V4=($=0)=>(K)=>q4(parseFloat,K)??$,_4=V4(),I4=($="")=>(K)=>K??$,R4=I4(),y4=($)=>(K)=>K!=null&&$.includes(K.toLowerCase())?K:U4($),w4=($)=>(K)=>{if(K==null)return $;let Z;try{Z=JSON.parse(K)}catch(H){X(H,"Failed to parse JSON",A)}return Z??$},O4=w4({});var f4=($)=>{if(/^(mailto|tel):/i.test($))return!0;if($.includes("://"))try{let K=new URL($,window.location.origin);return["http:","https:","ftp:"].includes(K.protocol)}catch(K){return!1}return!0},M4=($,K,Z)=>{if(/^on/i.test(K))throw new Error(`Unsafe attribute: ${K}`);if(Z=String(Z).trim(),!f4(Z))throw new Error(`Unsafe URL for ${K}: ${Z}`);$.setAttribute(K,Z)},C=($,K)=>(Z,H)=>{let{op:B,read:Q,update:Y}=K,z=Q(H);if(T($)&&!x(Z.signals[$])){let J=T(z)?t(Z,$,z):z;if(J!=null)Z.set($,J,!1)}L(()=>{let J=M;try{J=T($)?Z.get($):P($)?$.get():I($)?$():M}catch(D){X(D,`Failed to update element ${q(H)} in ${q(Z)}:`,A)}finally{if(J===M)J=z;if(J===j)J=null}let w=Q(H);if(!Object.is(J,w))if((J===null||J==null&&z===null)&&K.delete)O(()=>{return K.delete(H),!0},[H,B]);else if(J==null){if(z)O(()=>{return Y(H,z),!0},[H,B])}else O(()=>{return Y(H,J),!0},[H,B])})},k4=($,K,Z)=>C(K,{op:"create",read:()=>null,update:(H,B)=>{let Q=document.createElement($);for(let[Y,z]of Object.entries(B))M4(Q,Y,z);if(Z)Q.textContent=Z;H.append(Q)}}),S4=($)=>C($,{op:"remove",read:(K)=>!!K,update:(K,Z)=>{if(Z)K.remove()}}),b4=($)=>C($,{op:"text",read:(K)=>K.textContent,update:(K,Z)=>{Array.from(K.childNodes).filter((H)=>H.nodeType!==Node.COMMENT_NODE).forEach((H)=>H.remove()),K.append(document.createTextNode(Z))}}),h4=($,K=!1)=>C($,{op:"html",read:(Z)=>Z.innerHTML,update:(Z,H)=>{if(Z.innerHTML=H,!K)return;Z.querySelectorAll("script").forEach((B)=>{let Q=document.createElement("script");Q.appendChild(document.createTextNode(B.textContent??"")),Z.appendChild(Q),B.remove()})}}),E4=($,K=$)=>C(K,{op:"prop",read:(Z)=>($ in Z)?Z[$]:j,update:(Z,H)=>{Z[$]=H}}),m4=($,K=$)=>C(K,{op:"attr",read:(Z)=>Z.getAttribute($),update:(Z,H)=>{M4(Z,$,H)},delete:(Z)=>{Z.removeAttribute($)}}),p4=($,K=$)=>C(K,{op:"attr",read:(Z)=>Z.hasAttribute($),update:(Z,H)=>{Z.toggleAttribute($,H)}}),g4=($,K=$)=>C(K,{op:"class",read:(Z)=>Z.classList.contains($),update:(Z,H)=>{Z.classList.toggle($,H)}}),d4=($,K=$)=>C(K,{op:"style",read:(Z)=>Z.style.getPropertyValue($),update:(Z,H)=>{Z.style.setProperty($,H)},delete:(Z)=>{Z.style.removeProperty($)}});export{y as watch,$4 as useContext,C as updateElement,g4 as toggleClass,p4 as toggleAttribute,f as toSignal,s as state,b4 as setText,d4 as setStyle,E4 as setProperty,m4 as setAttribute,S4 as removeElement,t as parse,X as log,U as isState,P as isSignal,x as isComputed,O as enqueue,L as effect,h4 as dangerouslySetInnerHTML,k4 as createElement,G as computed,Q4 as batch,I4 as asStringWithDefault,R4 as asString,V4 as asNumberWithDefault,_4 as asNumber,w4 as asJSONWithDefault,O4 as asJSON,W4 as asIntegerWithDefault,D4 as asInteger,y4 as asEnum,N4 as asBoolean,j as UNSET,p as UIElement,k as UI,M as RESET,N as LOG_WARN,x4 as LOG_INFO,A as LOG_ERROR,Y4 as LOG_DEBUG};
