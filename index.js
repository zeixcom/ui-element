var d=($)=>typeof $==="function";var c=($,K)=>Object.prototype.toString.call($)===`[object ${K}]`,Z4=($)=>(K)=>K instanceof $,k=Z4(Error),H4=Z4(Promise),S=($)=>k($)?$:new Error(String($));var R,o=new Set,t=0,a=new Map,v,B4=()=>{v=void 0;let $=Array.from(a.values());a.clear();for(let K of $)K()},V4=()=>{if(v)cancelAnimationFrame(v);v=requestAnimationFrame(B4)};queueMicrotask(B4);var i=($)=>{if(R&&!$.includes(R))$.push(R)},b=($)=>{for(let K of $)if(t)o.add(K);else K()},e=()=>{while(o.size){let $=Array.from(o);o.clear();for(let K of $)K()}},J4=($)=>{t++;try{$()}finally{e(),t--}},y=($,K)=>{let Z=R;R=K;try{$()}finally{R=Z}},O=($,K)=>new Promise((Z,H)=>{let B=()=>{try{Z($())}catch(J){H(J)}};if(K)a.set(K,B);V4()});function x($,...K){let Z=!1,H=()=>y(()=>{if(Z)throw new Error("Circular dependency in effect detected");Z=!0;let B=n(K,$);if(k(B))console.error("Unhandled error in effect:",B);Z=!1},H);H()}var Q4="Computed",M4=($,K)=>{if(!K)return!1;return $.name===K.name&&$.message===K.message},w=($,...K)=>{let Z=[],H=j,B,J=!0,Q=!1,X=!1,Y=(F)=>{if(!Object.is(F,H))H=F,J=!1,B=void 0,Q=!1},z=()=>{Q=j===H,H=j,B=void 0},_=(F)=>{let g=S(F);Q=M4(g,B),H=j,B=g},L=()=>{if(J=!0,!Q)b(Z)},q4=()=>y(()=>{if(X)throw new Error("Circular dependency in computed detected");Q=!0,X=!0;let F=n(K,$);if(H4(F))z(),F.then((g)=>{Y(g),b(Z)}).catch(_);else if(F==null||j===F)z();else if(k(F))_(F);else Y(F);X=!1},L),p={[Symbol.toStringTag]:Q4,get:()=>{if(i(Z),e(),J)q4();if(B)throw B;return H},map:(F)=>w(F,p),match:(F)=>{return x(F,p),p}};return p},U=($)=>c($,Q4);var X4="State",u=($)=>{let K=[],Z=$,H={[Symbol.toStringTag]:X4,get:()=>{return i(K),Z},set:(B)=>{if(Object.is(Z,B))return;if(Z=B,b(K),j===Z)K.length=0},update:(B)=>{H.set(B(Z))},map:(B)=>w(B,H),match:(B)=>{return x(B,H),H}};return H},D=($)=>c($,X4);var j=Symbol(),N=($)=>D($)||U($),E=($)=>d($)&&!$.length||typeof $==="object"&&$!==null&&("ok"in $)&&d($.ok),f=($)=>N($)?$:E($)?w($):u($),n=($,K)=>{let{ok:Z,nil:H,err:B}=d(K)?{ok:K}:K,J=[],Q=[],X=!1;for(let z=0;z<$.length;z++){let _=$[z];try{let L=_.get();if(L===j)X=!0;J[z]=L}catch(L){Q.push(S(L))}}let Y=void 0;try{if(X&&H)Y=H();else if(Q.length)Y=B?B(...Q):Q[0];else if(!X)Y=Z(...J)}catch(z){if(Y=S(z),B)Y=B(Y)}return Y};var M=($)=>typeof $==="function",h=($)=>!!$&&typeof $==="object",P=($)=>typeof $==="string";var q=!1,Y4="debug",C4="info",T="warn",I="error",G4=($)=>$?`#${$}`:"",w4=($)=>$.length?`.${Array.from($).join(".")}`:"",A=($)=>`<${$.localName}${G4($.id)}${w4($.classList)}>`,V=($)=>P($)?`"${$}"`:h($)?JSON.stringify($):String($),s=($)=>{if($===null)return"null";if(typeof $!=="object")return typeof $;if(Array.isArray($))return"Array";if(Symbol.toStringTag in Object($))return $[Symbol.toStringTag];return $.constructor?.name||"Object"},W=($,K,Z=Y4)=>{if(q||[I,T].includes(Z))console[Z](K,$);return $};var r=($,K=[$])=>{let Z={host:$,targets:K,on:(H,B)=>{return K.forEach((J,Q)=>{let X;if(M(B))X=B.length===2?B(J,Q):B;else if(h(B)&&M(B.handleEvent))X=B;else{W(B,`Invalid listener provided for ${H} event on element ${A(J)}`,I);return}J.addEventListener(H,X),$.cleanup.push(()=>J.removeEventListener(H,X))}),Z},emit:(H,B)=>{return K.forEach((J)=>{J.dispatchEvent(new CustomEvent(H,{detail:B,bubbles:!0}))}),Z},pass:(H)=>{return K.forEach(async(B,J)=>{if(await m.registry.whenDefined(B.localName),B instanceof m){let Q;if(M(H)&&H.length===2)Q=H(B,J);else if(h(H))Q=H;else{W(H,"Invalid passed signals provided",I);return}Object.entries(Q).forEach(([X,Y])=>{if(P(Y))if(Y in $.signals)B.set(X,$.signals[Y]);else W(Y,`Invalid string key "${Y}" for state ${V(X)}`,T);else try{B.set(X,f(Y))}catch(z){W(z,`Invalid source for state ${V(X)}`,T)}})}else W(B,"Target is not a UIElement",I)}),Z},sync:(...H)=>{return K.forEach((B,J)=>H.forEach((Q)=>Q($,B,J))),Z}};return Z};var z4="context-request";class W4 extends Event{$;K;Z;constructor($,K,Z=!1){super(z4,{bubbles:!0,composed:!0});this.context=$;this.callback=K;this.subscribe=Z}}var $4=($)=>{let K=$.constructor,Z=K.consumedContexts||[];queueMicrotask(()=>{for(let B of Z)$.dispatchEvent(new W4(B,(J)=>$.set(String(B),J??C)))});let H=K.providedContexts||[];if(!H.length)return!1;return $.addEventListener(z4,(B)=>{let{context:J,callback:Q}=B;if(!H.includes(J)||!M(Q))return;B.stopPropagation(),Q($.signals[String(J)])}),!0};var C=Symbol(),F4=($)=>M($)&&!!$.length,j4=($)=>M($)&&!!$.length,K4=($)=>M($)?K4($()):N($)?K4($.get()):$,l=($,K,Z,H)=>{let B=$.states[K];return F4(B)?B(Z,$,H):Z??void 0};class m extends HTMLElement{static registry=customElements;static localName;static observedAttributes;static consumedContexts;static providedContexts;static define($=this.localName){try{if(this.registry.define($,this),q)W($,"Registered custom element")}catch(K){W(K,`Failed to register custom element ${$}`,I)}return this}states={};signals={};cleanup=[];self=r(this);get root(){return this.shadowRoot||this}debug=!1;attributeChangedCallback($,K,Z){if(Z===K||U(this.signals[$]))return;let H=l(this,$,Z,K);if(q&&this.debug)W(Z,`Attribute "${$}" of ${A(this)} changed from ${V(K)} to ${V(Z)}, parsed as <${s(H)}> ${V(H)}`);this.set($,H??C)}connectedCallback(){if(q){if(this.debug=this.hasAttribute("debug"),this.debug)W(this,"Connected")}for(let[$,K]of Object.entries(this.states)){let Z=F4(K)?K(this.getAttribute($),this):E(K)?w(K):K;this.set($,Z??C)}$4(this)}disconnectedCallback(){if(this.cleanup.forEach(($)=>$()),this.cleanup=[],q&&this.debug)W(this,"Disconnected")}adoptedCallback(){if(q&&this.debug)W(this,"Adopted")}has($){return $ in this.signals}get($){let K=K4(this.signals[$]);if(q&&this.debug)W(K,`Get current value of signal <${s(K)}> ${V($)} in ${A(this)}`);return K}set($,K,Z=!0){if(K==null){W(K,`Attempt to set state ${V($)} to null or undefined in ${A(this)}`,I);return}let H,B=this.signals[$],J=B?.get();if(!($ in this.signals)){if(j4(K)){W(K,`Cannot use updater function to create a computed signal in ${A(this)}`,I);return}if(q&&this.debug)H="Create";this.signals[$]=f(K)}else if(Z||J===j||J===C){if(E(K)){W(K,`Cannot use computed callbacks to update signal ${V($)} in ${A(this)}`,I);return}if(N(K)){if(q&&this.debug)H="Replace";if(this.signals[$]=K,D(B))B.set(j)}else if(D(B)){if(q&&this.debug)H="Update";if(j4(K))B.update(K);else B.set(K)}else{W(K,`Computed signal ${V($)} in ${A(this)} cannot be set`,T);return}}else return;if(q&&this.debug)W(K,`${H} signal <${s(K)}> ${V($)} in ${A(this)}`)}delete($){if(q&&this.debug)W($,`Delete signal ${V($)} from ${A(this)}`);return delete this.signals[$]}first($){let K=this.root.querySelector($);if(this.shadowRoot&&!K)K=this.querySelector($);return r(this,K?[K]:[])}all($){let K=this.root.querySelectorAll($);if(this.shadowRoot&&!K.length)K=this.querySelectorAll($);return r(this,Array.from(K))}}var I4=($,K)=>{if(K==null)return;let Z=$(K);return Number.isFinite(Z)?Z:void 0},L4=($)=>Array.isArray($)&&$[0]?$[0]:$,x4=($)=>$!=="false"&&$!=null,U4=($=0)=>(K)=>I4(parseInt,K)??$,N4=($=0)=>(K)=>I4(parseFloat,K)??$,P4=($="")=>(K)=>K??$,D4=($)=>(K)=>K!=null&&$.includes(K.toLowerCase())?K:L4($),T4=($)=>(K)=>{if(K==null)return $;let Z;try{Z=JSON.parse(K)}catch(H){W(H,"Failed to parse JSON",I)}return Z??$};var _4=($)=>{if(/^(mailto|tel):/i.test($))return!0;if($.includes("://"))try{let K=new URL($,window.location.origin);return["http:","https:","ftp:"].includes(K.protocol)}catch(K){return!1}return!0},A4=($,K,Z)=>{if(/^on/i.test(K))throw new Error(`Unsafe attribute: ${K}`);if(Z=String(Z).trim(),!_4(Z))throw new Error(`Unsafe URL for ${K}: ${Z}`);$.setAttribute(K,Z)},G=($,K)=>(Z,H,B)=>{let{op:J,read:Q,update:X}=K,Y=Q(H);if(P($)&&!U(Z.signals[$])){let z=P(Y)?l(Z,$,Y):Y;if(z!=null)Z.set($,z,!1)}x(()=>{let z=C;try{z=P($)?Z.get($):N($)?$.get():M($)?$(H,B):C}catch(L){W(L,`Failed to update element ${A(H)} in ${A(Z)}:`,I)}finally{if(z===C)z=Y;if(z===j)z=null}let _=Q(H);if(!Object.is(z,_))if((z===null||z==null&&Y===null)&&K.delete)O(()=>{return K.delete(H),!0},[H,J]);else if(z==null){if(Y)O(()=>{return X(H,Y),!0},[H,J])}else O(()=>{return X(H,z),!0},[H,J])})},R4=($,K,Z)=>G(K,{op:"create",read:()=>null,update:(H,B)=>{let J=document.createElement($);for(let[Q,X]of Object.entries(B))A4(J,Q,X);if(Z)J.textContent=Z;H.append(J)}}),y4=($)=>G($,{op:"remove",read:(K)=>!!K,update:(K,Z)=>{if(Z)K.remove()}}),O4=($)=>G($,{op:"text",read:(K)=>K.textContent,update:(K,Z)=>{Array.from(K.childNodes).filter((H)=>H.nodeType!==Node.COMMENT_NODE).forEach((H)=>H.remove()),K.append(document.createTextNode(Z))}}),f4=($,K,Z)=>G($,{op:"html",read:(H)=>(H.shadowRoot||!K?H:null)?.innerHTML??"",update:(H,B)=>{if(!B){if(H.shadowRoot)H.shadowRoot.innerHTML="<slot></slot>";return}if(K&&!H.shadowRoot)H.attachShadow({mode:K});let J=H.shadowRoot||H;if(J.innerHTML=B,!Z)return;J.querySelectorAll("script").forEach((Q)=>{let X=document.createElement("script");X.appendChild(document.createTextNode(Q.textContent??"")),J.appendChild(X),Q.remove()})}}),k4=($,K=$)=>G(K,{op:"prop",read:(Z)=>($ in Z)?Z[$]:j,update:(Z,H)=>{Z[$]=H}}),S4=($,K=$)=>G(K,{op:"attr",read:(Z)=>Z.getAttribute($),update:(Z,H)=>{A4(Z,$,H)},delete:(Z)=>{Z.removeAttribute($)}}),b4=($,K=$)=>G(K,{op:"attr",read:(Z)=>Z.hasAttribute($),update:(Z,H)=>{Z.toggleAttribute($,H)}}),E4=($,K=$)=>G(K,{op:"class",read:(Z)=>Z.classList.contains($),update:(Z,H)=>{Z.classList.toggle($,H)}}),h4=($,K=$)=>G(K,{op:"style",read:(Z)=>Z.style.getPropertyValue($),update:(Z,H)=>{Z.style.setProperty($,H)},delete:(Z)=>{Z.style.removeProperty($)}});export{y as watch,$4 as useContext,G as updateElement,E4 as toggleClass,b4 as toggleAttribute,f as toSignal,u as state,O4 as setText,h4 as setStyle,k4 as setProperty,S4 as setAttribute,y4 as removeElement,l as parse,W as log,D as isState,N as isSignal,U as isComputed,O as enqueue,x as effect,f4 as dangerouslySetInnerHTML,R4 as createElement,w as computed,J4 as batch,P4 as asString,N4 as asNumber,T4 as asJSON,U4 as asInteger,D4 as asEnum,x4 as asBoolean,j as UNSET,m as UIElement,C as RESET,T as LOG_WARN,C4 as LOG_INFO,I as LOG_ERROR,Y4 as LOG_DEBUG};
