var z=($)=>typeof $==="function",p=($,W)=>Object.prototype.toString.call($)===`[object ${W}]`,h=($)=>$ instanceof Error?$:Error(String($));class b extends Error{constructor($){super(`Circular dependency in ${$} detected`);return this}}var S,v=new Set,l=0,r=new Map,c,I$=()=>{c=void 0;let $=Array.from(r.values());r.clear();for(let W of $)W()},V$=()=>{if(c)cancelAnimationFrame(c);c=requestAnimationFrame(I$)};queueMicrotask(I$);var m=($)=>{let W=new Set,B=$;return B.off=(Z)=>{W.add(Z)},B.cleanup=()=>{for(let Z of W)Z();W.clear()},B},O=($)=>{if(S&&!$.has(S)){let W=S;$.add(W),S.off(()=>{$.delete(W)})}},y=($)=>{for(let W of $)if(l)v.add(W);else W()},u=()=>{while(v.size){let $=Array.from(v);v.clear();for(let W of $)W()}},K$=($)=>{l++;try{$()}finally{u(),l--}},g=($,W)=>{let B=S;S=W;try{$()}finally{S=B}},k=($,W)=>new Promise((B,Z)=>{r.set(W||Symbol(),()=>{try{B($())}catch(H){Z(H)}}),V$()});var a="State",i=($)=>{let W=new Set,B=$,Z={[Symbol.toStringTag]:a,get:()=>{return O(W),B},set:(H)=>{if(Object.is(B,H))return;if(B=H,y(W),j===B)W.clear()},update:(H)=>{Z.set(H(B))}};return Z},M=($)=>p($,a);var f="Computed",o=($)=>{let W=new Set,B=j,Z,H,J=!0,I=!1,K=!1,Q=(A)=>{if(!Object.is(A,B))B=A,I=!0;Z=void 0,J=!1},X=()=>{I=j!==B,B=j,Z=void 0},G=(A)=>{let C=h(A);I=!Z||C.name!==Z.name||C.message!==Z.message,B=j,Z=C},x=(A)=>(C)=>{if(K=!1,H=void 0,A(C),I)y(W)},q=m(()=>{if(J=!0,H?.abort("Aborted because source signal changed"),W.size)y(W);else q.cleanup()}),T=()=>g(()=>{if(K)throw new b("computed");if(I=!1,z($)&&$.constructor.name==="AsyncFunction"){if(H)return B;H=new AbortController,H.signal.addEventListener("abort",()=>{K=!1,H=void 0,T()},{once:!0})}let A;K=!0;try{A=H?$(H.signal):$()}catch(C){if(C instanceof DOMException&&C.name==="AbortError")X();else G(C);K=!1;return}if(A instanceof Promise)A.then(x(Q),x(G));else if(A==null||j===A)X();else Q(A);K=!1},q);return{[Symbol.toStringTag]:f,get:()=>{if(O(W),u(),J)T();if(Z)throw Z;return B}}},d=($)=>p($,f),t=($)=>z($)&&$.length<2;var j=Symbol(),_=($)=>M($)||d($),D=($)=>_($)?$:t($)?o($):i($);function E($){let{signals:W,ok:B,err:Z=console.error,nil:H=()=>{}}=z($)?{signals:[],ok:$}:$,J=!1,I=m(()=>g(()=>{if(J)throw new b("effect");J=!0;let K=[],Q=!1,X=W.map((x)=>{try{let q=x.get();if(q===j)Q=!0;return q}catch(q){return K.push(h(q)),j}}),G=void 0;try{G=Q?H():K.length?Z(...K):B(...X)}catch(x){G=Z(h(x))}finally{if(z(G))I.off(G)}J=!1},I));return I(),()=>I.cleanup()}var V=!1,X$="debug",C$="info",Q$="warn",R="error",y$=($)=>$?`#${$}`:"",M$=($)=>$.length?`.${Array.from($).join(".")}`:"",e=($)=>!!$&&typeof $==="object",N=($)=>typeof $==="string",Y$=($,W)=>N(W)&&(W in $)&&z($[W]),G$=($)=>$.nodeType===Node.ELEMENT_NODE,$$=($)=>$.localName.includes("-"),z$=($)=>{if(!$$($))return!0;let W=customElements.get($.localName);return!!W&&$ instanceof W},Y=($)=>`<${$.localName}${y$($.id)}${M$($.classList)}>`,w=($)=>N($)?`"${$}"`:e($)?JSON.stringify($):String($),n=($)=>{if($===null)return"null";if(typeof $!=="object")return typeof $;if(Array.isArray($))return"Array";if(Symbol.toStringTag in Object($))return $[Symbol.toStringTag];return $.constructor?.name||"Object"},F=($,W,B=X$)=>{if(V||[R,Q$].includes(B))console[B](W,$);return $};class j$ extends Error{constructor($){super($);this.name="CircularMutationError"}}var U$=($)=>{let W=new Set;if($.includes("."))W.add("class");if($.includes("#"))W.add("id");if($.includes("[")){let B=$.split("[");for(let Z=1;Z<B.length;Z++){let H=B[Z];if(!H.includes("]"))continue;let J=H.split("=")[0].trim().replace(/[^a-zA-Z0-9_-]/g,"");if(J)W.add(J)}}return[...W]},P$=($,W)=>{if($.length!==W.length)return!1;let B=new Set($);for(let Z of W)if(!B.has(Z))return!1;return!0},B$=($,W,B)=>{let Z=new MutationObserver(B),H=U$(W),J={childList:!0,subtree:!0};if(H.length)J.attributes=!0,J.attributeFilter=H;return Z.observe($,J),Z},W$=($,W)=>{let B=new Set,Z=()=>Array.from($.querySelectorAll(W)),H=j,J,I=0,K=2,Q=()=>{H=Z(),J=B$($,W,()=>{if(!B.size){J?.disconnect(),J=void 0;return}if(I++,I>K)throw J?.disconnect(),J=void 0,I=0,new j$("Circular mutation in element selection detected");try{let X=Z();if(!P$(H,X))H=X,y(B)}finally{I--}})};return{[Symbol.toStringTag]:f,get:()=>{if(O(B),!B.size)H=Z();else if(!J)Q();return H}}},O$=($)=>(W)=>W$(W,$),_$=($,W,B)=>(Z)=>()=>W$(Z,$).get().reduce(W,B),D$=($,W,B=!1)=>(Z,H=Z)=>{if(!z(W))throw new TypeError(`Invalid event listener provided for "${$} event on element ${Y(H)}`);return H.addEventListener($,W,B),()=>H.removeEventListener($,W)},A$=($,W,B,Z,H,J=!1)=>{let I=new Set,K=H,Q,X,G=()=>{Q=(x)=>{let q=Z($,W,x,K);if(!Object.is(q,K)){if(K=q,I.size>0)y(I);else if(X)X()}},W.addEventListener(B,Q,J),X=()=>{if(Q)W.removeEventListener(B,Q),Q=void 0;X=void 0}};return{[Symbol.toStringTag]:f,get:()=>{if(O(I),I.size&&!Q)G();return K}}},R$=($,W,B,Z)=>(H)=>{let J=H.querySelector($);if(!J)throw new Error(`Element not found for selector "${$}" in ${Y(H)}`);let I=z(Z)?Z(H,J):Z;return A$(H,J,W,B,I)},q$=($,W,B)=>()=>{if(!$||!z$($))return B;let Z=W in $?$[W]:B;return Z==null||Z===j?B:Z},N$=($,W,B)=>(Z)=>q$(Z.querySelector($),W,B);var U=Symbol(),w$=new Set(["constructor","prototype"]),T$=new Set(["id","class","className","title","role","style","dataset","lang","dir","hidden","children","innerHTML","outerHTML","textContent","innerText"]),Z$=($)=>z($)&&$.length>=2,F$=($)=>{if(w$.has($))return`Property name "${$}" is a reserved word`;if(T$.has($))return`Property name "${$}" conflicts with inherited HTMLElement property`;return null},H$=($,W,B=W)=>{let Z=$.filter(z).map((H)=>H(W,B));return()=>{Z.filter(z).forEach((H)=>H()),Z.length=0}},S$=()=>({first:($,...W)=>(B)=>{let Z=(B.shadowRoot||B).querySelector($);if(Z)H$(W,B,Z)},all:($,...W)=>(B)=>{let Z=new Map,H=B.shadowRoot||B,J=(X)=>{if(!Z.has(X))Z.set(X,H$(W,B,X))},I=(X)=>{let G=Z.get(X);if(z(G))G();Z.delete(X)},K=(X)=>(G)=>{if(G$(G)){if(G.matches($))X(G);G.querySelectorAll($).forEach(X)}},Q=B$(H,$,(X)=>{for(let G of X)G.addedNodes.forEach(K(J)),G.removedNodes.forEach(K(I))});return H.querySelectorAll($).forEach(J),()=>{Q.disconnect(),Z.forEach((X)=>X()),Z.clear()}}}),k$=($,W={},B)=>{for(let Z of Object.keys(W)){let H=F$(Z);if(H)throw new TypeError(`${H} in component "${$}".`)}customElements.define($,class extends HTMLElement{debug;#$={};#B;static observedAttributes=Object.entries(W)?.filter(([,Z])=>Z$(Z)).map(([Z])=>Z)??[];static isComponent(Z){return#$ in Z}constructor(){super();for(let[Z,H]of Object.entries(W)){if(H==null)continue;let J=Z$(H)?H(this,null):z(H)?H(this):H;if(J!=null)this.setSignal(Z,D(J))}}connectedCallback(){if(V){if(this.debug=this.hasAttribute("debug"),this.debug)F(this,"Connected")}let Z=B(this,S$());if(!Array.isArray(Z))throw new TypeError(`Expected array of functions as return value of setup function in ${Y(this)}`);this.#B=H$(Z,this)}disconnectedCallback(){if(z(this.#B))this.#B();if(V&&this.debug)F(this,"Disconnected")}attributeChangedCallback(Z,H,J){if(J===H||d(this.#$[Z]))return;let I=W[Z];if(!Z$(I))return;let K=I(this,J,H);if(V&&this.debug)F(J,`Attribute "${Z}" of ${Y(this)} changed from ${w(H)} to ${w(J)}, parsed as <${n(K)}> ${w(K)}`);this[Z]=K}getSignal(Z){let H=this.#$[Z];if(V&&this.debug)F(H,`Get ${n(H)} "${String(Z)}" in ${Y(this)}`);return H}setSignal(Z,H){let J=F$(String(Z));if(J)throw new TypeError(`${J} on ${Y(this)}.`);if(!_(H))throw new TypeError(`Expected signal as value for property "${String(Z)}" on ${Y(this)}.`);let I=this.#$[Z],K=M(H);if(this.#$[Z]=H,Object.defineProperty(this,Z,{get:H.get,set:K?H.set:void 0,enumerable:!0,configurable:K}),I&&M(I))I.set(j);if(V&&this.debug)F(H,`Set ${n(H)} "${String(Z)} in ${Y(this)}`)}})};var J$="context-request";class x$ extends Event{$;W;B;constructor($,W,B=!1){super(J$,{bubbles:!0,composed:!0});this.context=$;this.callback=W;this.subscribe=B}}var E$=($)=>(W)=>{let B=(Z)=>{let{context:H,callback:J}=Z;if($.includes(H)&&z(J))Z.stopImmediatePropagation(),J(W.getSignal(String(H)))};return W.addEventListener(J$,B),()=>W.removeEventListener(J$,B)},b$=($,W)=>(B)=>{let Z=D(W);return B.dispatchEvent(new x$($,(H)=>{Z=H})),Z};var L$=($,W)=>{if(W==null)return;let B=$(W);return Number.isFinite(B)?B:void 0},f$=()=>($,W)=>W!=="false"&&W!=null,d$=($=0)=>(W,B)=>{if(B==null)return $;let Z=B.trim();if(Z==="")return $;if(Z.toLowerCase().startsWith("0x")){let J=parseInt(Z,16);return Number.isFinite(J)?J:$}let H=L$(parseFloat,B);return H!=null?Math.trunc(H):$},h$=($=0)=>(W,B)=>L$(parseFloat,B)??$,m$=($="")=>(W,B)=>B??$,g$=($)=>(W,B)=>{if(B==null)return $[0];let Z=B.toLowerCase();return $.find((J)=>J.toLowerCase()===Z)?B:$[0]},p$=($)=>(W,B)=>{if((B??$)==null)throw new ReferenceError("Value and fallback are both null or undefined");if(B==null)return $;if(B==="")throw new SyntaxError("Empty string is not valid JSON");let Z;try{Z=JSON.parse(B)}catch(H){throw new SyntaxError(`Failed to parse JSON: ${String(H)}`,{cause:H})}return Z??$};var s=($,W,B)=>N($)?W.getSignal($).get():_($)?$.get():z($)?$(B):U,v$=($)=>{if(/^(mailto|tel):/i.test($))return!0;if($.includes("://"))try{let W=new URL($,window.location.origin);return["http:","https:","ftp:"].includes(W.protocol)}catch{return!1}return!0},c$=($,W,B)=>{if(/^on/i.test(W))throw new Error(`Unsafe attribute: ${W}`);if(B=String(B).trim(),!v$(B))throw new Error(`Unsafe URL for ${W}: ${B}`);$.setAttribute(W,B)},P=($,W)=>(B,Z)=>{let{op:H,name:J="",read:I,update:K}=W,Q=I(Z),X={a:"attribute ",c:"class ",h:"inner HTML",p:"property ",s:"style property ",t:"text content"};if(N($)&&N(Q)&&B[$]===U)B.attributeChangedCallback($,null,Q);let G=(q)=>()=>{if(V&&B.debug)F(Z,`${q} ${X[H]+J} of ${Y(Z)} in ${Y(B)}`);W.resolve?.(Z)},x=(q)=>(T)=>{F(T,`Failed to ${q} ${X[H]+J} of ${Y(Z)} in ${Y(B)}`,R),W.reject?.(T)};return E(()=>{let q=Symbol(`${H}:${J}`),T=Symbol(`${H}-${J}`),L=U;try{L=s($,B,Z)}catch(A){F(A,`Failed to resolve value of ${w($)} for ${X[H]+J} of ${Y(Z)} in ${Y(B)}`,R);return}if(L===U)L=Q;else if(L===j)L=W.delete?null:Q;if(W.delete&&L===null)k(()=>{return W.delete(Z),!0},T).then(G("Deleted")).catch(x("delete"));else if(L!=null){let A=I(Z);if(Object.is(L,A))return;k(()=>{return K(Z,L),!0},q).then(G("Updated")).catch(x("update"))}})},u$=($,W)=>(B,Z)=>{let H=(I)=>()=>{if(V&&B.debug)F(Z,`${I} element in ${Y(Z)} in ${Y(B)}`);if(z(W?.resolve))W.resolve(Z);else{let K=_($)?$:N($)?B.getSignal($):void 0;if(M(K))K.set(0)}},J=(I)=>(K)=>{F(K,`Failed to ${I} element in ${Y(Z)} in ${Y(B)}`,R),W?.reject?.(K)};return E(()=>{let I=Symbol("i"),K=Symbol("d"),Q=0;try{Q=s($,B,Z)}catch(X){F(X,`Failed to resolve value of ${w($)} for insertion or deletion in ${Y(Z)} in ${Y(B)}`,R);return}if(Q===U)Q=0;if(Q>0){if(!W)throw new TypeError("No inserter provided");k(()=>{for(let X=0;X<Q;X++){let G=W.create(Z);if(!G)continue;Z.insertAdjacentElement(W.position??"beforeend",G)}return!0},I).then(H("Inserted")).catch(J("insert"))}else if(Q<0)k(()=>{if(W&&(W.position==="afterbegin"||W.position==="beforeend"))for(let X=0;X>Q;X--)if(W.position==="afterbegin")Z.firstElementChild?.remove();else Z.lastElementChild?.remove();else Z.remove();return!0},K).then(H("Removed")).catch(J("remove"))})},i$=($)=>P($,{op:"t",read:(W)=>W.textContent,update:(W,B)=>{Array.from(W.childNodes).filter((Z)=>Z.nodeType!==Node.COMMENT_NODE).forEach((Z)=>Z.remove()),W.append(document.createTextNode(B))}}),o$=($,W=$)=>P(W,{op:"p",name:String($),read:(B)=>($ in B)?B[$]:j,update:(B,Z)=>{B[$]=Z}}),n$=($)=>P($,{op:"p",name:"hidden",read:(W)=>!W.hidden,update:(W,B)=>{W.hidden=!B}}),s$=($,W=$)=>P(W,{op:"a",name:$,read:(B)=>B.getAttribute($),update:(B,Z)=>{c$(B,$,Z)},delete:(B)=>{B.removeAttribute($)}}),l$=($,W=$)=>P(W,{op:"a",name:$,read:(B)=>B.hasAttribute($),update:(B,Z)=>{B.toggleAttribute($,Z)}}),r$=($,W=$)=>P(W,{op:"c",name:$,read:(B)=>B.classList.contains($),update:(B,Z)=>{B.classList.toggle($,Z)}}),a$=($,W=$)=>P(W,{op:"s",name:$,read:(B)=>B.style.getPropertyValue($),update:(B,Z)=>{B.style.setProperty($,Z)},delete:(B)=>{B.style.removeProperty($)}}),t$=($,W={})=>P($,{op:"h",read:(B)=>(B.shadowRoot||!W.shadowRootMode?B:null)?.innerHTML??"",update:(B,Z)=>{let{shadowRootMode:H,allowScripts:J}=W;if(!Z){if(B.shadowRoot)B.shadowRoot.innerHTML="<slot></slot>";return""}if(H&&!B.shadowRoot)B.attachShadow({mode:H});let I=B.shadowRoot||B;if(I.innerHTML=Z,!J)return"";return I.querySelectorAll("script").forEach((K)=>{let Q=document.createElement("script");Q.appendChild(document.createTextNode(K.textContent??"")),I.appendChild(Q),K.remove()})," with scripts"}}),e$=($,W)=>(B,Z=B)=>E(()=>{let H;try{H=s(W,B,Z)}catch(J){F(J,`Failed to resolve value of ${w(W)} for custom event detail emitted on ${Y(Z)} in ${Y(B)}`,R);return}if(H===U||H===j)return;Z.dispatchEvent(new CustomEvent($,{detail:H,bubbles:!0}))}),$B=($)=>(W,B)=>{let Z=z($)?$(B):$;if(!e(Z))throw new TypeError("Passed signals must be an object or a provider function");let H=E(()=>{for(let[J,I]of Object.entries(Z)){let K;try{K=s(I,W,B)}catch(Q){throw new Error(`Failed to resolve signal ${J} for ${Y(B)}`,{cause:Q})}if(K==null||K===U)continue;B[J]=K}});if(!$$(B))return H();customElements.whenDefined(B.localName).then(()=>{if(!Y$(B,"setSignal"))return H();for(let[J,I]of Object.entries(Z))B.setSignal(J,N(I)?W.getSignal(I):D(I))}).catch((J)=>{throw new Error(`Failed to pass signals to ${Y(B)}`,{cause:J})})};export{P as updateElement,r$ as toggleClass,l$ as toggleAttribute,D as toSignal,i as state,n$ as show,i$ as setText,a$ as setStyle,o$ as setProperty,s$ as setAttribute,A$ as sensor,W$ as selection,q$ as read,E$ as provide,$B as pass,D$ as on,F as log,M as isState,_ as isSignal,d as isComputed,u$ as insertOrRemoveElement,O$ as fromSelector,R$ as fromEvent,_$ as fromDescendants,N$ as fromDescendant,b$ as fromContext,k as enqueue,e$ as emit,E as effect,t$ as dangerouslySetInnerHTML,o as computed,k$ as component,K$ as batch,m$ as asString,h$ as asNumber,p$ as asJSON,d$ as asInteger,g$ as asEnum,f$ as asBoolean,j as UNSET,U as RESET,Q$ as LOG_WARN,C$ as LOG_INFO,R as LOG_ERROR,X$ as LOG_DEBUG};

//# debugId=9C20F169FE83783F64756E2164756E21
