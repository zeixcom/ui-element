var H=(B)=>typeof B==="function",g=(B,W)=>Object.prototype.toString.call(B)===`[object ${W}]`,f=(B)=>B instanceof Error?B:Error(String(B));class S extends Error{constructor(B){super(`Circular dependency in ${B} detected`);return this}}var _,v=new Set,s=0,l=new Map,c,KB=()=>{c=void 0;let B=Array.from(l.values());l.clear();for(let W of B)W()},YB=()=>{if(c)cancelAnimationFrame(c);c=requestAnimationFrame(KB)};queueMicrotask(KB);var m=(B)=>{let W=new Set,$=B;return $.off=(K)=>{W.add(K)},$.cleanup=()=>{for(let K of W)K();W.clear()},$},D=(B)=>{if(_&&!B.has(_)){let W=_;B.add(W),_.off(()=>{B.delete(W)})}},M=(B)=>{for(let W of B)if(s)v.add(W);else W()},u=()=>{while(v.size){let B=Array.from(v);v.clear();for(let W of B)W()}},ZB=(B)=>{s++;try{B()}finally{u(),s--}},d=(B,W)=>{let $=_;_=W;try{B()}finally{_=$}},N=(B,W)=>new Promise(($,K)=>{l.set(W||Symbol(),()=>{try{$(B())}catch(Z){K(Z)}}),YB()});var r="State",i=(B)=>{let W=new Set,$=B,K={[Symbol.toStringTag]:r,get:()=>{return D(W),$},set:(Z)=>{if(Object.is($,Z))return;if($=Z,M(W),j===$)W.clear()},update:(Z)=>{K.set(Z($))}};return K},C=(B)=>g(B,r);var p="Computed",o=(B)=>{let W=new Set,$=j,K,Z,J=!0,z=!1,G=!1,Y=(V)=>{if(!Object.is(V,$))$=V,z=!0;K=void 0,J=!1},I=()=>{z=j!==$,$=j,K=void 0},X=(V)=>{let x=f(V);z=!K||x.name!==K.name||x.message!==K.message,$=j,K=x},q=(V)=>(x)=>{if(G=!1,Z=void 0,V(x),z)M(W)},A=m(()=>{if(J=!0,Z?.abort("Aborted because source signal changed"),W.size)M(W);else A.cleanup()}),y=()=>d(()=>{if(G)throw new S("computed");if(z=!1,H(B)&&B.constructor.name==="AsyncFunction"){if(Z)return $;Z=new AbortController,Z.signal.addEventListener("abort",()=>{G=!1,Z=void 0,y()},{once:!0})}let V;G=!0;try{V=Z?B(Z.signal):B()}catch(x){if(x instanceof DOMException&&x.name==="AbortError")I();else X(x);G=!1;return}if(V instanceof Promise)V.then(q(Y),q(X));else if(V==null||j===V)I();else Y(V);G=!1},A);return{[Symbol.toStringTag]:p,get:()=>{if(D(W),u(),J)y();if(K)throw K;return $}}},k=(B)=>g(B,p),a=(B)=>H(B)&&B.length<2;var j=Symbol(),P=(B)=>C(B)||k(B),b=(B)=>P(B)?B:a(B)?o(B):i(B);function h(B){let{signals:W,ok:$,err:K=console.error,nil:Z=()=>{}}=H(B)?{signals:[],ok:B}:B,J=!1,z=m(()=>d(()=>{if(J)throw new S("effect");J=!0;let G=[],Y=!1,I=W.map((q)=>{try{let A=q.get();if(A===j)Y=!0;return A}catch(A){return G.push(f(A)),j}}),X=void 0;try{X=Y?Z():G.length?K(...G):$(...I)}catch(q){X=K(f(q))}finally{if(H(X))z.off(X)}J=!1},z));return z(),()=>z.cleanup()}var U=!1,HB="debug",QB="info",jB="warn",E="error",VB=(B)=>B?`#${B}`:"",FB=(B)=>B.length?`.${Array.from(B).join(".")}`:"",t=(B)=>!!B&&typeof B==="object",O=(B)=>typeof B==="string",JB=(B)=>B.nodeType===Node.ELEMENT_NODE,Q=(B)=>`<${B.localName}${VB(B.id)}${FB(B.classList)}>`,T=(B)=>O(B)?`"${B}"`:t(B)?JSON.stringify(B):String(B),n=(B)=>{if(B===null)return"null";if(typeof B!=="object")return typeof B;if(Array.isArray(B))return"Array";if(Symbol.toStringTag in Object(B))return B[Symbol.toStringTag];return B.constructor?.name||"Object"},F=(B,W,$="debug")=>{if(["error","warn"].includes($))console[$](W,B);return B};class zB extends Error{constructor(B){super(B);this.name="CircularMutationError"}}var AB=(B)=>B instanceof HTMLElement&&B.localName.includes("-"),LB=(B)=>{let W=new Set;if(B.includes("."))W.add("class");if(B.includes("#"))W.add("id");if(B.includes("[")){let $=B.split("[");for(let K=1;K<$.length;K++){let Z=$[K];if(!Z.includes("]"))continue;let J=Z.split("=")[0].trim().replace(/[^a-zA-Z0-9_-]/g,"");if(J)W.add(J)}}return[...W]},qB=(B,W)=>{if(B.length!==W.length)return!1;let $=new Set(B);for(let K of W)if(!$.has(K))return!1;return!0},e=(B,W,$)=>{let K=new MutationObserver($),Z=LB(W),J={childList:!0,subtree:!0};if(Z.length)J.attributes=!0,J.attributeFilter=Z;return K.observe(B,J),K},xB=(B,W)=>{let $=new Set,K=()=>Array.from(B.querySelectorAll(W)),Z=j,J,z=0,G=2,Y=()=>{Z=K(),J=e(B,W,()=>{if(!$.size){J?.disconnect(),J=void 0;return}if(z++,z>G)throw J?.disconnect(),J=void 0,z=0,new zB("Circular mutation in element selection detected");try{let X=K();if(!qB(Z,X))Z=X,M($)}finally{z--}})};return{[Symbol.toStringTag]:p,get:()=>{if(D($),!$.size)Z=K();else if(!J)Y();return Z}}},CB=(B,W)=>($,K=$)=>{if(!H(W))throw new TypeError(`Invalid event listener provided for "${B} event on element ${Q(K)}`);return K.addEventListener(B,W),()=>K.removeEventListener(B,W)},UB=(B,W)=>($,K=$)=>{K.dispatchEvent(new CustomEvent(B,{detail:H(W)?W(K):W,bubbles:!0}))},MB=(B)=>(W,$)=>{let K=$.localName;if(!AB($))throw new TypeError("Target element must be a custom element");let Z=H(B)?B($):B;if(!t(Z))throw new TypeError("Passed signals must be an object or a provider function");customElements.whenDefined(K).then(()=>{for(let[J,z]of Object.entries(Z)){let G=O(z)?W.getSignal(J):b(z);$.setSignal(J,G)}}).catch((J)=>{throw new Error(`Failed to pass signals to ${Q($)}}`,{cause:J})})};var w=Symbol(),PB=new Set(Object.getOwnPropertyNames(HTMLElement.prototype)),OB=new Set(["constructor","prototype","__proto__","toString","valueOf","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString"]),BB=(B)=>H(B)&&B.length>=2,RB=(B)=>!(PB.has(B)||OB.has(B)),$B=(B,W,$=W)=>{let K=B.filter(H).map((Z)=>Z(W,$));return()=>{K.filter(H).forEach((Z)=>Z()),K.length=0}},yB=()=>({first:(B,...W)=>($)=>{let K=($.shadowRoot||$).querySelector(B);if(K)$B(W,$,K)},all:(B,...W)=>($)=>{let K=new Map,Z=$.shadowRoot||$,J=(I)=>{if(!K.has(I))K.set(I,$B(W,$,I))},z=(I)=>{let X=K.get(I);if(H(X))X();K.delete(I)},G=(I)=>(X)=>{if(JB(X)){if(X.matches(B))I(X);X.querySelectorAll(B).forEach(I)}},Y=e(Z,B,(I)=>{for(let X of I)X.addedNodes.forEach(G(J)),X.removedNodes.forEach(G(z))});return Z.querySelectorAll(B).forEach(J),()=>{Y.disconnect(),K.forEach((I)=>I()),K.clear()}}}),_B=(B,W={},$)=>{class K extends HTMLElement{debug;#B={};#$;static observedAttributes=Object.entries(W)?.filter(([,Z])=>BB(Z)).map(([Z])=>Z)??[];constructor(){super();for(let[Z,J]of Object.entries(W)){if(J==null)continue;let z=BB(J)?J(this,null):H(J)?J(this):J;if(z!=null)this.setSignal(Z,b(z))}}connectedCallback(){if(U){if(this.debug=this.hasAttribute("debug"),this.debug)F(this,"Connected")}let Z=$(this,yB());if(!Array.isArray(Z))throw new TypeError(`Expected array of functions as return value of setup function in ${Q(this)}`);this.#$=$B(Z,this)}disconnectedCallback(){if(H(this.#$))this.#$();if(U&&this.debug)F(this,"Disconnected")}attributeChangedCallback(Z,J,z){if(z===J||k(this.#B[Z]))return;let G=W[Z];if(!BB(G))return;let Y=G(this,z,J);if(U&&this.debug)F(z,`Attribute "${Z}" of ${Q(this)} changed from ${T(J)} to ${T(z)}, parsed as <${n(Y)}> ${T(Y)}`);this[Z]=Y}getSignal(Z){let J=this.#B[Z];if(U&&this.debug)F(J,`Get ${n(J)} "${String(Z)}" in ${Q(this)}`);return J}setSignal(Z,J){if(!RB(String(Z)))throw new TypeError(`Invalid property name "${String(Z)}". Property names must be valid JavaScript identifiers and not conflict with inherited HTMLElement properties.`);if(!P(J))throw new TypeError(`Expected signal as value for property "${String(Z)}" on ${Q(this)}.`);let z=this.#B[Z],G=C(J);if(this.#B[Z]=J,Object.defineProperty(this,Z,{get:J.get,set:G?J.set:void 0,enumerable:!0,configurable:G}),z&&C(z))z.set(j);if(U&&this.debug)F(J,`Set ${n(J)} "${String(Z)} in ${Q(this)}`)}}return customElements.define(B,K),K};var WB="context-request";class GB extends Event{B;W;$;constructor(B,W,$=!1){super(WB,{bubbles:!0,composed:!0});this.context=B;this.callback=W;this.subscribe=$}}var DB=(B)=>(W)=>{let $=(K)=>{let{context:Z,callback:J}=K;if(B.includes(Z)&&H(J))K.stopPropagation(),J(W.getSignal(String(Z)))};return W.addEventListener(WB,$),()=>W.removeEventListener(WB,$)},NB=(B)=>(W)=>{let $;return W.dispatchEvent(new GB(B,(K)=>{$=K})),$};var IB=(B,W)=>{if(W==null)return;let $=B(W);return Number.isFinite($)?$:void 0},TB=(B,W)=>W!=="false"&&W!=null,wB=(B=0)=>(W,$)=>IB(parseInt,$)??B,SB=(B=0)=>(W,$)=>IB(parseFloat,$)??B,kB=(B="")=>(W,$)=>$??B,bB=(B)=>(W,$)=>$!=null&&B.includes($.toLowerCase())?$:B[0],EB=(B)=>(W,$)=>{if(($??B)==null)throw new ReferenceError("Value and fallback are both null or undefined");if($==null)return B;if($==="")throw new SyntaxError("Empty string is not valid JSON");let K;try{K=JSON.parse($)}catch(Z){throw new SyntaxError(`Failed to parse JSON: ${String(Z)}`,{cause:Z})}return K??B};var XB=(B,W,$)=>O(B)?W.getSignal(B).get():P(B)?B.get():H(B)?B($):w,fB=(B)=>{if(/^(mailto|tel):/i.test(B))return!0;if(B.includes("://"))try{let W=new URL(B,window.location.origin);return["http:","https:","ftp:"].includes(W.protocol)}catch(W){return!1}return!0},mB=(B,W,$)=>{if(/^on/i.test(W))throw new Error(`Unsafe attribute: ${W}`);if($=String($).trim(),!fB($))throw new Error(`Unsafe URL for ${W}: ${$}`);B.setAttribute(W,$)},R=(B,W)=>($,K)=>{let{op:Z,name:J="",read:z,update:G}=W,Y=z(K),I={a:"attribute ",c:"class ",h:"inner HTML",p:"property ",s:"style property ",t:"text content"};if(O(B)&&O(Y)&&$[B]===w)$.attributeChangedCallback(B,null,Y);let X=(A)=>()=>{if(U&&$.debug)F(K,`${A} ${I[Z]+J} of ${Q(K)} in ${Q($)}`);W.resolve?.(K)},q=(A)=>(y)=>{F(y,`Failed to ${A} ${I[Z]+J} of ${Q(K)} in ${Q($)}`,E),W.reject?.(y)};return h(()=>{let A=Symbol(`${Z}:${J}`),y=Symbol(`${Z}-${J}`),L=w;try{L=XB(B,$,K)}catch(V){F(V,`Failed to resolve value of ${T(B)} for ${I[Z]+J} of ${Q(K)} in ${Q($)}`,E);return}if(L===w)L=Y;else if(L===j)L=W.delete?null:Y;if(W.delete&&L===null)N(()=>{return W.delete(K),!0},y).then(X("Deleted")).catch(q("delete"));else if(L!=null){let V=z(K);if(Object.is(L,V))return;N(()=>{return G(K,L),!0},A).then(X("Updated")).catch(q("update"))}})},dB=(B,W)=>($,K)=>{let Z=(z)=>()=>{if(U&&$.debug)F(K,`${z} element in ${Q(K)} in ${Q($)}`);if(H(W?.resolve))W.resolve(K);else{let G=P(B)?B:O(B)?$.getSignal(B):void 0;if(C(G))G.set(0)}},J=(z)=>(G)=>{F(G,`Failed to ${z} element in ${Q(K)} in ${Q($)}`,E),W?.reject?.(G)};return h(()=>{let z=Symbol("i"),G=Symbol("d"),Y=0;try{Y=XB(B,$,K)}catch(I){F(I,`Failed to resolve value of ${T(B)} for insertion or deletion in ${Q(K)} in ${Q($)}`,E);return}if(Y===w)Y=0;if(Y>0){if(!W)throw new TypeError("No inserter provided");N(()=>{for(let I=0;I<Y;I++){let X=W.create(K);if(!X)continue;K.insertAdjacentElement(W.position??"beforeend",X)}return!0},z).then(Z("Inserted")).catch(J("insert"))}else if(Y<0)N(()=>{if(W&&(W.position==="afterbegin"||W.position==="beforeend"))for(let I=0;I>Y;I--)if(W.position==="afterbegin")K.firstElementChild?.remove();else K.lastElementChild?.remove();else K.remove();return!0},G).then(Z("Removed")).catch(J("remove"))})},pB=(B)=>R(B,{op:"t",read:(W)=>W.textContent,update:(W,$)=>{Array.from(W.childNodes).filter((K)=>K.nodeType!==Node.COMMENT_NODE).forEach((K)=>K.remove()),W.append(document.createTextNode($))}}),hB=(B,W=B)=>R(W,{op:"p",name:String(B),read:($)=>(B in $)?$[B]:j,update:($,K)=>{$[B]=K}}),gB=(B,W=B)=>R(W,{op:"a",name:B,read:($)=>$.getAttribute(B),update:($,K)=>{mB($,B,K)},delete:($)=>{$.removeAttribute(B)}}),vB=(B,W=B)=>R(W,{op:"a",name:B,read:($)=>$.hasAttribute(B),update:($,K)=>{$.toggleAttribute(B,K)}}),cB=(B,W=B)=>R(W,{op:"c",name:B,read:($)=>$.classList.contains(B),update:($,K)=>{$.classList.toggle(B,K)}}),uB=(B,W=B)=>R(W,{op:"s",name:B,read:($)=>$.style.getPropertyValue(B),update:($,K)=>{$.style.setProperty(B,K)},delete:($)=>{$.style.removeProperty(B)}}),iB=(B,W,$)=>R(B,{op:"h",read:(K)=>(K.shadowRoot||!W?K:null)?.innerHTML??"",update:(K,Z)=>{if(!Z){if(K.shadowRoot)K.shadowRoot.innerHTML="<slot></slot>";return""}if(W&&!K.shadowRoot)K.attachShadow({mode:W});let J=K.shadowRoot||K;if(J.innerHTML=Z,!$)return"";return J.querySelectorAll("script").forEach((z)=>{let G=document.createElement("script");G.appendChild(document.createTextNode(z.textContent??"")),J.appendChild(G),z.remove()})," with scripts"}});export{R as updateElement,cB as toggleClass,vB as toggleAttribute,b as toSignal,i as state,pB as setText,uB as setStyle,hB as setProperty,gB as setAttribute,xB as selection,DB as provide,MB as pass,CB as on,F as log,C as isState,P as isSignal,k as isComputed,dB as insertOrRemoveElement,N as enqueue,UB as emit,h as effect,iB as dangerouslySetInnerHTML,NB as consume,o as computed,_B as component,ZB as batch,kB as asString,SB as asNumber,EB as asJSON,wB as asInteger,bB as asEnum,TB as asBoolean,j as UNSET,w as RESET,jB as LOG_WARN,QB as LOG_INFO,E as LOG_ERROR,HB as LOG_DEBUG};
