var c=($)=>typeof $==="function";var o=($,K)=>Object.prototype.toString.call($)===`[object ${K}]`,Z4=($)=>(K)=>K instanceof $,b=Z4(Error),H4=Z4(Promise),S=($)=>b($)?$:new Error(String($));var R,v=new Set,l=0,a=new Map,i,B4=()=>{i=void 0;let $=Array.from(a.values());a.clear();for(let K of $)K()},w4=()=>{if(i)cancelAnimationFrame(i);i=requestAnimationFrame(B4)};queueMicrotask(B4);var n=($)=>{if(R&&!$.includes(R))$.push(R)},E=($)=>{for(let K of $)if(l)v.add(K);else K()},e=()=>{while(v.size){let $=Array.from(v);v.clear();for(let K of $)K()}},Q4=($)=>{l++;try{$()}finally{e(),l--}},y=($,K)=>{let Z=R;R=K;try{$()}finally{R=Z}},O=($,K)=>new Promise((Z,H)=>{let B=()=>{try{Z($())}catch(Q){H(Q)}};if(K)a.set(K,B);w4()});function x($,...K){let Z=!1,H=()=>y(()=>{if(Z)throw new Error("Circular dependency in effect detected");Z=!0;let B=u(K,$);if(b(B))console.error("Unhandled error in effect:",B);Z=!1},H);H()}var X4="Computed",L4=($,K)=>{if(!K)return!1;return $.name===K.name&&$.message===K.message},w=($,...K)=>{let Z=[],H=j,B,Q=!0,J=!1,A=!1,z=(F)=>{if(!Object.is(F,H))H=F,Q=!1,B=void 0,J=!1},Y=()=>{J=j===H,H=j,B=void 0},_=(F)=>{let d=S(F);J=L4(d,B),H=j,B=d},L=()=>{if(Q=!0,!J)E(Z)},G4=()=>y(()=>{if(A)throw new Error("Circular dependency in computed detected");J=!0,A=!0;let F=u(K,$);if(H4(F))Y(),F.then((d)=>{z(d),E(Z)}).catch(_);else if(F==null||j===F)Y();else if(b(F))_(F);else z(F);A=!1},L),g={[Symbol.toStringTag]:X4,get:()=>{if(n(Z),e(),Q)G4();if(B)throw B;return H},map:(F)=>w(F,g),match:(F)=>{return x(F,g),g}};return g},P=($)=>o($,X4);var J4="State",s=($)=>{let K=[],Z=$,H={[Symbol.toStringTag]:J4,get:()=>{return n(K),Z},set:(B)=>{if(Object.is(Z,B))return;if(Z=B,E(K),j===Z)K.length=0},update:(B)=>{H.set(B(Z))},map:(B)=>w(B,H),match:(B)=>{return x(B,H),H}};return H},N=($)=>o($,J4);var j=Symbol(),T=($)=>N($)||P($),h=($)=>c($)&&!$.length||typeof $==="object"&&$!==null&&("ok"in $)&&c($.ok),f=($)=>T($)?$:h($)?w($):s($),u=($,K)=>{let{ok:Z,nil:H,err:B}=c(K)?{ok:K}:K,Q=[],J=[],A=!1;for(let Y=0;Y<$.length;Y++){let _=$[Y];try{let L=_.get();if(L===j)A=!0;Q[Y]=L}catch(L){J.push(S(L))}}let z=void 0;try{if(A&&H)z=H();else if(J.length)z=B?B(...J):J[0];else if(!A)z=Z(...Q)}catch(Y){if(z=S(Y),B)z=B(z)}return z};var M=($)=>typeof $==="function",m=($)=>!!$&&typeof $==="object",U=($)=>typeof $==="string";var V=!1,Y4="debug",x4="info",D="warn",q="error",P4=($)=>$?`#${$}`:"",T4=($)=>$.length?`.${Array.from($).join(".")}`:"",W=($)=>`<${$.localName}${P4($.id)}${T4($.classList)}>`,I=($)=>U($)?`"${$}"`:m($)?JSON.stringify($):String($),r=($)=>{if($===null)return"null";if(typeof $!=="object")return typeof $;if(Array.isArray($))return"Array";if(Symbol.toStringTag in Object($))return $[Symbol.toStringTag];return $.constructor?.name||"Object"},X=($,K,Z=Y4)=>{if(V||[q,D].includes(Z))console[Z](K,$);return $};class k{$;K;constructor($,K=[$]){this.host=$;this.targets=K}on($,K){return this.targets.forEach((Z,H)=>{let B;if(M(K))B=K.length===2?K(Z,H):K;else if(m(K)&&M(K.handleEvent))B=K;else{X(K,`Invalid listener provided for ${$} event on element ${W(Z)}`,q);return}Z.addEventListener($,B),this.host.cleanup.push(()=>Z.removeEventListener($,B))}),this}emit($,K){return this.targets.forEach((Z)=>{Z.dispatchEvent(new CustomEvent($,{detail:K,bubbles:!0}))}),this}pass($){return this.targets.forEach(async(K,Z)=>{if(await p.registry.whenDefined(K.localName),K instanceof p){let H;if(M($)&&$.length===2)H=$(K,Z);else if(m($))H=$;else{X($,"Invalid passed signals provided",q);return}Object.entries(H).forEach(([B,Q])=>{if(U(Q))if(Q in this.host.signals)K.set(B,this.host.signals[Q]);else X(Q,`Invalid string key "${Q}" for state ${I(B)}`,D);else try{K.set(B,f(Q))}catch(J){X(J,`Invalid source for state ${I(B)}`,D)}})}else X(K,"Target is not a UIElement",q)}),this}sync(...$){return this.targets.forEach((K,Z)=>$.forEach((H)=>H(this.host,K,Z))),this}}var z4="context-request";class j4 extends Event{$;K;Z;constructor($,K,Z=!1){super(z4,{bubbles:!0,composed:!0});this.context=$;this.callback=K;this.subscribe=Z}}var $4=($)=>{let K=$.constructor,Z=K.consumedContexts||[];queueMicrotask(()=>{for(let B of Z)$.dispatchEvent(new j4(B,(Q)=>$.set(String(B),Q??C)))});let H=K.providedContexts||[];if(!H.length)return!1;return $.addEventListener(z4,(B)=>{let{context:Q,callback:J}=B;if(!H.includes(Q)||!M(J))return;B.stopPropagation(),J($.signals[String(Q)])}),!0};var C=Symbol(),A4=($)=>M($)&&!!$.length,F4=($)=>M($)&&!!$.length,K4=($)=>M($)?K4($()):T($)?K4($.get()):$,t=($,K,Z,H)=>{let B=$.states[K];return A4(B)?B(Z,$,H):Z??void 0};class p extends HTMLElement{static registry=customElements;static localName;static observedAttributes;static consumedContexts;static providedContexts;static define($=this.localName){try{if(this.registry.define($,this),V)X($,"Registered custom element")}catch(K){X(K,`Failed to register custom element ${$}`,q)}return this}states={};signals={};cleanup=[];self=new k(this);get root(){return this.shadowRoot||this}debug=!1;attributeChangedCallback($,K,Z){if(Z===K||P(this.signals[$]))return;let H=t(this,$,Z,K);if(V&&this.debug)X(Z,`Attribute "${$}" of ${W(this)} changed from ${I(K)} to ${I(Z)}, parsed as <${r(H)}> ${I(H)}`);this.set($,H??C)}connectedCallback(){if(V){if(this.debug=this.hasAttribute("debug"),this.debug)X(this,"Connected")}for(let[$,K]of Object.entries(this.states)){let Z=A4(K)?K(this.getAttribute($),this):h(K)?w(K):K;this.set($,Z??C)}$4(this)}disconnectedCallback(){if(this.cleanup.forEach(($)=>$()),this.cleanup=[],V&&this.debug)X(this,"Disconnected")}adoptedCallback(){if(V&&this.debug)X(this,"Adopted")}has($){return $ in this.signals}get($){let K=K4(this.signals[$]);if(V&&this.debug)X(K,`Get current value of signal <${r(K)}> ${I($)} in ${W(this)}`);return K}set($,K,Z=!0){if(K==null){X(K,`Attempt to set state ${I($)} to null or undefined in ${W(this)}`,q);return}let H,B=this.signals[$],Q=B?.get();if(!($ in this.signals)){if(F4(K)){X(K,`Cannot use updater function to create a computed signal in ${W(this)}`,q);return}if(V&&this.debug)H="Create";this.signals[$]=f(K)}else if(Z||Q===j||Q===C){if(h(K)){X(K,`Cannot use computed callbacks to update signal ${I($)} in ${W(this)}`,q);return}if(T(K)){if(V&&this.debug)H="Replace";if(this.signals[$]=K,N(B))B.set(j)}else if(N(B)){if(V&&this.debug)H="Update";if(F4(K))B.update(K);else B.set(K)}else{X(K,`Computed signal ${I($)} in ${W(this)} cannot be set`,D);return}}else return;if(V&&this.debug)X(K,`${H} signal <${r(K)}> ${I($)} in ${W(this)}`)}delete($){if(V&&this.debug)X($,`Delete signal ${I($)} from ${W(this)}`);return delete this.signals[$]}first($){let K=this.root.querySelector($);if(this.shadowRoot&&!K)K=this.querySelector($);return new k(this,K?[K]:[])}all($){let K=this.root.querySelectorAll($);if(this.shadowRoot&&!K.length)K=this.querySelectorAll($);return new k(this,Array.from(K))}}var q4=($,K)=>{if(K==null)return;let Z=$(K);return Number.isFinite(Z)?Z:void 0},U4=($)=>Array.isArray($)&&$[0]?$[0]:$,N4=($)=>$!=="false"&&$!=null,W4=($=0)=>(K)=>q4(parseInt,K)??$,D4=W4(),V4=($=0)=>(K)=>q4(parseFloat,K)??$,_4=V4(),I4=($="")=>(K)=>K??$,R4=I4(),y4=($)=>(K)=>K!=null&&$.includes(K.toLowerCase())?K:U4($),M4=($)=>(K)=>{if(K==null)return $;let Z;try{Z=JSON.parse(K)}catch(H){X(H,"Failed to parse JSON",q)}return Z??$},O4=M4({});var f4=($)=>{if(/^(mailto|tel):/i.test($))return!0;if($.includes("://"))try{let K=new URL($,window.location.origin);return["http:","https:","ftp:"].includes(K.protocol)}catch(K){return!1}return!0},C4=($,K,Z)=>{if(/^on/i.test(K))throw new Error(`Unsafe attribute: ${K}`);if(Z=String(Z).trim(),!f4(Z))throw new Error(`Unsafe URL for ${K}: ${Z}`);$.setAttribute(K,Z)},G=($,K)=>(Z,H,B)=>{let{op:Q,read:J,update:A}=K,z=J(H);if(U($)&&!P(Z.signals[$])){let Y=U(z)?t(Z,$,z):z;if(Y!=null)Z.set($,Y,!1)}x(()=>{let Y=C;try{Y=U($)?Z.get($):T($)?$.get():M($)?$(H,B):C}catch(L){X(L,`Failed to update element ${W(H)} in ${W(Z)}:`,q)}finally{if(Y===C)Y=z;if(Y===j)Y=null}let _=J(H);if(!Object.is(Y,_))if((Y===null||Y==null&&z===null)&&K.delete)O(()=>{return K.delete(H),!0},[H,Q]);else if(Y==null){if(z)O(()=>{return A(H,z),!0},[H,Q])}else O(()=>{return A(H,Y),!0},[H,Q])})},k4=($,K,Z)=>G(K,{op:"create",read:()=>null,update:(H,B)=>{let Q=document.createElement($);for(let[J,A]of Object.entries(B))C4(Q,J,A);if(Z)Q.textContent=Z;H.append(Q)}}),b4=($)=>G($,{op:"remove",read:(K)=>!!K,update:(K,Z)=>{if(Z)K.remove()}}),S4=($)=>G($,{op:"text",read:(K)=>K.textContent,update:(K,Z)=>{Array.from(K.childNodes).filter((H)=>H.nodeType!==Node.COMMENT_NODE).forEach((H)=>H.remove()),K.append(document.createTextNode(Z))}}),E4=($,K,Z)=>G($,{op:"html",read:(H)=>(H.shadowRoot||!K?H:null)?.innerHTML??"",update:(H,B)=>{if(!B){if(H.shadowRoot)H.shadowRoot.innerHTML="<slot></slot>";return}if(K&&!H.shadowRoot)H.attachShadow({mode:K});let Q=H.shadowRoot||H;if(Q.innerHTML=B,!Z)return;Q.querySelectorAll("script").forEach((J)=>{let A=document.createElement("script");A.appendChild(document.createTextNode(J.textContent??"")),Q.appendChild(A),J.remove()})}}),h4=($,K=$)=>G(K,{op:"prop",read:(Z)=>($ in Z)?Z[$]:j,update:(Z,H)=>{Z[$]=H}}),m4=($,K=$)=>G(K,{op:"attr",read:(Z)=>Z.getAttribute($),update:(Z,H)=>{C4(Z,$,H)},delete:(Z)=>{Z.removeAttribute($)}}),p4=($,K=$)=>G(K,{op:"attr",read:(Z)=>Z.hasAttribute($),update:(Z,H)=>{Z.toggleAttribute($,H)}}),g4=($,K=$)=>G(K,{op:"class",read:(Z)=>Z.classList.contains($),update:(Z,H)=>{Z.classList.toggle($,H)}}),d4=($,K=$)=>G(K,{op:"style",read:(Z)=>Z.style.getPropertyValue($),update:(Z,H)=>{Z.style.setProperty($,H)},delete:(Z)=>{Z.style.removeProperty($)}});export{y as watch,$4 as useContext,G as updateElement,g4 as toggleClass,p4 as toggleAttribute,f as toSignal,s as state,S4 as setText,d4 as setStyle,h4 as setProperty,m4 as setAttribute,b4 as removeElement,t as parse,X as log,N as isState,T as isSignal,P as isComputed,O as enqueue,x as effect,E4 as dangerouslySetInnerHTML,k4 as createElement,w as computed,Q4 as batch,I4 as asStringWithDefault,R4 as asString,V4 as asNumberWithDefault,_4 as asNumber,M4 as asJSONWithDefault,O4 as asJSON,W4 as asIntegerWithDefault,D4 as asInteger,y4 as asEnum,N4 as asBoolean,j as UNSET,p as UIElement,k as UI,C as RESET,D as LOG_WARN,x4 as LOG_INFO,q as LOG_ERROR,Y4 as LOG_DEBUG};
