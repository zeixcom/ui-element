var S=($)=>typeof $==="function";var $$=($)=>S($)&&$.length<2,g=($,H)=>Object.prototype.toString.call($)===`[object ${H}]`,H$=($)=>(H)=>H instanceof $,b=H$(Error),K$=H$(Promise),O=($)=>b($)?$:new Error(String($)),Z$=($,H)=>{if(!H)return!1;return $.name===H.name&&$.message===H.message};var D,d=new Set,s=0,c=new Map,o,Q$=()=>{o=void 0;for(let $ of c.values()){for(let H of $.values())H();$.clear()}},x$=()=>{if(o)cancelAnimationFrame(o);o=requestAnimationFrame(Q$)};queueMicrotask(Q$);var v=($)=>{if(D&&!$.includes(D))$.push(D)},h=($)=>{for(let H of $)s?d.add(H):H()},r=()=>{while(d.size){let $=Array.from(d);d.clear();for(let H of $)H()}},X$=($)=>{s++,$(),r(),s--},k=($,H)=>{let K=D;D=H,$(),D=K},j$=($,H)=>new Promise((K,Z)=>{let Q=()=>{try{K($())}catch(X){Z(X)}};if(H){let[X,j]=H;if(!c.has(X))c.set(X,new Map);c.get(X).set(j,Q)}x$()});function F($,...H){let K=S($)?{ok:$}:$,Z=()=>k(()=>{let Q=n(H,K);if(b(Q))console.error("Unhandled error in effect:",Q)},Z);Z()}var B$="Computed",M=($,...H)=>{let K=S($)?{ok:$}:$,Z=[],Q=z,X,j=!0,Y=!1,J=!1,N=(q)=>{if(!Object.is(q,Q))Q=q,j=!1,X=void 0,Y=!1},L=()=>{Y=z===Q,Q=z,X=void 0},e=(q)=>{let p=O(q);Y=Z$(p,X),Q=z,X=p},M$=()=>{if(j=!0,!Y)h(Z)},G$=()=>k(()=>{if(J)throw new Error("Circular dependency detected");Y=!0,J=!0;let q=n(H,K);if(K$(q))L(),q.then((p)=>{N(p),h(Z)}).catch(e);else if(q==null||z===q)L();else if(b(q))e(q);else N(q);J=!1},M$),m={[Symbol.toStringTag]:B$,get:()=>{if(v(Z),r(),j)G$();if(X)throw X;return Q},map:(q)=>M(()=>q(m.get())),match:(q)=>{return F(q,m),m}};return m},_=($)=>g($,B$);var J$="State",i=($)=>{let H=[],K=$,Z={[Symbol.toStringTag]:J$,get:()=>{return v(H),K},set:(Q)=>{if(Object.is(K,Q))return;if(K=Q,h(H),z===K)H.length=0},update:(Q)=>{Z.set(Q(K))},map:(Q)=>M(()=>Q(Z.get())),match:(Q)=>{return F(Q,Z),Z}};return Z},U=($)=>g($,J$);var z=Symbol(),W=($)=>U($)||_($),R=($)=>W($)?$:$$($)?M($):i($),n=($,H)=>{let{ok:K,nil:Z,err:Q}=H,X=[],j=[],Y=!1;for(let N of $)try{let L=N.get();if(L===z)Y=!0;X.push(L)}catch(L){j.push(O(L))}let J=void 0;try{if(Y&&Z)J=Z();else if(j.length)J=Q?Q(...j):j[0];else if(!Y)J=K(...X)}catch(N){if(J=O(N),Q)J=Q(J)}finally{return J}};var A=($)=>typeof $==="function",E=($)=>!!$&&typeof $==="object",T=($)=>typeof $==="string";var V=!1,t="debug",F$="info",P="warn",C="error",T$=($)=>$?`#${$}`:"",L$=($)=>$.length?`.${Array.from($).join(".")}`:"",I=($)=>`<${$.localName}${T$($.id)}${L$($.classList)}>`,w=($)=>T($)?`"${$}"`:E($)?JSON.stringify($):String($),B=($,H,K=t)=>{if(V||[C,P].includes(K))console[K](H,$);return $};class f{host;targets;constructor($,H=[$]){this.host=$;this.targets=H}on($,H){return this.targets.forEach((K,Z)=>{let Q;if(A(H))Q=H.length===2?H(K,Z):H;else if(E(H)&&A(H.handleEvent))Q=H;else{B(H,`Invalid listener provided for ${$} event on element ${I(K)}`,C);return}K.addEventListener($,Q),this.host.cleanup.push(()=>K.removeEventListener($,Q))}),this}emit($,H){return this.targets.forEach((K)=>{K.dispatchEvent(new CustomEvent($,{detail:H,bubbles:!0}))}),this}pass($){return this.targets.forEach(async(H,K)=>{if(await y.registry.whenDefined(H.localName),H instanceof y){let Z;if(A($)&&$.length===2)Z=$(H,K);else if(E($))Z=$;else{B($,"Invalid passed signals provided",C);return}Object.entries(Z).forEach(([Q,X])=>{if(T(X))if(X in this.host.signals)H.set(Q,this.host.signals[X]);else B(X,`Invalid string key "${X}" for state ${w(Q)}`,P);else if(A(X)||W(X))H.set(Q,R(X));else B(X,`Invalid source for state ${w(Q)}`,P)})}else B(H,"Target is not a UIElement",C)}),this}sync(...$){return this.targets.forEach((H,K)=>$.forEach((Z)=>Z(this.host,H,K))),this}}var Y$="context-request";class z$ extends Event{context;callback;subscribe;constructor($,H,K=!1){super(Y$,{bubbles:!0,composed:!0});this.context=$;this.callback=H;this.subscribe=K}}var l=($)=>{let H=$.constructor,K=H.consumedContexts||[];queueMicrotask(()=>{for(let Q of K)$.dispatchEvent(new z$(Q,(X)=>$.set(String(Q),X??G)))});let Z=H.providedContexts||[];if(!Z.length)return!1;return $.addEventListener(Y$,(Q)=>{let{context:X,callback:j}=Q;if(!Z.includes(X)||!A(j))return;Q.stopPropagation(),j($.signals[String(X)])}),!0};var G=Symbol(),q$=($)=>A($)&&!!$.length,U$=($)=>A($)&&!$.length,a=($)=>A($)?a($()):W($)?a($.get()):$,u=($,H,K,Z)=>{let Q=$.states[H];return q$(Q)?Q(K,$,Z):K};class y extends HTMLElement{static registry=customElements;static localName;static observedAttributes;static consumedContexts;static providedContexts;static define($=this.localName){try{if(this.registry.define($,this),V)B($,"Registered custom element")}catch(H){B(H,`Failed to register custom element ${$}`,C)}return this}states={};signals={};cleanup=[];self=new f(this);get root(){return this.shadowRoot||this}debug=!1;attributeChangedCallback($,H,K){if(K===H||_(this.signals[$]))return;let Z=u(this,$,K,H);if(V&&this.debug)B(K,`Attribute "${$}" of ${I(this)} changed from ${w(H)} to ${w(K)}, parsed as <${typeof Z}> ${w(Z)}`);this.set($,Z??G)}connectedCallback(){if(V){if(this.debug=this.hasAttribute("debug"),this.debug)B(this,"Connected")}for(let[$,H]of Object.entries(this.states)){let K=q$(H)?H(this.getAttribute($),this):U$(H)?M(H):H;this.set($,K??G)}l(this)}disconnectedCallback(){if(this.cleanup.forEach(($)=>$()),this.cleanup=[],V&&this.debug)B(this,"Disconnected")}adoptedCallback(){if(V&&this.debug)B(this,"Adopted")}has($){return $ in this.signals}get($){let H=a(this.signals[$]);if(V&&this.debug)B(H,`Get current value of state <${typeof H}> ${w($)} in ${I(this)}`);return H}set($,H,K=!0){if(H==null){B(H,`Attempt to set state ${w($)} to null or undefined in ${I(this)}`,C);return}let Z,Q=this.signals[$],X=Q?.get();if(!($ in this.signals)){if(V&&this.debug)Z="Create";this.signals[$]=R(H)}else if(K||X===z||X===G)if(W(H)){if(V&&this.debug)Z="Replace";if(this.signals[$]=H,U(Q))Q.set(z)}else if(U(Q)){if(V&&this.debug)Z="Update";if(A(H))Q.update(H);else Q.set(H)}else{B(H,`Computed state ${w($)} in ${I(this)} cannot be set`,P);return}else return;if(V&&this.debug)B(H,`${Z} state <${typeof H}> ${w($)} in ${I(this)}`)}delete($){if(V&&this.debug)B($,`Delete state ${w($)} from ${I(this)}`);return delete this.signals[$]}first($){let H=this.root.querySelector($);return new f(this,H?[H]:[])}all($){return new f(this,Array.from(this.root.querySelectorAll($)))}}var A$=($,H)=>{if(H==null)return;let K=$(H);return Number.isFinite(K)?K:void 0},P$=($)=>Array.isArray($)&&$[0]?$[0]:$,N$=($)=>$!=="false"&&$!=null,V$=($=0)=>(H)=>A$(parseInt,H)??$,D$=V$(),w$=($=0)=>(H)=>A$(parseFloat,H)??$,_$=w$(),C$=($="")=>(H)=>H??$,R$=C$(),y$=($)=>(H)=>H!=null&&$.includes(H.toLowerCase())?H:P$($),W$=($)=>(H)=>{if(H==null)return $;let K;try{K=JSON.parse(H)}catch(Z){B(Z,"Failed to parse JSON",C)}return K??$},f$=W$({});var S$=($)=>{if(/^(mailto|tel):/i.test($))return!0;if($.includes("://"))try{let H=new URL($,window.location.origin);return["http:","https:","ftp:"].includes(H.protocol)}catch(H){return!1}return!0},I$=($,H,K)=>{if(/^on/i.test(H))throw new Error(`Unsafe attribute: ${H}`);if(K=String(K).trim(),!S$(K))throw new Error(`Unsafe URL for ${H}: ${K}`);$.setAttribute(H,K)},x=($,H)=>(K,Z)=>{let{read:Q,update:X}=H,j=Q(Z);if(T($)){let Y=T(j)?u(K,$,j):j;if(Y!=null)K.set($,Y,!1)}F(()=>{let Y=Q(Z),J=T($)?K.get($):W($)?$.get():A($)?$(Y):void 0;if(!Object.is(J,Y))if((J===null||J===z||J===G&&j===null)&&H.delete)H.delete(Z);else if(J==null||J===G){if(j)X(Z,j)}else X(Z,J)})},b$=($,H,K)=>x(H,{read:()=>null,update:(Z,Q)=>{let X=document.createElement($);for(let[j,Y]of Object.entries(Q))I$(X,j,Y);if(K)X.textContent=K;Z.append(X)}}),O$=($)=>x($,{read:(H)=>H!=null,update:(H,K)=>{if(K)H.remove()}}),h$=($)=>x($,{read:(H)=>H.textContent,update:(H,K)=>{Array.from(H.childNodes).filter((Z)=>Z.nodeType!==Node.COMMENT_NODE).forEach((Z)=>Z.remove()),H.append(document.createTextNode(K))}}),k$=($,H=$)=>x(H,{read:(K)=>($ in K)?K[$]:z,update:(K,Z)=>{K[$]=Z}}),E$=($,H=$)=>x(H,{read:(K)=>K.getAttribute($),update:(K,Z)=>{I$(K,$,Z)},delete:(K)=>{K.removeAttribute($)}}),m$=($,H=$)=>x(H,{read:(K)=>K.hasAttribute($),update:(K,Z)=>{K.toggleAttribute($,Z)}}),p$=($,H=$)=>x(H,{read:(K)=>K.classList.contains($),update:(K,Z)=>{K.classList.toggle($,Z)}}),g$=($,H=$)=>x(H,{read:(K)=>K.style.getPropertyValue($),update:(K,Z)=>{K.style.setProperty($,Z)},delete:(K)=>{K.style.removeProperty($)}});export{l as useContext,x as updateElement,p$ as toggleClass,m$ as toggleAttribute,R as toSignal,i as state,h$ as setText,g$ as setStyle,k$ as setProperty,E$ as setAttribute,O$ as removeElement,u as parse,B as log,U as isState,W as isSignal,_ as isComputed,j$ as enqueue,F as effect,b$ as createElement,M as computed,X$ as batch,C$ as asStringWithDefault,R$ as asString,w$ as asNumberWithDefault,_$ as asNumber,W$ as asJSONWithDefault,f$ as asJSON,V$ as asIntegerWithDefault,D$ as asInteger,y$ as asEnum,N$ as asBoolean,z as UNSET,y as UIElement,f as UI,G as RESET,P as LOG_WARN,F$ as LOG_INFO,C as LOG_ERROR,t as LOG_DEBUG};
