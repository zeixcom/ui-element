var z=(K)=>typeof K==="function",s=(K,$)=>Object.prototype.toString.call(K)===`[object ${$}]`,v=(K)=>K instanceof Error?K:Error(String(K));class g extends Error{constructor(K){super(`Circular dependency in ${K} detected`);return this}}var k,l=new Set,HK=0,ZK=new Map,r,PK=()=>{r=void 0;let K=Array.from(ZK.values());ZK.clear();for(let $ of K)$()},DK=()=>{if(r)cancelAnimationFrame(r);r=requestAnimationFrame(PK)};queueMicrotask(PK);var c=(K)=>{let $=new Set,B=K;return B.off=(H)=>{$.add(H)},B.cleanup=()=>{for(let H of $)H();$.clear()},B},D=(K)=>{if(k&&!K.has(k)){let $=k;K.add($),k.off(()=>{K.delete($)})}},F=(K)=>{for(let $ of K)if(HK)l.add($);else $()},a=()=>{while(l.size){let K=Array.from(l);l.clear();for(let $ of K)$()}},t=(K)=>{HK++;try{K()}finally{a(),HK--}},u=(K,$)=>{let B=k;k=$;try{K()}finally{k=B}},b=(K,$)=>new Promise((B,H)=>{ZK.set($||Symbol(),()=>{try{B(K())}catch(Z){H(Z)}}),DK()});var JK="State",e=(K)=>{let $=new Set,B=K,H={[Symbol.toStringTag]:JK,get:()=>{return D($),B},set:(Z)=>{if(Object.is(B,Z))return;if(B=Z,F($),V===B)$.clear()},update:(Z)=>{H.set(Z(B))}};return H},P=(K)=>s(K,JK);var E="Computed",N=(K)=>{let $=new Set,B=V,H,Z,J=!0,L=!1,W=!1,A=(x)=>{if(!Object.is(x,B))B=x,L=!0;H=void 0,J=!1},G=()=>{L=V!==B,B=V,H=void 0},j=(x)=>{let _=v(x);L=!H||_.name!==H.name||_.message!==H.message,B=V,H=_},Q=(x)=>(_)=>{if(W=!1,Z=void 0,x(_),L)F($)},X=c(()=>{if(J=!0,Z?.abort("Aborted because source signal changed"),$.size)F($);else X.cleanup()}),O=()=>u(()=>{if(W)throw new g("computed");if(L=!1,z(K)&&K.constructor.name==="AsyncFunction"){if(Z)return B;Z=new AbortController,Z.signal.addEventListener("abort",()=>{W=!1,Z=void 0,O()},{once:!0})}let x;W=!0;try{x=Z?K(Z.signal):K()}catch(_){if(_ instanceof DOMException&&_.name==="AbortError")G();else j(_);W=!1;return}if(x instanceof Promise)x.then(Q(A),Q(j));else if(x==null||V===x)G();else A(x);W=!1},X);return{[Symbol.toStringTag]:E,get:()=>{if(D($),a(),J)O();if(H)throw H;return B}}},p=(K)=>s(K,E),LK=(K)=>z(K)&&K.length<2;var V=Symbol(),R=(K)=>P(K)||p(K),T=(K)=>R(K)?K:LK(K)?N(K):e(K);function f(K){let{signals:$,ok:B,err:H=console.error,nil:Z=()=>{}}=z(K)?{signals:[],ok:K}:K,J=!1,L=c(()=>u(()=>{if(J)throw new g("effect");J=!0;let W=[],A=!1,G=$.map((Q)=>{try{let X=Q.get();if(X===V)A=!0;return X}catch(X){return W.push(v(X)),V}}),j=void 0;try{j=A?Z():W.length?H(...W):B(...G)}catch(Q){j=H(v(Q))}finally{if(z(j))L.off(j)}J=!1},L));return L(),()=>L.cleanup()}var M=!1,UK="debug",RK="info",FK="warn",w="error",TK=(K)=>K?`#${K}`:"",wK=(K)=>K?.length?`.${Array.from(K).join(".")}`:"",i=(K)=>!!K&&typeof K==="object",U=(K)=>typeof K==="string",WK=(K,$)=>U($)&&($ in K)&&z(K[$]),MK=(K)=>K.nodeType===Node.ELEMENT_NODE,n=(K)=>K.localName.includes("-");var Y=(K)=>K?`<${K.localName}${TK(K.id)}${wK(K.classList)}>`:"<unknown>",d=(K)=>U(K)?`"${K}"`:i(K)?JSON.stringify(K):String(K),KK=(K)=>{if(K===null)return"null";if(typeof K!=="object")return typeof K;if(Array.isArray(K))return"Array";if(Symbol.toStringTag in Object(K))return K[Symbol.toStringTag];return K.constructor?.name||"Object"},y=(K,$,B=UK)=>{if(M||[w,FK].includes(B))console[B]($,K);return K};class AK extends Error{constructor(K,$){super(`Circular dependency detected in selection signal for component ${Y(K)} with selector "${$}"`);this.name="CircularMutationError"}}class QK extends Error{constructor(K){super(`Invalid component name "${K}". Custom element names must contain a hyphen, start with a lowercase letter, and contain only lowercase letters, numbers, and hyphens.`);this.name="InvalidComponentNameError"}}class XK extends Error{constructor(K,$,B){super(`Expected element ${Y($)} in ${Y(K)} to be a custom element.${B?` ${B}`:""}`);this.name="InvalidCustomElementError"}}class $K extends Error{constructor(K,$,B){super(`Invalid property name "${$}" for component <${K}>. ${B}`);this.name="InvalidPropertyNameError"}}class YK extends Error{constructor(K){super(`Invalid setup function in component <${Y(K)}>. Setup function must return an array of effects or a single effect function.`);this.name="InvalidSetupFunctionError"}}class GK extends Error{constructor(K,$){super(`Expected signal as value for property "${String($)}" in component ${Y(K)}.`);this.name="InvalidSignalError"}}class h extends Error{constructor(K,$,B){super(`Missing required element <${$}> in component ${Y(K)}. ${B}`);this.name="MissingElementError"}}var NK=(K)=>{let $=new Set;if(K.includes("."))$.add("class");if(K.includes("#"))$.add("id");if(K.includes("[")){let B=K.split("[");for(let H=1;H<B.length;H++){let Z=B[H];if(!Z.includes("]"))continue;let J=Z.split("=")[0].trim().replace(/[^a-zA-Z0-9_-]/g,"");if(J)$.add(J)}}return[...$]},SK=(K,$)=>{if(K.length!==$.length)return!1;let B=new Set(K);for(let H of $)if(!B.has(H))return!1;return!0},o=(K)=>z(K)&&K.length>=2,I=(K,$)=>z($)?$(K):$,BK=(K,$)=>(B)=>{let H=B.shadowRoot??B,Z=(L,W)=>{let A=H.querySelector(L);if(!A)return;let G=W(A);if(G!=null)return G},J=void 0;for(let[L,W]of Object.entries($))if(J=Z(L,W),J!=null)break;return U(J)&&o(K)?K(B,J):J??I(B,K)},jK=(K,$,B)=>{let H=new MutationObserver(B),Z={childList:!0,subtree:!0},J=NK($);if(J.length)Z.attributes=!0,Z.attributeFilter=J;return H.observe(K,Z),H},CK=(K)=>($)=>{let B=new Set,H=()=>Array.from(($.shadowRoot??$).querySelectorAll(K)),Z=V,J,L=0,W=2,A=()=>{Z=H(),J=jK($,K,()=>{if(!B.size){J?.disconnect(),J=void 0;return}if(L++,L>W)throw J?.disconnect(),J=void 0,L=0,new AK($,K);try{let G=H();if(!SK(Z,G))Z=G,F(B)}finally{L--}})};return{[Symbol.toStringTag]:E,get(){if(D(B),!B.size)Z=H();else if(!J)A();return Z}}},kK=(K,$,B,H)=>N(()=>CK($)(K).get().reduce(B,H)),bK=(K,$,B)=>{if(!K)return()=>B;if(!n(K))throw new TypeError("Target element must be a custom element");let H=N(async()=>{return await customElements.whenDefined(K.localName),K.getSignal($)});return()=>{let Z=H.get();return Z===V?B:Z.get()}},OK=(K,$,B,H)=>{let Z=(K.shadowRoot||K).querySelector($);if(Z){if(H&&!n(Z))throw new XK(K,Z,B);return Z}throw new h(K,$,B)},EK=(K,$,B)=>(H)=>{let Z=OK(H,K,B,!0);return N(async()=>{return await customElements.whenDefined(Z.localName),$(Z)})};var fK=new Set(["constructor","prototype"]),gK=new Set(["id","class","className","title","role","style","dataset","lang","dir","hidden","children","innerHTML","outerHTML","textContent","innerText"]),qK=(K)=>{if(fK.has(K))return`Property name "${K}" is a reserved word`;if(gK.has(K))return`Property name "${K}" conflicts with inherited HTMLElement property`;return null},zK=(K,$,B=$)=>{if(!Array.isArray(K))return K($,B);let H=K.filter(z).map((Z)=>Z($,B));return()=>{H.filter(z).forEach((Z)=>Z()),H.length=0}},pK=()=>({first:(K,$,B)=>(H)=>{let Z=(H.shadowRoot||H).querySelector(K);if(!Z&&B!=null)throw new h(H,K,B);if(Z)zK($,H,Z)},all:(K,$,B)=>(H)=>{let Z=new Map,J=H.shadowRoot||H,L=(Q)=>{let X=zK($,H,Q);if(X&&!Z.has(Q))Z.set(Q,X)},W=(Q)=>{let X=Z.get(Q);if(X)X();Z.delete(Q)},A=(Q)=>(X)=>{if(MK(X)){if(X.matches(K))Q(X);X.querySelectorAll(K).forEach(Q)}},G=jK(J,K,(Q)=>{for(let X of Q)X.addedNodes.forEach(A(L)),X.removedNodes.forEach(A(W))}),j=J.querySelectorAll(K);if(!j.length&&B!=null)throw new h(H,K,B);if(j.length)j.forEach(L);return()=>{G.disconnect(),Z.forEach((Q)=>Q()),Z.clear()}}}),dK=(K,$={},B)=>{if(!K.includes("-")||!K.match(/^[a-z][a-z0-9-]*$/))throw new QK(K);for(let Z of Object.keys($)){let J=qK(Z);if(J)throw new $K(K,Z,J)}class H extends HTMLElement{debug;#K={};#$;static observedAttributes=Object.entries($)?.filter(([,Z])=>o(Z)).map(([Z])=>Z)??[];connectedCallback(){if(M){if(this.debug=this.hasAttribute("debug"),this.debug)y(this,"Connected")}for(let[J,L]of Object.entries($)){if(L==null||J in this)continue;let W=z(L)?L(this,null):L;if(W!=null)this.setSignal(J,T(W))}let Z=B(this,pK());if(Array.isArray(Z)||z(Z)){let J=zK(Z,this);if(J)this.#$=J}else throw new YK(this)}disconnectedCallback(){if(z(this.#$))this.#$();if(M&&this.debug)y(this,"Disconnected")}attributeChangedCallback(Z,J,L){if(L===J||p(this.#K[Z]))return;let W=$[Z];if(!o(W))return;let A=W(this,L,J);if(M&&this.debug)y(L,`Attribute "${String(Z)}" of ${Y(this)} changed from ${d(J)} to ${d(L)}, parsed as <${KK(A)}> ${d(A)}`);if(Z in this)this[Z]=A;else this.setSignal(Z,T(A))}getSignal(Z){let J=this.#K[Z];if(M&&this.debug)y(J,`Get ${KK(J)} "${String(Z)}" in ${Y(this)}`);return J}setSignal(Z,J){let L=qK(String(Z));if(L)throw new $K(this.localName,Z,L);if(!R(J))throw new GK(this,Z);let W=this.#K[Z],A=P(J);if(this.#K[Z]=J,Object.defineProperty(this,Z,{get:J.get,set:A?J.set:void 0,enumerable:!0,configurable:A}),W&&P(W))W.set(V);if(M&&this.debug)y(J,`Set ${KK(J)} "${String(Z)} in ${Y(this)}`)}}customElements.define(K,H)};var S=Symbol("RESET"),m=(K,$,B,H)=>{try{return U(K)?$.getSignal(K).get():R(K)?K.get():z(K)?K(B):S}catch(Z){if(H)y(Z,`Failed to resolve value of ${d(K)}${H?` for ${H}`:""} in ${Y(B)}${$!==B?` in ${Y($)}`:""}`,w);return S}};var hK=(K,$,B)=>(H)=>{let Z=new Set,J=I(H,K),L=new Map,W,A=()=>{for(let[G,j]of Object.entries(B)){let Q=(X)=>{let O=X.target;if(!O)return;let q=O.closest($);if(!q||!H.contains(q))return;X.stopPropagation();try{let x=j({event:X,host:H,target:q,value:J});if(x==null)return;if(!Object.is(x,J)){if(J=x,Z.size>0)F(Z);else if(W)W()}}catch(x){throw X.stopImmediatePropagation(),x}};L.set(G,Q),H.addEventListener(G,Q)}W=()=>{if(L.size){for(let[G,j]of L)H.removeEventListener(G,j);L.clear()}W=void 0}};return{[Symbol.toStringTag]:E,get(){if(D(Z),Z.size&&!L.size)A();return J}}},mK=(K,$,B=!1)=>(H,Z)=>{let J=(L)=>{let W=$({host:H,target:Z,event:L});if(!i(W))return;t(()=>{for(let[A,G]of Object.entries(W)){let j=H.getSignal(A);if(P(j))j.set(G);else y(G,`Reactive property "${A}" on ${Y(H)} from event ${K} on ${Y(Z)} could not be set, because it is read-only.`,w)}})};return Z.addEventListener(K,J,B),()=>Z.removeEventListener(K,J)},vK=(K,$)=>(B,H)=>f(()=>{let Z=m($,B,H,`custom event "${K}" detail`);if(Z===S||Z===V)return;H.dispatchEvent(new CustomEvent(K,{detail:Z,bubbles:!0}))});var VK="context-request";class _K extends Event{K;$;B;constructor(K,$,B=!1){super(VK,{bubbles:!0,composed:!0});this.context=K;this.callback=$;this.subscribe=B}}var cK=(K)=>($)=>{let B=(H)=>{let{context:Z,callback:J}=H;if(K.includes(Z)&&z(J))H.stopImmediatePropagation(),J($.getSignal(String(Z)))};return $.addEventListener(VK,B),()=>$.removeEventListener(VK,B)},uK=(K,$)=>(B)=>{let H=T(I(B,$));return B.dispatchEvent(new _K(K,(Z)=>{H=Z})),H};var xK=(K,$)=>{if($==null)return;let B=K($);return Number.isFinite(B)?B:void 0},iK=()=>(K,$)=>$!=null&&$!=="false",nK=(K=0)=>($,B)=>{if(B==null)return I($,K);let H=B.trim();if(H.toLowerCase().startsWith("0x"))return xK((J)=>parseInt(J,16),H)??I($,K);let Z=xK(parseFloat,B);return Z!=null?Math.trunc(Z):I($,K)},oK=(K=0)=>($,B)=>xK(parseFloat,B)??I($,K),sK=(K="")=>($,B)=>B??I($,K),lK=(K)=>($,B)=>{if(B==null)return K[0];let H=B.toLowerCase();return K.find((J)=>J.toLowerCase()===H)?B:K[0]},rK=(K)=>($,B)=>{if((B??K)==null)throw new TypeError("asJSON: Value and fallback are both null or undefined");if(B==null)return I($,K);if(B==="")throw new TypeError("Empty string is not valid JSON");let H;try{H=JSON.parse(B)}catch(Z){throw new SyntaxError(`Failed to parse JSON: ${String(Z)}`,{cause:Z})}return H??I($,K)};var aK=(K,$="")=>{return{a:"attribute ",c:"class ",d:"dataset ",h:"inner HTML",m:"method call ",p:"property ",s:"style property ",t:"text content"}[K]+$},tK=(K,$,B,H,Z)=>{return{ok:(W)=>()=>{if(M&&K.debug)y($,`${W} ${B} of ${Y($)} in ${Y(K)}`);H?.($)},err:(W)=>(A)=>{y(A,`Failed to ${W} ${B} of ${Y($)} in ${Y(K)}`,w),Z?.(A)}}},eK=(K)=>{if(/^(mailto|tel):/i.test(K))return!0;if(K.includes("://"))try{let $=new URL(K,window.location.origin);return["http:","https:","ftp:"].includes($.protocol)}catch{return!1}return!0},K$=(K,$,B)=>{if(/^on/i.test($))throw new Error(`Unsafe attribute: ${$}`);if(B=String(B).trim(),!eK(B))throw new Error(`Unsafe URL for ${$}: ${B}`);K.setAttribute($,B)},C=(K,$)=>(B,H)=>{let{op:Z,name:J="",read:L,update:W}=$,A=L(H),G=aK(Z,J);if(U(K)&&U(A)&&B[K]===S)B.attributeChangedCallback(K,null,A);let{ok:j,err:Q}=tK(B,H,G,$.resolve,$.reject);return f(()=>{let X=Symbol(J?`${Z}:${J}`:Z),O=m(K,B,H,G),q=O===S?A:O===V?$.delete?null:A:O;if($.delete&&q===null)b(()=>{return $.delete(H),!0},X).then(j("Deleted")).catch(Q("delete"));else if(q!=null){let x=L(H);if(Object.is(q,x))return;b(()=>{return W(H,q),!0},X).then(j("Updated")).catch(Q("update"))}})},$$=(K,$)=>(B,H)=>{let Z=(L)=>()=>{if(M&&B.debug)y(H,`${L} element in ${Y(H)} in ${Y(B)}`);if(z($?.resolve))$.resolve(H);else{let W=R(K)?K:U(K)?B.getSignal(K):void 0;if(P(W))W.set(0)}},J=(L)=>(W)=>{y(W,`Failed to ${L} element in ${Y(H)} in ${Y(B)}`,w),$?.reject?.(W)};return f(()=>{let L=Symbol("i"),W=Symbol("r"),A=m(K,B,H,"insertion or deletion"),G=A===S?0:A;if(G>0){if(!$)throw new TypeError("No inserter provided");b(()=>{for(let j=0;j<G;j++){let Q=$.create(H);if(!Q)continue;H.insertAdjacentElement($.position??"beforeend",Q)}return!0},L).then(Z("Inserted")).catch(J("insert"))}else if(G<0)b(()=>{if($&&($.position==="afterbegin"||$.position==="beforeend"))for(let j=0;j>G;j--)if($.position==="afterbegin")H.firstElementChild?.remove();else H.lastElementChild?.remove();else H.remove();return!0},W).then(Z("Removed")).catch(J("remove"))})},B$=(K)=>C(K,{op:"t",read:($)=>$.textContent,update:($,B)=>{Array.from($.childNodes).filter((H)=>H.nodeType!==Node.COMMENT_NODE).forEach((H)=>H.remove()),$.append(document.createTextNode(B))}}),H$=(K,$=K)=>C($,{op:"p",name:K,read:(B)=>(K in B)?B[K]:V,update:(B,H)=>{B[K]=H}}),Z$=(K)=>C(K,{op:"p",name:"hidden",read:($)=>!$.hidden,update:($,B)=>{$.hidden=!B}});var J$=(K)=>C(K,{op:"m",name:"focus",read:($)=>$===document.activeElement,update:($,B)=>{if(B&&WK($,"focus"))$.focus()}}),L$=(K,$=K)=>C($,{op:"a",name:K,read:(B)=>B.getAttribute(K),update:(B,H)=>{K$(B,K,H)},delete:(B)=>{B.removeAttribute(K)}}),W$=(K,$=K)=>C($,{op:"a",name:K,read:(B)=>B.hasAttribute(K),update:(B,H)=>{B.toggleAttribute(K,H)}}),A$=(K,$=K)=>C($,{op:"c",name:K,read:(B)=>B.classList.contains(K),update:(B,H)=>{B.classList.toggle(K,H)}}),Q$=(K,$=K)=>C($,{op:"s",name:K,read:(B)=>B.style.getPropertyValue(K),update:(B,H)=>{B.style.setProperty(K,H)},delete:(B)=>{B.style.removeProperty(K)}}),X$=(K,$={})=>C(K,{op:"h",read:(B)=>(B.shadowRoot||!$.shadowRootMode?B:null)?.innerHTML??"",update:(B,H)=>{let{shadowRootMode:Z,allowScripts:J}=$;if(!H){if(B.shadowRoot)B.shadowRoot.innerHTML="<slot></slot>";return""}if(Z&&!B.shadowRoot)B.attachShadow({mode:Z});let L=B.shadowRoot||B;if(L.innerHTML=H,!J)return"";return L.querySelectorAll("script").forEach((W)=>{let A=document.createElement("script");A.appendChild(document.createTextNode(W.textContent??"")),L.appendChild(A),W.remove()})," with scripts"}}),Y$=(K)=>($,B)=>{if(!i(K))throw new TypeError("Reactives must be an object of passed signals");if(!n(B))throw new TypeError(`Target ${Y(B)} is not a custom element`);customElements.whenDefined(B.localName).then(()=>{if(!WK(B,"setSignal"))throw new TypeError(`Target ${Y(B)} is not a UIElement component`);for(let[H,Z]of Object.entries(K))B.setSignal(H,U(Z)?$.getSignal(Z):T(Z))}).catch((H)=>{throw new Error(`Failed to pass signals to ${Y(B)}`,{cause:H})})};var yK=()=>(K)=>K.textContent?.trim(),G$=(K)=>($)=>$[K],j$=(K)=>($)=>$.hasAttribute(K),IK=(K)=>($)=>$.getAttribute(K),z$=(K)=>($)=>$.classList.contains(K),V$=(K)=>($)=>window.getComputedStyle($).getPropertyValue(K),x$=(K)=>BK("",{".label":yK(),[K]:IK("aria-label")}),y$=(K)=>BK("",{".description":yK(),[K]:IK("aria-describedby")});export{C as updateElement,A$ as toggleClass,W$ as toggleAttribute,T as toSignal,e as state,Z$ as show,B$ as setText,Q$ as setStyle,H$ as setProperty,L$ as setAttribute,m as resolveReactive,OK as requireElement,kK as reduced,bK as read,cK as provideContexts,Y$ as pass,mK as on,y as log,P as isState,R as isSignal,o as isParser,p as isComputed,$$ as insertOrRemoveElement,z$ as hasClass,j$ as hasAttribute,yK as getText,V$ as getStyle,G$ as getProperty,x$ as getLabel,I as getFallback,y$ as getDescription,IK as getAttribute,CK as fromSelector,hK as fromEvents,BK as fromDOM,uK as fromContext,EK as fromComponent,J$ as focus,b as enqueue,vK as emitEvent,f as effect,X$ as dangerouslySetInnerHTML,N as computed,dK as component,t as batch,sK as asString,oK as asNumber,rK as asJSON,nK as asInteger,lK as asEnum,iK as asBoolean,V as UNSET,FK as LOG_WARN,RK as LOG_INFO,w as LOG_ERROR,UK as LOG_DEBUG};

//# debugId=25D60E0FA418540F64756E2164756E21
