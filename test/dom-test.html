<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<title>UI Functions Tests</title>
	</head>
	<body>
		<div class="test-element">Content</div>
		<div id="host">
			<div id="test-on-function"></div>
			<div id="test-on-provider"></div>
			<div id="test-on-invalid"></div>
		</div>
		<child-component id="orphan">
			<h1>Hello from Server</h1>
			<p>Text from Server</p>
		</child-component>
		<parent-component id="parent" heading="Hello from Attribute">
			<child-component id="child">
				<h1>Hello from Server</h1>
				<p>Text from Server</p>
			</child-component>
			<invalid-component id="invalid"></invalid-component>
		</parent-component>
		<read-component id="read" value="test-value"></read-component>
		<test-signal-producers-integration>
			<div class="item" data-value="10">Item 1</div>
			<div class="item" data-value="20">Item 2</div>
			<input type="text" />
			<p></p>
		</test-signal-producers-integration>

		<script type="module">
			import { runTests } from '@web/test-runner-mocha'
			import { assert } from '@esm-bundle/chai'
			import {
				RESET,
				asString,
				component,
				computed,
				effect,
				fromDescendants,
				fromDescendant,
				fromEvent,
				fromSelector,
				read,
				on,
				pass,
				selection,
				sensor,
				setText,
				state,
			} from '../index.dev.js'

			const wait = ms => new Promise(resolve => setTimeout(resolve, ms))
			const animationFrame = async () =>
				new Promise(requestAnimationFrame)
			const microtask = async () => new Promise(queueMicrotask)
			const normalizeText = text => text.replace(/\s+/g, ' ').trim()

			component(
				'child-component',
				{
					heading: asString(RESET),
					text: asString(RESET),
				},
				(_, { first }) => [
					first('h1', setText('heading')),
					first('p', setText('text')),
				],
			)

			component(
				'parent-component',
				{
					heading: asString(RESET),
				},
				(el, { first }) => [
					first(
						'child-component',
						pass({
							heading: 'heading',
							text: () => el.heading.toUpperCase(),
						}),
					),
				],
			)
			component(
				'read-component',
				{
					value: asString(),
				},
				() => [],
			)

			component(
				'form-textbox',
				{
					value: asString(),
					length: 0,
				},
				(el, { first }) => [
					first(
						'input',
						on('input', e => {
							el.length = e.target.value.length
						}),
						on('change', e => {
							el.value = e.target.value
						}),
					),
				],
			)

			component(
				'test-signal-producers-integration',
				{
					items: fromSelector('.item'),
					total: fromDescendants(
						'[data-value]',
						(sum, element) =>
							sum + parseInt(element.dataset.value || '0'),
						0,
					),
					lastInput: fromEvent(
						'input',
						'input',
						(_, source) => source.value,
						'',
					),
				},
				(_, { first }) => [first('p', setText('lastInput'))],
			)

			class InvalidComponent extends HTMLElement {
				constructor() {
					super()
					throw new Error('Invalid component')
				}
			}
			customElements.define('invalid-component', InvalidComponent)

			runTests(() => {
				describe('selection()', () => {
					it('should create a signal returning an empty array for no matching elements', () => {
						const signal = selection(document, '.nonexistent')
						assert.deepEqual(signal.get(), [])
					})

					it('should return an array of elements matching the selector', () => {
						const signal = selection(document, '.test-element')
						const elements = Array.from(
							document.querySelectorAll('.test-element'),
						)
						assert.deepEqual(signal.get(), elements)
					})

					it('should update the signal when elements are added or removed', () => {
						const signal = selection(document, '.test-element')

						const newElement = document.createElement('div')
						newElement.classList.add('test-element')
						document.body.appendChild(newElement)
						let elements = Array.from(
							document.querySelectorAll('.test-element'),
						)
						assert.deepEqual(signal.get(), elements)

						newElement.remove()
						elements = Array.from(
							document.querySelectorAll('.test-element'),
						)
						assert.deepEqual(signal.get(), elements)
					})

					it('should update the signal when matching class is added or removed', () => {
						const signal = selection(document.body, '.test-element')
						const newElement = document.createElement('div')
						document.body.appendChild(newElement)
						let elements = Array.from(
							document.querySelectorAll('.test-element'),
						)
						assert.deepEqual(signal.get(), elements)

						newElement.classList.add('test-element')
						elements = Array.from(
							document.querySelectorAll('.test-element'),
						)
						assert.deepEqual(signal.get(), elements)

						newElement.classList.remove('test-element')
						elements = Array.from(
							document.querySelectorAll('.test-element'),
						)
						assert.deepEqual(signal.get(), elements)
					})

					it('should update the signal when matching id is added or removed', () => {
						const signal = selection(document, '#test-element')
						const newElement = document.createElement('div')
						document.body.appendChild(newElement)
						let elements = Array.from(
							document.querySelectorAll('#test-element'),
						)
						assert.deepEqual(signal.get(), elements)

						newElement.id = 'test-element'
						elements = Array.from(
							document.querySelectorAll('#test-element'),
						)
						assert.deepEqual(signal.get(), elements)

						newElement.removeAttribute('id')
						elements = Array.from(
							document.querySelectorAll('#test-element'),
						)
						assert.deepEqual(signal.get(), elements)
					})

					it('should update the computed signal watching the element selection when elements are added or removed', async () => {
						const signal = selection(document, '.test-element')
						const contents = computed(elements =>
							signal.get().map(element => element.textContent),
						)

						// Wait for initial setup
						await microtask()
						assert.deepEqual(contents.get(), ['Content'])

						const newElement = document.createElement('div')
						newElement.textContent = 'New Content'
						newElement.classList.add('test-element')
						document.body.appendChild(newElement)
						await microtask()
						assert.deepEqual(contents.get(), [
							'Content',
							'New Content',
						])

						newElement.remove()
						await microtask()
						assert.deepEqual(contents.get(), ['Content'])
					})

					it('should apply the effect to an updated array of elements when elements are added or removed', async () => {
						const signal = selection(document, '.test-element')

						// Reset hidden state first
						document
							.querySelectorAll('.test-element')
							.forEach(element => {
								element.hidden = false
							})

						const cleanup = effect({
							signals: [signal],
							ok: elements =>
								elements
									.filter(element => !element.hidden)
									.map(element => {
										element.hidden = true
									}),
						})

						// Wait for initial effect to run
						await microtask()

						const newElement = document.createElement('div')
						newElement.textContent = 'New Content'
						newElement.classList.add('test-element')
						document.body.appendChild(newElement)
						await microtask()
						let expected = Array.from(
							document.querySelectorAll('.test-element'),
						).map(element => element.hidden)
						assert.deepEqual(expected, [true, true])
						document
							.querySelectorAll('.test-element')
							.forEach(element => {
								element.hidden = false
							})

						newElement.remove()
						await microtask()
						expected = Array.from(
							document.querySelectorAll('.test-element'),
						).map(element => element.hidden)
						assert.deepEqual(expected, [true])
						document
							.querySelectorAll('.test-element')
							.forEach(element => {
								element.hidden = false
							})

						cleanup()
					})

					it('should handle complex selectors with multiple attributes', async () => {
						const container = document.createElement('div')
						document.body.appendChild(container)

						try {
							const signal = selection(
								container,
								'div[data-test="value"].active[role="button"]',
							)

							// Initially empty
							assert.deepEqual(signal.get(), [])

							// Add element that partially matches
							const partial = document.createElement('div')
							partial.setAttribute('data-test', 'value')
							container.appendChild(partial)

							await microtask()
							assert.deepEqual(signal.get(), [])

							// Add all required attributes
							partial.classList.add('active')
							partial.setAttribute('role', 'button')

							await microtask()
							assert.deepEqual(signal.get(), [partial])

							// Remove one attribute
							partial.removeAttribute('role')

							await microtask()
							assert.deepEqual(signal.get(), [])
						} finally {
							container.remove()
						}
					})

					it('should handle attribute selectors with different operators', async () => {
						const container = document.createElement('div')
						document.body.appendChild(container)

						try {
							const signal = selection(
								container,
								'[data-prefix^="test"]',
							)

							const element1 = document.createElement('div')
							element1.setAttribute('data-prefix', 'testing')
							container.appendChild(element1)

							await microtask()
							assert.deepEqual(signal.get(), [element1])

							const element2 = document.createElement('div')
							element2.setAttribute('data-prefix', 'nottesting')
							container.appendChild(element2)

							await microtask()
							assert.deepEqual(signal.get(), [element1])

							element2.setAttribute('data-prefix', 'test-value')

							await microtask()
							assert.deepEqual(signal.get(), [element1, element2])
						} finally {
							container.remove()
						}
					})

					it('should properly disconnect observer when no watchers exist', () => {
						const container = document.createElement('div')
						document.body.appendChild(container)

						try {
							const signal = selection(container, '.test')

							// Get value to create observer
							signal.get()

							// Add element to trigger mutation
							const element = document.createElement('div')
							element.classList.add('test')
							container.appendChild(element)

							// Observer should disconnect automatically since no watchers
							assert.deepEqual(signal.get(), [element])
						} finally {
							container.remove()
						}
					})

					it('should handle rapid DOM mutations efficiently', async () => {
						const container = document.createElement('div')
						document.body.appendChild(container)

						try {
							const signal = selection(container, '.rapid-test')
							let updateCount = 0

							const cleanup = effect({
								signals: [signal],
								ok: () => {
									updateCount++
								},
							})

							// Rapid mutations
							for (let i = 0; i < 10; i++) {
								const element = document.createElement('div')
								element.classList.add('rapid-test')
								container.appendChild(element)
							}

							await animationFrame()

							// Should handle rapid mutations without excessive updates
							assert.isBelow(
								updateCount,
								15,
								'Should not update excessively for rapid mutations',
							)
							assert.equal(signal.get().length, 10)

							cleanup()
						} finally {
							container.remove()
						}
					})

					it('should detect circular mutations and throw CircularMutationError', async () => {
						// Create a container div
						const container = document.createElement('div')
						document.body.appendChild(container)

						try {
							// Add an initial element to trigger the effect
							const initialElement = document.createElement('div')
							initialElement.classList.add('circular-test')
							container.appendChild(initialElement)

							// Create a selection signal watching for .circular-test elements
							const signal = selection(
								container,
								'.circular-test',
							)

							let errorCaught = false
							let effectRanCount = 0

							// Set up an effect that creates a circular dependency
							const cleanup = effect({
								signals: [signal],
								ok: elements => {
									effectRanCount++
									if (effectRanCount <= 3) {
										elements.forEach(element => {
											const newElement =
												document.createElement('div')
											newElement.classList.add(
												'circular-test',
											)
											newElement.textContent = `Element ${effectRanCount}`
											element.appendChild(newElement)
										})
									}
								},
								err: error => {
									errorCaught = true
									assert.equal(
										error.name,
										'CircularMutationError',
									)
									assert.include(
										error.message,
										'Circular mutation in element selection detected',
									)
									cleanup()
								},
							})

							// Wait for effects to run
							await animationFrame()

							// Either error should be caught or effect should have run multiple times
							assert.isTrue(
								errorCaught || effectRanCount > 1,
								'Should either catch circular mutation error or run effect multiple times',
							)

							if (!errorCaught) {
								cleanup()
							}
						} finally {
							// Clean up
							container.remove()
						}
					})
				})

				describe('read()', () => {
					it('should return fallback when source is null', () => {
						const reader = read(null, 'value', 'default')
						assert.equal(reader(), 'default')
					})

					it('should return fallback when property does not exist on source', () => {
						const div = document.createElement('div')
						const reader = read(div, 'value', 'fallback')
						assert.equal(reader(), 'fallback')
					})

					it('should return property value of source element for non custom elements', () => {
						const div = document.createElement('div')
						div.className = 'test'
						const reader = read(div, 'className', 'fallback')
						assert.equal(reader(), 'test')
					})

					it('should return fallback until component is defined', async () => {
						// Create a mock component that's not yet defined
						const mockElement = document.createElement(
							'undefined-component',
						)

						const reader = read(mockElement, 'value', 'fallback')

						// Should return fallback initially
						assert.equal(reader(), 'fallback')
					})

					it('should read component property after component is defined', async () => {
						const element = document.getElementById('read')
						const reader = read(element, 'value', 'fallback')

						// Should return fallback initially
						// assert.equal(reader(), 'fallback')

						// Wait for component to be defined and upgraded
						await customElements.whenDefined('read-component')

						// Now should return component value
						assert.equal(reader(), 'test-value')
					})

					it('should work with module-todo pattern reading input length', async () => {
						// Simulate the module-todo pattern with form-textbox

						const textbox = document.createElement('form-textbox')
						const input = document.createElement('input')
						textbox.appendChild(input)
						document.body.appendChild(textbox)

						try {
							const inputLength = read(textbox, 'length', 0)

							// Should return fallback initially
							assert.equal(inputLength(), 0)

							// Wait for component to be defined
							await customElements.whenDefined('form-textbox')

							// Initially should be 0
							assert.equal(inputLength(), 0)

							// Change value and test length updates
							input.value = 'hello'
							input.dispatchEvent(new Event('input'))
							assert.equal(inputLength(), 5)

							// Test that reader function can be used in effects
							let effectResult = 0
							const cleanup = effect(() => {
								effectResult = inputLength()
							})

							await animationFrame()
							assert.equal(effectResult, 5)

							// Change value again - use setter to trigger length update
							input.value = 'world!'
							input.dispatchEvent(new Event('input'))
							assert.equal(effectResult, 6)

							cleanup()
						} finally {
							input.remove()
						}
					})

					it('should handle component upgrade timing correctly', async () => {
						// Test the actual timing issue that read() solves
						const container = document.createElement('div')
						container.innerHTML =
							'<timing-test-component></timing-test-component>'
						document.body.appendChild(container)

						try {
							// Get element before it's defined (like querySelector in real usage)
							const element = container.querySelector(
								'timing-test-component',
							)

							// Create reader before component is defined
							const reader = read(element, 'status', 'not-ready')

							// Should return fallback initially
							assert.equal(reader(), 'not-ready')

							// Now define the component
							class TimingTestComponent extends HTMLElement {
								constructor() {
									super()
									this.signals = new Map()
									this.status = 'ready'
								}

								getSignal(prop) {
									if (!this.signals.has(prop)) {
										this.signals.set(prop, {
											get: () => this[prop],
										})
									}
									return this.signals.get(prop)
								}
							}

							customElements.define(
								'timing-test-component',
								TimingTestComponent,
							)

							// Wait for upgrade
							await customElements.whenDefined(
								'timing-test-component',
							)

							// Now should return component value
							assert.equal(reader(), 'ready')
						} finally {
							container.remove()
						}
					})
				})

				describe('on()', () => {
					it('should attach and remove an event listener', async () => {
						const div = document.getElementById('test-on-function')
						let called = false

						const off = on('click', () => {
							called = true
						})({}, div)

						div.click()
						const wasCalled = called

						off() // Remove the event listener
						called = false
						div.click()

						assert.equal(wasCalled, true)
						assert.equal(called, false)
					})

					it('should throw TypeError for invalid handler', async () => {
						const div = document.getElementById('test-on-invalid')
						assert.throws(() => on('click', {})({}, div), TypeError)
					})

					it('should use host as default target', async () => {
						const host = document.getElementById('host')
						let called = false

						const off = on('click', () => {
							called = true
						})(host)

						host.click()
						const wasCalled = called

						off() // Remove the event listener
						called = false
						host.click()

						assert.equal(wasCalled, true)
						assert.equal(called, false)
					})

					it('should handle multiple event types', () => {
						const element = document.createElement('input')
						document.body.appendChild(element) // Add to DOM for focus/blur to work
						let focusCount = 0
						let blurCount = 0

						const cleanup1 = on('focus', () => focusCount++)(
							null,
							element,
						)
						const cleanup2 = on('blur', () => blurCount++)(
							null,
							element,
						)

						element.focus()
						element.blur()

						assert.equal(focusCount, 1)
						assert.equal(blurCount, 1)

						cleanup1()
						cleanup2()
						document.body.removeChild(element) // Clean up
					})
				})

				describe('Orphan child component', function () {
					it('should do nothing at all', async function () {
						const orphanComponent =
							document.getElementById('orphan')
						await animationFrame()
						const headingContent = normalizeText(
							orphanComponent.querySelector('h1').textContent,
						)
						const textContent = normalizeText(
							orphanComponent.querySelector('p').textContent,
						)
						assert.equal(
							headingContent,
							'Hello from Server',
							'Should not change server-side rendered heading',
						)
						assert.equal(
							textContent,
							'Text from Server',
							'Should not change server-side rendered text',
						)
					})
				})

				describe('Child component', function () {
					it('should receive state from attribute of parent component', async function () {
						const childComponent = document.getElementById('child')
						await customElements.whenDefined(
							childComponent.localName,
						)
						const headingContent =
							childComponent.querySelector('h1').textContent
						assert.equal(
							headingContent,
							'Hello from Attribute',
							'Should have initial heading from attribute of parent component',
						)
					})

					it('should receive derived state from attribute of parent component', async function () {
						const childComponent = document.getElementById('child')
						await customElements.whenDefined(
							childComponent.localName,
						)
						const textContent = normalizeText(
							childComponent.querySelector('p').textContent,
						)
						assert.equal(
							textContent,
							'Hello from Attribute'.toUpperCase(),
							'Should have initial text derived from attribute of parent component',
						)
					})

					it('should receive passed and derived states from changed attribute of parent component', async function () {
						const parentComponent =
							document.getElementById('parent')
						const childComponent = document.getElementById('child')
						parentComponent.setAttribute(
							'heading',
							'Hello from Changed Attribute',
						)
						await animationFrame()
						const headingContent = normalizeText(
							childComponent.querySelector('h1').textContent,
						)
						const textContent = normalizeText(
							childComponent.querySelector('p').textContent,
						)
						assert.equal(
							headingContent,
							'Hello from Changed Attribute',
							'Should have changed heading from attribute of parent component',
						)
						assert.equal(
							textContent,
							'Hello from Changed Attribute'.toUpperCase(),
							'Should have changed text derived from attribute of parent component',
						)
					})

					it('should change heading if inherited state is set', async function () {
						const parentComponent =
							document.getElementById('parent')
						const childComponent = document.getElementById('child')
						parentComponent.heading = 'Hello from State on Parent'
						await animationFrame()
						const headingContent =
							childComponent.querySelector('h1').textContent
						assert.equal(
							headingContent,
							'Hello from State on Parent',
							'Should have changed heading from state of parent component',
						)
					})

					it('should throw TypeError if signals are not an object or provider', async function () {
						const parentComponent =
							document.getElementById('parent')
						const childComponent = document.getElementById('child')

						assert.throws(
							() => {
								pass(null)(parentComponent, childComponent)
							},
							TypeError,
							'Passed signals must be an object or a provider function',
						)
					})

					it('should throw TypeError if signals are not a function', async function () {
						const parentComponent =
							document.getElementById('parent')
						const invalidComponent =
							document.getElementById('invalid')

						try {
							pass({ heading: 'heading' })(
								parentComponent,
								invalidComponent,
							)
						} catch (error) {
							assert.equal(
								error instanceof TypeError,
								true,
								'Should throw TypeError',
							)
						}
					})

					it('should handle Signal objects directly', async () => {
						const host = document.querySelector('parent-component')
						const target = document.querySelector('child-component')

						const directSignal = state('Direct Signal')

						try {
							pass({
								heading: directSignal,
							})(host, target)

							await customElements.whenDefined('child-component')
							await animationFrame()

							assert.equal(target.heading, 'Direct Signal')

							// Test reactivity
							directSignal.set('Updated Signal')
							await animationFrame()

							assert.equal(target.heading, 'Updated Signal')
						} catch (error) {
							// If pass fails, test that error handling works
							assert.include(
								error.message,
								'Failed to pass signals',
							)
						}
					})

					it('should pass signals using function', async () => {
						const host = document.querySelector('parent-component')
						const target = document.querySelector('child-component')

						const dynamicSignal = state('Dynamic')

						try {
							pass(targetElement => ({
								text: dynamicSignal,
							}))(host, target)

							await customElements.whenDefined('child-component')
							await animationFrame()

							assert.equal(target.text, 'Dynamic')
						} catch (error) {
							// If pass fails, test that error handling works
							assert.include(
								error.message,
								'Failed to pass signals',
							)
						}
					})
				})

				describe('Edge Cases and Integration', () => {
					it('should handle selection with rapidly changing DOM', async () => {
						const container = document.createElement('div')
						document.body.appendChild(container)

						try {
							const signal = selection(container, '.dynamic')
							let lastCount = 0

							const cleanup = effect({
								signals: [signal],
								ok: elements => {
									lastCount = elements.length
								},
							})

							// Simulate rapid DOM changes
							const elements = []
							for (let i = 0; i < 5; i++) {
								const el = document.createElement('div')
								el.classList.add('dynamic')
								container.appendChild(el)
								elements.push(el)
							}

							await animationFrame()
							assert.equal(lastCount, 5)

							// Remove elements
							elements.forEach(el => el.remove())
							await animationFrame()
							assert.equal(lastCount, 0)

							cleanup()
						} finally {
							container.remove()
						}
					})

					it('should handle events during DOM mutations', async () => {
						const container = document.createElement('div')
						document.body.appendChild(container)

						try {
							const signal = selection(container, '.clickable')
							let clicksReceived = 0

							// Add element
							const button = document.createElement('button')
							button.classList.add('clickable')
							container.appendChild(button)

							await microtask()

							// Attach event listener
							const cleanup = on('click', () => {
								clicksReceived++
								// Modify DOM during event handling
								const newButton =
									document.createElement('button')
								newButton.classList.add('clickable')
								container.appendChild(newButton)
							})(null, button)

							button.click()
							await animationFrame()

							assert.equal(clicksReceived, 1)
							assert.equal(signal.get().length, 2) // Original + new button

							cleanup()
						} finally {
							container.remove()
						}
					})

					it('should handle memory cleanup properly', () => {
						const container = document.createElement('div')
						document.body.appendChild(container)

						try {
							// Create many signals and let them go out of scope
							for (let i = 0; i < 100; i++) {
								const signal = selection(
									container,
									`.test-${i}`,
								)
								signal.get() // Access to trigger observer creation
							}

							// Force garbage collection if possible
							if (typeof window !== 'undefined' && window.gc) {
								window.gc()
							}

							// Should not throw or cause memory issues
							assert.isTrue(true, 'Memory cleanup should work')
						} finally {
							container.remove()
						}
					})
				})

				describe('sensor()', () => {
					it('should create a computed signal from event data', async () => {
						const button = document.createElement('button')
						button.textContent = 'Click me'
						document.body.appendChild(button)

						try {
							const clickSignal = sensor(
								document.body,
								button,
								'click',
								(host, source, event, oldValue) => {
									assert.equal(host, document.body)
									assert.equal(source, button)
									assert.instanceOf(event, MouseEvent)
									return oldValue + 1
								},
								0,
							)

							// Use with a computed to ensure it behaves like a signal
							let lastValue = 0
							const cleanup = effect(() => {
								lastValue = clickSignal.get()
							})

							// Should start with initial value
							assert.equal(lastValue, 0)

							// Should update when event fires
							button.click()
							await animationFrame()
							assert.equal(lastValue, 1)

							button.click()
							await animationFrame()
							assert.equal(lastValue, 2)

							cleanup()
						} finally {
							button.remove()
						}
					})

					it('should handle input events with proper typing', async () => {
						const input = document.createElement('input')
						input.type = 'text'
						document.body.appendChild(input)

						try {
							const valueSignal = sensor(
								document.body,
								input,
								'input',
								(host, source, event, oldValue) => {
									assert.instanceOf(event, Event)
									return source.value
								},
								'',
							)

							// Use in an effect to test reactivity
							let currentValue = ''
							const cleanup = effect(() => {
								currentValue = valueSignal.get()
							})

							assert.equal(currentValue, '')

							input.value = 'hello'
							input.dispatchEvent(
								new Event('input', { bubbles: true }),
							)
							await animationFrame()
							assert.equal(currentValue, 'hello')

							cleanup()
						} finally {
							input.remove()
						}
					})

					it('should work with computed signals', async () => {
						const button = document.createElement('button')
						document.body.appendChild(button)

						try {
							const clickSignal = sensor(
								document.body,
								button,
								'click',
								(_, __, ___, oldValue) => oldValue + 1,
								0,
							)

							const doubledSignal = computed(
								() => clickSignal.get() * 2,
							)

							// Test initial computed value
							assert.equal(doubledSignal.get(), 0)

							// Test that clicking updates the computed
							button.click()
							await animationFrame()
							assert.equal(doubledSignal.get(), 2) // 1 * 2
						} finally {
							button.remove()
						}
					})

					it('should cleanup event listeners when no watchers remain', async () => {
						const button = document.createElement('button')
						button.id = 'cleanup-test-button'
						document.body.appendChild(button)

						try {
							let eventCount = 0
							const clickSignal = sensor(
								document.body,
								button,
								'click',
								() => ++eventCount,
								0,
							)

							// Access signal in an effect - creates watcher
							let effectRanCount = 0
							const cleanup = effect(() => {
								clickSignal.get()
								effectRanCount++
							})

							// Wait for initial effect
							await animationFrame()

							// Click should trigger the effect
							button.click()
							await animationFrame()
							assert.equal(effectRanCount, 2) // initial + after click

							// Remove the watcher by cleaning up the effect
							cleanup()

							// Next click should not trigger the effect and remove listener
							button.click()
							await animationFrame()
							assert.equal(effectRanCount, 2) // initial + after click

							// Reset event count to test if listener is removed
							eventCount = 0

							// Click should not trigger the effect anymore
							button.click()

							// Event count should remain 0 if cleanup worked
							assert.equal(eventCount, 0)
						} finally {
							button.remove()
						}
					})
				})

				describe('fromSelector()', () => {
					it('should create a signal producer that selects elements', () => {
						const container = document.createElement('div')
						container.innerHTML = `
						<div class="test-item">Item 1</div>
						<div class="test-item">Item 2</div>
						<div class="other">Other</div>
					`
						document.body.appendChild(container)

						try {
							const producer = fromSelector('.test-item')
							const signal = producer(container)
							const elements = signal.get()

							assert.equal(elements.length, 2)
							assert.equal(elements[0].textContent, 'Item 1')
							assert.equal(elements[1].textContent, 'Item 2')
						} finally {
							container.remove()
						}
					})

					it('should update when matching elements change', async () => {
						const container = document.createElement('div')
						container.innerHTML = `<div class="item">Item 1</div>`
						document.body.appendChild(container)

						try {
							const producer = fromSelector('.item')
							const signal = producer(container)

							assert.equal(signal.get().length, 1)

							// Add new matching element
							const newItem = document.createElement('div')
							newItem.className = 'item'
							newItem.textContent = 'Item 2'
							container.appendChild(newItem)

							await animationFrame()
							assert.equal(signal.get().length, 2)

							// Remove element
							newItem.remove()
							await animationFrame()
							assert.equal(signal.get().length, 1)
						} finally {
							container.remove()
						}
					})

					it('should work with complex selectors', () => {
						const container = document.createElement('div')
						container.innerHTML = `
						<input type="text" class="form-control" />
						<input type="password" class="form-control" />
						<input type="text" />
						<textarea class="form-control"></textarea>
					`
						document.body.appendChild(container)

						try {
							const producer = fromSelector('input.form-control')
							const signal = producer(container)
							const elements = signal.get()

							assert.equal(elements.length, 2)
							assert.equal(elements[0].type, 'text')
							assert.equal(elements[1].type, 'password')
						} finally {
							container.remove()
						}
					})
				})

				describe('fromDescendants()', () => {
					it('should reduce child elements to a single value', () => {
						const container = document.createElement('div')
						container.innerHTML = `
						<div data-value="10">Item 1</div>
						<div data-value="20">Item 2</div>
						<div data-value="30">Item 3</div>
					`
						document.body.appendChild(container)

						try {
							const producer = fromDescendants(
								'[data-value]',
								(total, element) =>
									total
									+ parseInt(element.dataset.value || '0'),
								0,
							)(container)
							assert.equal(producer(), 60) // 10 + 20 + 30
						} finally {
							container.remove()
						}
					})

					it('should update when child elements change', async () => {
						const container = document.createElement('div')
						container.innerHTML = `
						<div data-count="1">Item 1</div>
						<div data-count="1">Item 2</div>
					`
						document.body.appendChild(container)

						try {
							const producer = fromDescendants(
								'[data-count]',
								(total, element) =>
									total
									+ parseInt(element.dataset.count || '0'),
								0,
							)(container)
							assert.equal(producer(), 2)

							// Add new element
							const newItem = document.createElement('div')
							newItem.dataset.count = '3'
							newItem.textContent = 'Item 3'
							container.appendChild(newItem)

							await animationFrame()
							assert.equal(producer(), 5) // 1 + 1 + 3
						} finally {
							container.remove()
						}
					})

					it('should work with complex reducers', () => {
						const container = document.createElement('div')
						container.innerHTML = `
						<input type="checkbox" checked />
						<input type="checkbox" />
						<input type="checkbox" checked />
						<input type="radio" />
					`
						document.body.appendChild(container)

						try {
							const producer = fromDescendants(
								'input[type="checkbox"]',
								(acc, input) => ({
									total: acc.total + 1,
									checked:
										acc.checked + (input.checked ? 1 : 0),
								}),
								{ total: 0, checked: 0 },
							)(container)
							const result = producer()

							assert.equal(result.total, 3)
							assert.equal(result.checked, 2)
						} finally {
							container.remove()
						}
					})
				})

				describe('fromEvent()', () => {
					it('should create a signal producer from input events', async () => {
						const container = document.createElement('div')
						container.innerHTML = `<input type="text" id="test-input" />`
						document.body.appendChild(container)

						try {
							const producer = fromEvent(
								'#test-input',
								'input',
								(host, source, event) => {
									assert.equal(host, container)
									assert.equal(source.id, 'test-input')
									assert.instanceOf(event, Event)
									return source.value
								},
								'',
							)
							const signal = producer(container)

							// Use in effect to test reactivity
							let currentValue = ''
							const cleanup = effect(() => {
								currentValue = signal.get()
							})

							assert.equal(currentValue, '')

							const input = container.querySelector('#test-input')
							input.value = 'hello'
							input.dispatchEvent(
								new Event('input', { bubbles: true }),
							)

							assert.equal(currentValue, 'hello')

							cleanup()
						} finally {
							container.remove()
						}
					})

					it('should throw error when element not found', () => {
						const container = document.createElement('div')
						document.body.appendChild(container)

						try {
							const producer = fromEvent(
								'.nonexistent',
								'click',
								() => 'clicked',
								'',
							)

							assert.throws(() => {
								producer(container)
							}, /Element not found for selector/)
						} finally {
							container.remove()
						}
					})

					it('should work with function initializers', async () => {
						const container = document.createElement('div')
						container.innerHTML = `<button id="counter">Count: 0</button>`
						document.body.appendChild(container)

						try {
							const producer = fromEvent(
								'#counter',
								'click',
								(host, source, event, oldValue) => oldValue + 1,
								(host, source) => {
									assert.equal(host, container)
									assert.equal(source.id, 'counter')
									return 5 // Start from 5
								},
							)
							const signal = producer(container)

							// Use in effect to test reactivity
							let currentValue = 0
							const cleanup = effect(() => {
								currentValue = signal.get()
							})

							assert.equal(currentValue, 5)

							const button = container.querySelector('#counter')
							button.click()

							assert.equal(currentValue, 6)

							cleanup()
						} finally {
							container.remove()
						}
					})

					it('should handle form events', async () => {
						const container = document.createElement('div')
						container.innerHTML = `
						<form>
							<input type="text" name="username" value="john" />
						</form>
					`
						document.body.appendChild(container)

						try {
							const producer = fromEvent(
								'form',
								'submit',
								(host, source, event) => {
									event.preventDefault()
									event.stopPropagation()
									return new FormData(source)
								},
								null,
							)
							const signal = producer(container)

							// Use in effect to test reactivity
							let formData = null
							const cleanup = effect(() => {
								formData = signal.get()
							})

							assert.equal(formData, null)

							const form = container.querySelector('form')
							const submitEvent = new Event('submit', {
								bubbles: true,
								cancelable: true,
							})
							form.dispatchEvent(submitEvent)

							assert.instanceOf(formData, FormData)
							assert.equal(formData.get('username'), 'john')

							cleanup()
						} finally {
							container.remove()
						}
					})
				})

				describe('fromDescendant()', () => {
					it('should read signals from a descendant component', async () => {
						// Create a mock child component
						class MockChild1 extends HTMLElement {
							constructor() {
								super()
								this.signals = new Map()
								this.value = 'child-value'
							}

							getSignal(prop) {
								if (!this.signals.has(prop)) {
									this.signals.set(prop, {
										get: () => this[prop],
									})
								}
								return this.signals.get(prop)
							}
						}

						customElements.define('mock-child-1', MockChild1)

						const container = document.createElement('div')
						container.innerHTML = `<mock-child-1 id="child"></mock-child-1>`
						document.body.appendChild(container)

						try {
							const producer = fromDescendant(
								'#child',
								'value',
								'fallback',
							)(container)

							// Should return fallback initially
							// assert.equal(producer(), 'fallback')

							// Wait for component to be defined and upgraded
							await customElements.whenDefined('mock-child-1')

							// Should now return component value
							assert.equal(producer(), 'child-value')
						} finally {
							container.remove()
						}
					})

					it('should handle missing child elements', () => {
						const container = document.createElement('div')
						document.body.appendChild(container)

						try {
							const producer = fromDescendant(
								'.nonexistent',
								'value',
								'fallback',
							)(container)

							assert.equal(producer(), 'fallback')
						} finally {
							container.remove()
						}
					})

					it('should work with computed signals', async () => {
						class MockComputed2 extends HTMLElement {
							constructor() {
								super()
								this.signals = new Map()
								this._count = 0
							}

							getSignal(prop) {
								if (!this.signals.has(prop)) {
									this.signals.set(prop, {
										get: () => this._count,
									})
								}
								return this.signals.get(prop)
							}
						}

						customElements.define('mock-computed-2', MockComputed2)

						const container = document.createElement('div')
						container.innerHTML = `<mock-computed-2 id="computed"></mock-computed-2>`
						document.body.appendChild(container)

						try {
							const producer = fromDescendant(
								'#computed',
								'count',
								0,
							)(container)
							const doubled = computed(() => producer() * 2)

							// Initial fallback
							assert.equal(doubled.get(), 0)

							// Wait for component
							await customElements.whenDefined('mock-computed-2')

							assert.equal(doubled.get(), 0) // 0 * 2
						} finally {
							container.remove()
						}
					})
				})

				describe('Integration: Signal Producers in Components', () => {
					it('should reproduce fromEvent component issue', async () => {
						// This test reproduces the issue where fromEvent properties
						// in components don't update when events are dispatched
						const container = document.createElement('div')
						container.innerHTML = `
							<div class="test-component">
								<input type="text" id="comp-input" />
								<span class="length-display"></span>
								<span class="value-display"></span>
							</div>
						`
						document.body.appendChild(container)

						try {
							const host =
								container.querySelector('.test-component')

							// Create fromEvent producers like in form-textbox component
							const lengthProducer = fromEvent(
								'#comp-input',
								'input',
								(host, source, event, oldValue) =>
									source.value.length,
								0,
							)
							const valueProducer = fromEvent(
								'#comp-input',
								'change',
								(host, source, event, oldValue) => source.value,
								'',
							)

							// Create signals
							const lengthSignal = lengthProducer(host)
							const valueSignal = valueProducer(host)

							// Track updates (this simulates component property access)
							let lengthValue = 0
							let valueValue = ''

							// WITHOUT effect wrapper (simulates direct property access)
							lengthValue = lengthSignal.get()
							valueValue = valueSignal.get()

							assert.equal(
								lengthValue,
								0,
								'Initial length should be 0',
							)
							assert.equal(
								valueValue,
								'',
								'Initial value should be empty',
							)

							// Simulate typing (like test helper does)
							const input = host.querySelector('#comp-input')
							input.value = 'hello'
							input.dispatchEvent(
								new Event('input', { bubbles: true }),
							)

							// Check if length updated (this should fail if bug exists)
							lengthValue = lengthSignal.get()
							console.log(
								'Length after input event:',
								lengthValue,
							)
							// This assertion may fail, reproducing the component issue
							// assert.equal(lengthValue, 5, 'Length should be 5 after typing hello')

							// Dispatch change event
							input.dispatchEvent(
								new Event('change', { bubbles: true }),
							)

							// Check if value updated
							valueValue = valueSignal.get()
							console.log('Value after change event:', valueValue)
							// This assertion may fail, reproducing the component issue
							// assert.equal(valueValue, 'hello', 'Value should be hello after change event')

							// Now test WITH effect wrapper (should work)
							let reactiveLength = 0
							let reactiveValue = ''

							const lengthCleanup = effect(() => {
								reactiveLength = lengthSignal.get()
							})
							const valueCleanup = effect(() => {
								reactiveValue = valueSignal.get()
							})

							// Reset and test again
							input.value = 'world'
							input.dispatchEvent(
								new Event('input', { bubbles: true }),
							)

							assert.equal(
								reactiveLength,
								5,
								'Reactive length should update correctly',
							)

							input.dispatchEvent(
								new Event('change', { bubbles: true }),
							)

							assert.equal(
								reactiveValue,
								'world',
								'Reactive value should update correctly',
							)

							lengthCleanup()
							valueCleanup()
						} finally {
							container.remove()
						}
					})

					it('should work together in a component setup', async () => {
						const name = 'test-signal-producers-integration'
						const container = document.querySelector(name)
						await customElements.whenDefined(name)

						// Test fromSelector
						assert.equal(container.items.length, 2)

						// Test fromDescendants
						assert.equal(container.total, 30)

						// Test fromEvent
						assert.equal(container.lastInput, '')

						const input = container.querySelector('input')
						input.value = 'hello'
						input.dispatchEvent(
							new Event('input', { bubbles: true }),
						)
						assert.equal(container.lastInput, 'hello')

						// Add new item
						const newItem = document.createElement('div')
						newItem.className = 'item'
						newItem.dataset.value = '15'
						newItem.textContent = 'Item 3'
						container.appendChild(newItem)
						await microtask()

						assert.equal(container.items.length, 3)
						assert.equal(container.total, 45) // 10 + 20 + 15
					})
				})
			})
		</script>
	</body>
</html>
