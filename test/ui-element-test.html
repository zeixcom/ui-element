<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>UIElement Tests</title>
</head>
<body>

	<style>
		.visually-hidden {
			position: absolute;
			left: -10000px;
			top: auto;
			width: 1px;
			height: 1px;
			overflow: hidden;
		}

		my-counter {
			display: flex;
			flex-direction: row;
			gap: 1rem;

			& p {
				margin-block: 0.2rem;
			}
		}

		tab-list {

			> menu {
				list-style: none;
				display: flex;
				gap: 0.2rem;
				padding: 0;

				& button[aria-pressed="true"] {
					color: purple;
				}
			}

			> details {

				&:not([open]) {
					display: none;
				}

				&[aria-disabled] {
					pointer-events: none;
				}
			}

			&[accordion] {

				> menu {
					display: none;
				}

				> details:not([open]) {
					display: block;
				}
			}
		}

		lazy-load .error {
			color: red;
		}

		post-reply div {
			margin-left: 2rem;
		}
	</style>

	<void-component id="void">
		<h1>Hello from Server</h1>
	</void-component>
	<void-component id="void2">
		<h1>Hello from Server</h1>
	</void-component>
	<causal-component id="causal">
		<h1>Hello from Server</h1>
	</causal-component>
	<causal-component id="causal-with-ignored-attribute" heading="Hello from Attribute">
		<h1>Hello from Server</h1>
	</causal-component>
	<updating-component id="updating">
		<h1>Hello from Server</h1>
		<p>Number of unread messages: <span></span></p>
	</updating-component>
	<updating-component id="updating-with-string-attribute" heading="Hello from Attribute">
		<h1>Hello from Server</h1>
		<p>Number of unread messages: <span></span></p>
	</updating-component>
	<updating-component id="updating-with-number-attribute" count="42" step="0.1" value="3.14">
		<h1>Hello from Server</h1>
		<p>Number of unread messages: <span></span></p>
		<input type="number" />
	</updating-component>
	<updating-component id="updating-with-boolean-attribute" selected>
		<h1>Hello from Server</h1>
		<p>Number of unread messages: <span></span></p>
	</updating-component>
	<child-component id="orphan">
		<h1>Hello from Server</h1>
		<p>Text from Server</p>
	</child-component>
	<parent-component id="parent" heading="Hello from Attribute">
		<child-component id="child">
			<h1>Hello from Server</h1>
			<p>Text from Server</p>
		</child-component>
	</parent-component>
	<my-counter value="42">
		<p>Count: <span class="value">42</span></p>
		<p>Parity: <span class="parity">even</span></p>
		<p>Double: <span class="double">84</span></p>
		<div>
			<button class="decrement">â€“</button>
			<button class="increment">+</button>
		</div>
	</my-counter>
	<greeting-configurator>
		<input-field class="first">
			<input type="text" name="first" value="Jane" />
		</input-field>
		<input-field class="last">
			<input type="text" name="last" value="Doe" />
		</input-field>
		<input-checkbox>
			<input type="checkbox" name="fullname" />
		</input-checkbox>
		<hello-world>
			<p>
				<span class="greeting">Hello</span>
				<span class="name">World</span>
			</p>
		</hello-world>
	</greeting-configurator>
	<lazy-load src="/test/mock/lazy-load.html" id="lazy-success">
		<p class="loading" role="status">Loading...</p>
		<p class="error" role="alert" aria-live="polite" hidden></p>
	</lazy-load>
	<lazy-load src="/test/mock/404.html" id="lazy-error">
		<p class="loading" role="status">Loading...</p>
		<p class="error" role="alert" aria-live="polite" hidden></p>
	</lazy-load>
	<lazy-load src="/test/mock/recursion.html" id="lazy-recursion">
		<p class="loading" role="status">Loading...</p>
        <p class="error" role="alert" aria-live="polite" hidden></p>
	</lazy-load>
	<tab-list>
		<menu>
			<li><button type="button">Tab 1</button></li>
			<li><button type="button">Tab 2</button></li>
			<li><button type="button">Tab 3</button></li>
		</menu>
		<details open>
			<summary>Tab 1</summary>
			<p>Content of tab panel 1</p>
		</details>
		<details>
			<summary>Tab 2</summary>
			<p>Content of tab panel 2</p>
		</details>
		<details>
			<summary>Tab 3</summary>
			<p>Content of tab panel 3</p>
		</details>
	</tab-list>
	<template id="post-reply">
		<div>
            <p></p>
			<post-reply>
				<button type="button" class="reply-button">Reply</button>
				<form hidden>
					<label>
						<span>Message:</span>
						<textarea required></textarea>
					</label>
					<button type="submit">Submit</button>
				</form>
			</post-reply>
        </div>
	</template>
	<post-reply message="My two cents">
		<button type="button">Reply</button>
		<form hidden>
			<label>
				<span>Message:</span>
				<textarea required></textarea>
			</label>
			<button type="submit">Submit</button>
		</form>
	</post-reply>

	<script type="module">
		import { runTests } from '@web/test-runner-mocha'
		import { assert } from '@esm-bundle/chai'
		import {
			RESET, component, first, all, on, pass, batch, effect, enqueue,
			asBoolean, asInteger, asNumber, asString,
			setText, setProperty, setAttribute, toggleAttribute, toggleClass, setStyle,
			removeElement, dangerouslySetInnerHTML, insertTemplate
		} from '../'

		const wait = ms => new Promise(resolve => setTimeout(resolve, ms))
		const animationFrame = async () => new Promise(requestAnimationFrame)
		const normalizeText = text => text.replace(/\s+/g, ' ').trim()

		const LOADING_DELAY = 800 // Adjust this if tests for LazyLoad fail; needs to be high enough so initial loading message can be observed before it gets removed when async connectedCallback() finishes

		component('void-component', {}, () => [])

		component('causal-component', {
			heading: 'Hello from Internal State'
		}, () => [
			first('h1', setText('heading'))
		])

		component('updating-component', {
			heading: asString(),
			count: asInteger(),
			step: asNumber(),
			value: (host, value) => {
				if (value == null) return RESET
				const parsed = Number.isInteger(host.step)
					? parseInt(value, 10)
					: parseFloat(value) 
				return Number.isFinite(parsed) ? parsed : undefined
			},
			selected: asBoolean
		}, () => [
			first('h1', setText('heading'), toggleClass('selected')),
			first('span', setText('count')),
			first('input', setAttribute('step'), setProperty('value')),
		])

		component('child-component', {}, () => [
			first('h1', setText('heading')),
			first('p', setText('text'))
		])

		component('parent-component', {
			heading: asString(),
		}, (_, { heading }) => [
			first('child-component', pass({
				heading,
                text: heading.map(v => v.toUpperCase())
			}))
		])

		component('my-counter', {
			value: asInteger()
		}, (_, { value }) => [
			first('.decrement', on('click', () => {
				value.update(v => --v)
			})),
			first('.increment', on('click', () => {
				value.update(v => ++v)
			})),
			first('.value', setText('value')),
			first('.parity', setText(value.map(v => v % 2 ? 'odd' : 'even'))),
			first('.double', setText(value.map(v => v * 2)))
		])

		component('greeting-configurator', {}, host => {
			const firstName = host.querySelector('.first')
			const lastName = host.querySelector('.last')
			const fullName = host.querySelector('input-checkbox')
			return [
				first('hello-world', pass({
					name: () => fullName.checked
						? `${firstName.value} ${lastName.value}`
						: firstName.value
				}))
			]
		})

		component('hello-world', {
			greeting: asString()
		}, () => [
			first('span.greeting', setText('greeting')),
			first('span.name', setText('name'))
		])

		component('input-field', {
			value: asString()
		}, host => [
			first('input',
				setProperty('value'),
			    on('change', e => {
					host.value = e.target.value
				})
			)
		])

		component('input-checkbox', {
			checked: asBoolean
		}, host => [
			first('input',
				setProperty('checked'),
				on('change', e => {
					host.checked = e.target.checked
				})
			)
		])

		component('lazy-load', {
			src: (host, v) => { // Custom attribute parser
				if (!v) {
					host.error = 'No URL provided in src attribute'
					return ''
				} else if ((host.parentElement || host.getRootNode().host)?.closest(`${host.localName}[src="${v}"]`)) {
					host.error = 'Recursive loading detected'
					return ''
				}
				const url = new URL(v, location.href) // Ensure 'src' attribute is a valid URL
				if (url.origin === location.origin) // Sanity check for cross-origin URLs
					return url.toString()
				host.error = 'Invalid URL origin'
				return ''
			},
			content: (host, { src }) => async abort => { // Async Computed callback
				const url = src.get()
				if (!url) return ''
				try {
					const response = await fetch(url, { signal: abort })
					await wait(LOADING_DELAY)
					host.querySelector('.loading')?.remove()
					if (response.ok) return response.text()
					else host.error = response.statusText
				} catch (error) {
					host.error = error.message
				}
				return ''
			},
			error: '',
		}, (host, { error }) => [
			first('.error',
				setText(error),
				toggleAttribute('hidden', error.map(v => !v))
			),
			dangerouslySetInnerHTML('content', 'open')
		])

		component('tab-list', {
			accordion: asBoolean(),
			active: host => {
				() => { 
					const panels = Array.from(host.querySelectorAll('details'))
					for (let i = 0; i < panels.length; i++) {
						if (panels[i].hasAttribute('open')) return i
					}
					return 0
				}
			},
		}, (host, { accordion, active }) => [
			toggleAttribute('accordion'),
			all('menu button',
				on('click', (_, index) => () => active.set(index)),
				setProperty('ariaPressed', (_, index) => String(active.get() === index))
			),
			all('details',
				setProperty('open', (_, index) => !!(active.get() === index)),
				setAttribute('aria-disabled', () => String(!accordion.get()))
			),
			all('summary',
				toggleClass('visually-hidden', () => !accordion.get())
			)
		])

		component('post-reply', {
			message: '',
			formIsHidden: true
		}, (host, { message, formIsHidden }) => [
			first('button', on('click', () => {
				host.formIsHidden = false
			})),
			first('form',
				on('submit', e => {
					e.preventDefault()
					host.message = host.querySelector('textarea').value
					host.formIsHidden = true
				}),
				setProperty('hidden', formIsHidden)
			),
			insertTemplate(host.querySelector('template'), () => !!message.get())
		])

		runTests(() => {

			describe('Void component', function () {

				it('should be an instance of HTMLElement', async function () {
					const voidComponent = document.getElementById('void')
					assert.instanceOf(voidComponent, HTMLElement)
					assert.equal(voidComponent.localName, 'void-component')
				})

				it('should do nothing at all', async function () {
					const voidComponent = document.getElementById('void')
					await animationFrame()
					const textContent = normalizeText(voidComponent.querySelector('h1').textContent)
					assert.equal(textContent, 'Hello from Server', 'Should not change server-side rendered heading')
				})

				it('should return false with in for unset state', async function () {
					const voidComponent = document.getElementById('void')
					assert.equal('test' in voidComponent, false)
					assert.equal(voidComponent.hasOwnProperty('test'), false)
				})

				/* it('should create a new state with set()', async function () {
					const voidComponent = document.getElementById('void')
					voidComponent.set('foo', 'foo')
					await animationFrame()
					assert.equal(voidComponent.get('foo'), 'foo')
				})

				it('should return true with has() for set state', async function () {
					const voidComponent = document.getElementById('void')
					voidComponent.set('bar', 'bar')
					await animationFrame()
					assert.equal(voidComponent.has('bar'), true)
				})

				it('should update an existing state with set()', async function () {
					const voidComponent = document.getElementById('void')
					for (let i = 1; i <= 10; i++) {
						voidComponent.set('test', i)
					}
					await animationFrame()
					assert.equal(voidComponent.get('test'), 10)
				})

				it('should trigger dependent effects with set()', async function () {
					const voidComponent = document.getElementById('void2')
					voidComponent.set('foo', 'test', false)
					let effectDidRun = false
					effect(() => {
						voidComponent.get('foo')
						effectDidRun = true
					})
					await animationFrame()
					assert.isTrue(effectDidRun)
				})

				it('should trigger dependent effects with set() again after change', async function () {
					const voidComponent = document.getElementById('void2')
					voidComponent.set('foo', 'test', false)
					let effectDidRun = false
					effect(() => {
						voidComponent.get('foo')
						effectDidRun = true
					})
					voidComponent.set('foo', 'bar')
					await animationFrame()
					assert.isTrue(effectDidRun)
				})

				it('repeated set() should trigger dependent effect only once', async function () {
					const voidComponent = document.getElementById('void2')
					voidComponent.set('bar', 0)
					let result = 0
					batch(() => {
						for (let i = 1; i <= 10; i++) {
							voidComponent.set('bar', i)
						}
					})
					effect(() => {
						voidComponent.get('bar')
						result++
					})
					assert.equal(result, 1)
				})

				it('should return false with has() for deleted state', async function () {
					const voidComponent = document.getElementById('void')
					voidComponent.set('test', 'test')
					voidComponent.delete('test')
					await animationFrame()
					assert.equal(voidComponent.has('test'), false)
				}) */
			})

			describe('Causal component', function () {

				it('should update according to internal state', async function () {
					const causalComponent = document.getElementById('causal')
					await animationFrame()
					const textContent = normalizeText(causalComponent.querySelector('h1').textContent)
					assert.equal(textContent, 'Hello from Internal State', 'Should have initial heading from internal state')
				})

				it('should update when state is set', async function () {
					const causalComponent = document.getElementById('causal')
					causalComponent.heading = 'Hello from State'
					await animationFrame()
					const textContent = normalizeText(causalComponent.querySelector('h1').textContent)
					assert.equal(textContent, 'Hello from State', 'Should update text content from setting heading state')
				})

				it('should update after a delay when state is set', async function () {
					const causalComponent = document.getElementById('causal')
					const delay = Math.floor(Math.random() * 200)
					await wait(delay)
					causalComponent.heading = 'Hello from Delayed State'
					await animationFrame()
					const textContent = normalizeText(causalComponent.querySelector('h1').textContent)
					assert.equal(textContent, 'Hello from Delayed State', 'Should update text content from setting heading state after a delay')
				})

				it('should ignore non-observed attributes', async function () {
					const causalComponent = document.getElementById('causal-with-ignored-attribute')
					await animationFrame()
					const textContent = normalizeText(causalComponent.querySelector('h1').textContent)
					assert.equal(textContent, 'Hello from Internal State', 'Should have initial heading from internal state')
				})
			})

			describe('Updating component', function () {

				it('should do nothing if attribute is not set', async function () {
					const updatingComponent = document.getElementById('updating')
					await animationFrame()
					const textContent = normalizeText(updatingComponent.querySelector('h1').textContent)
					assert.equal(textContent, 'Hello from Server', 'Should not change server-side rendered heading')
				})

				it('should update from initial string attribute', async function () {
					const updatingComponent = document.getElementById('updating-with-string-attribute')
					await animationFrame()
					const textContent = normalizeText(updatingComponent.querySelector('h1').textContent)
					assert.equal(textContent, 'Hello from Attribute', 'Should have initial heading from string attribute')
				})

				it('should update from initial integer number attribute', async function () {
					const updatingComponent = document.getElementById('updating-with-number-attribute')
					await animationFrame()
					const textContent = normalizeText(updatingComponent.querySelector('span').textContent)
					assert.equal(textContent, '42', 'Should have initial count from numeric attribute')
				})

				it('should update from initial floating point number attribute', async function () {
					const updatingComponent = document.getElementById('updating-with-number-attribute')
					await animationFrame()
					const stepAttribute = updatingComponent.querySelector('input').getAttribute('step')
					assert.equal(stepAttribute, '0.1', 'Should have initial step attribute from floating point number attribute')
				})

				it('should update from initial custom parser attribute', async function () {
					const updatingComponent = document.getElementById('updating-with-number-attribute')
					await animationFrame()
					const valueAttribute = updatingComponent.querySelector('input').value
					assert.equal(valueAttribute, '3.14', 'Should have initial value attribute from custom parser attribute')
				})

				it('should add class from boolean attribute', async function () {
					const updatingComponent = document.getElementById('updating-with-boolean-attribute')
					await animationFrame()
					const className = updatingComponent.querySelector('h1').className
					assert.equal(className, 'selected', 'Should have initial class from boolean attribute')
				})

				it('should update when string attribute set', async function () {
					const updatingComponent = document.getElementById('updating-with-string-attribute')
					updatingComponent.setAttribute('heading', 'Hello from Changed Attribute')
					await animationFrame()
					const textContent = normalizeText(updatingComponent.querySelector('h1').textContent)
					assert.equal(textContent, 'Hello from Changed Attribute', 'Should update text content from setting heading attribute')
				})

				it('should update when numeric attribute is set', async function () {
					const updatingComponent = document.getElementById('updating-with-number-attribute')
					updatingComponent.setAttribute('count', '0')
					await animationFrame()
					const textContent = normalizeText(updatingComponent.querySelector('span').textContent)
					assert.equal(textContent, '0', 'Should update text content from setting count attribute')
				})

				it('should update when numeric state is set', async function () {
					const updatingComponent = document.getElementById('updating-with-number-attribute')
					updatingComponent.step = 1
					await animationFrame()
					const stepAttribute = updatingComponent.querySelector('input').getAttribute('step')
					assert.equal(stepAttribute, '1', 'Should update step attribute of input element from setting step state')
				})

				it('should update when numeric attribute is set, parsed as integer', async function () {
					const updatingComponent = document.getElementById('updating-with-number-attribute')
					updatingComponent.setAttribute('value', '1.14')
					await animationFrame()
					const valueAttribute = updatingComponent.querySelector('input').value
					assert.equal(valueAttribute, '1', 'Should update value attribute of input element from setting value attribute and parse it as defined')
				})

				it('should remove class when boolean attribute removed', async function () {
					const updatingComponent = document.getElementById('updating-with-boolean-attribute')
					updatingComponent.removeAttribute('selected')
					await animationFrame()
					const className = updatingComponent.querySelector('h1').className
					assert.equal(className, '', 'Should remove class from removing selected attribute')
				})

				it('should update when state is set', async function () {
					const updatingComponent = document.getElementById('updating-with-string-attribute')
					updatingComponent.heading = 'Hello from State'
					await animationFrame()
					const textContent = normalizeText(updatingComponent.querySelector('h1').textContent)
					assert.equal(textContent, 'Hello from State', 'Should update text content from setting heading state')
				})
			})
				
			describe('Orphan child component', function () {

				it('should do nothing at all', async function () {
					const orphanComponent = document.getElementById('orphan')
					await animationFrame()
					const headingContent = normalizeText(orphanComponent.querySelector('h1').textContent)
					const textContent = normalizeText(orphanComponent.querySelector('p').textContent)
					assert.equal(headingContent, 'Hello from Server', 'Should not change server-side rendered heading')
					assert.equal(textContent, 'Text from Server', 'Should not change server-side rendered text')
				})

			})

			describe('Child component', function () {

				it('should receive state from attribute of parent component', async function () {
					const childComponent = document.getElementById('child')
					await customElements.whenDefined(childComponent.localName)
					const headingContent = childComponent.querySelector('h1').textContent
					assert.equal(headingContent, 'Hello from Attribute', 'Should have initial heading from attribute of parent component')
				})

				it('should receive derived state from attribute of parent component', async function () {
					const childComponent = document.getElementById('child')
					await customElements.whenDefined(childComponent.localName)
					const textContent = normalizeText(childComponent.querySelector('p').textContent)
					assert.equal(textContent, 'Hello from Attribute'.toUpperCase(), 'Should have initial text derived from attribute of parent component')
				})

				it('should receive passed and derived states from changed attribute of parent component', async function () {
					const parentComponent = document.getElementById('parent')
					const childComponent = document.getElementById('child')
					parentComponent.setAttribute('heading', 'Hello from Changed Attribute')
					await animationFrame()
					const headingContent = normalizeText(childComponent.querySelector('h1').textContent)
					const textContent = normalizeText(childComponent.querySelector('p').textContent)
					assert.equal(headingContent, 'Hello from Changed Attribute', 'Should have changed heading from attribute of parent component')
					assert.equal(textContent, 'Hello from Changed Attribute'.toUpperCase(), 'Should have changed text derived from attribute of parent component')
				})

				it('should change heading if inherited state is set', async function () {
					const parentComponent = document.getElementById('parent')
					const childComponent = document.getElementById('child')
					parentComponent.heading = 'Hello from State on Parent'
					await animationFrame()
					const headingContent = childComponent.querySelector('h1').textContent
					assert.equal(headingContent, 'Hello from State on Parent', 'Should have changed heading from state of parent component')
				})

			})

			describe('My counter', function () {

				it('should increment and decrement', async function () {
					const counter = document.querySelector('my-counter')
					const decrement = counter.querySelector('.decrement')
					const increment = counter.querySelector('.increment')
					const value = counter.querySelector('.value')
					assert.equal(counter.value, 42, 'Should have initial value from attribute')
					assert.equal(normalizeText(value.textContent), '42', 'Should have initial textContent from attribute')
					decrement.click()
					assert.equal(counter.value, 41, 'Should decrement value')
					await animationFrame()
					assert.equal(normalizeText(value.textContent), '41', 'Should have updated textContent from decrement')
					increment.click()
					assert.equal(counter.value, 42, 'Should increment value')
					await animationFrame()
					assert.equal(normalizeText(value.textContent), '42', 'Should have updated textContent from increment')
				})

				it('should update derived values', async function () {
					const counter = document.querySelector('my-counter')
					const decrement = counter.querySelector('.decrement')
					const parity = counter.querySelector('.parity')
					const double = counter.querySelector('.double')
					assert.equal(normalizeText(parity.textContent), 'even', 'Should have derived parity textContent from attribute')
					assert.equal(normalizeText(double.textContent), '84', 'Should have derived double textContent from attribute')
					decrement.click()
					await animationFrame()
					assert.equal(normalizeText(parity.textContent), 'odd', 'Should have changed derived parity textContent')
					assert.equal(normalizeText(double.textContent), '82', 'Should have decremented derived double textContent')
				})

			})

			describe('Greeting Configurator', function () {

				it('should display greeting', async function () {
					const configurator = document.querySelector('greeting-configurator')
					const helloWorld = configurator.querySelector('hello-world')
					const greeting = helloWorld.querySelector('p')
					assert.equal(normalizeText(greeting.textContent), 'Hello Jane', 'Should have initial greeting')
					helloWorld.greeting = 'Hi'
					await animationFrame()
					assert.equal(normalizeText(greeting.textContent), 'Hi Jane', 'Should have updated greeting from state')
				})

				it('should update name if first name changes', async function () {
					const configurator = document.querySelector('greeting-configurator')
					const first = configurator.querySelector('.first')
					const input = first.querySelector('input')
					const helloWorld = configurator.querySelector('hello-world')
					const greeting = helloWorld.querySelector('p')
					input.value = 'Esther'
					input.dispatchEvent(new Event('change'))
					await animationFrame()
					assert.equal(normalizeText(greeting.textContent), 'Hi Esther', 'Should update if first name changes')
				})

				it('should not update name if last name changes', async function () {
					const configurator = document.querySelector('greeting-configurator')
					const last = configurator.querySelector('.last')
					const input = last.querySelector('input')
					const helloWorld = configurator.querySelector('hello-world')
					const greeting = helloWorld.querySelector('p')
					input.value = 'Brunner'
					input.dispatchEvent(new Event('change'))
					await animationFrame()
					assert.equal(normalizeText(greeting.textContent), 'Hi Esther', 'Should not update if last name changes')
				})

				it('should update greeting if use fullname is checked or unchecked', async function () {
					const configurator = document.querySelector('greeting-configurator')
					const fullname = configurator.querySelector('input-checkbox')
					const input = fullname.querySelector('input')
					const helloWorld = configurator.querySelector('hello-world')
					const greeting = helloWorld.querySelector('p')
					input.checked = true
					input.dispatchEvent(new Event('change'))
					await animationFrame()
					assert.equal(normalizeText(greeting.textContent), 'Hi Esther Brunner', 'Should update if use fullname is checked')
					input.checked = false
					input.dispatchEvent(new Event('change'))
					await animationFrame()
					assert.equal(normalizeText(greeting.textContent), 'Hi Esther', 'Should update if use fullname is unchecked')
				})

			})

			describe('Lazy Load', function () {

				it('should display loading status initially', function () {
					const lazyComponent = document.getElementById('lazy-success')
					assert.equal(normalizeText(lazyComponent.querySelector('.loading').textContent), 'Loading...')
				})

				it('should display lazy loaded content', async function () {
					const lazyComponent = document.getElementById('lazy-success')
					await wait(LOADING_DELAY)
					const shadow = lazyComponent.shadowRoot
					assert.instanceOf(shadow, DocumentFragment, 'Should have a shadow root')
					assert.equal(normalizeText(shadow.querySelector('p').textContent), 'Lazy loaded content', 'Should display lazy loaded content')
					assert.equal(lazyComponent.querySelector('.error').hidden, true, 'Should hide error container')
					assert.equal(lazyComponent.querySelector('.loading') === null, true, 'Should remove loading status')
				})

				it('should display error message', async function () {
					const lazyComponent = document.getElementById('lazy-error')
					await wait(LOADING_DELAY)
					assert.equal(normalizeText(lazyComponent.querySelector('.error').textContent), 'Not Found', 'Should display error message')
					assert.equal(lazyComponent.querySelector('.loading') === null, true, 'Should remove loading status')
				})

				it('should prevent recursive loading', async function () {
					const lazyComponent = document.getElementById('lazy-recursion')
					await wait(LOADING_DELAY)
					const shadow = lazyComponent.shadowRoot
					assert.instanceOf(shadow, DocumentFragment, 'Should have a shadow root')
					const lazySubComponent = shadow.querySelector('lazy-load')
					const errorElement = lazySubComponent.querySelector('.error')
					assert.isFalse(errorElement.hidden, 'Error message should be visible')
					assert.equal(errorElement.textContent, 'Recursive loading detected', 'Should display recursion error message')
				})

			})

			describe('Tab List', function () {

				it('should mark the first button as active', async function() {
					const tabList = document.querySelector('tab-list')
                    const buttons = tabList.querySelectorAll('button')
					await animationFrame()
                    assert.equal(buttons[0].ariaPressed, 'true', 'Should have the first button marked as active')
				})

				it('should change the active tab when a button is clicked', async function() {
					const tabList = document.querySelector('tab-list')
                    const buttons = tabList.querySelectorAll('button')
                    buttons[1].click()
                    await animationFrame()
                    assert.equal(buttons[0].ariaPressed, 'false', 'Should have the first button marked as inactive')
                    assert.equal(buttons[1].ariaPressed, 'true', 'Should have the second button marked as active')
                })

				it('should display the content of the active tab', async function() {
					const tabList = document.querySelector('tab-list')
                    const buttons = tabList.querySelectorAll('button')
                    await animationFrame()
                    assert.equal(tabList.querySelectorAll('details')[1].hasAttribute('open'), true, 'Should mark the second details as open')
                    buttons[0].click()
                    await animationFrame()
                    assert.equal(tabList.querySelectorAll('details')[0].hasAttribute('open'), true, 'Should mark the second details as not open')
                    assert.equal(tabList.querySelectorAll('details')[0].hasAttribute('open'), true, 'Should mark the first details as open')
				})

			})

			describe('InsertRecursion', function () {
				it('should not cause infinite loops or memory leaks', async function () {
					const parentCount = document.querySelectorAll('recursion-parent').length
					const childCount = document.querySelectorAll('recursion-child').length
					assert.isAtMost(parentCount, 3, 'Should not create more than 3 recursion-parent components')
					assert.isAtMost(childCount, 3, 'Should not create more than 3 recursion-child components')
				})
			})
		})
	</script>
</body>
</html>